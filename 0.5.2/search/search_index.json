{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Hiero addon","text":"<p>Hiero integration for AYON.</p>"},{"location":"license.html","title":"License","text":"<pre><code>                             Apache License\n                       Version 2.0, January 2004\n                    http://www.apache.org/licenses/\n</code></pre> <p>TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION</p> <ol> <li> <p>Definitions.</p> <p>\"License\" shall mean the terms and conditions for use, reproduction,   and distribution as defined by Sections 1 through 9 of this document.</p> <p>\"Licensor\" shall mean the copyright owner or entity authorized by   the copyright owner that is granting the License.</p> <p>\"Legal Entity\" shall mean the union of the acting entity and all   other entities that control, are controlled by, or are under common   control with that entity. For the purposes of this definition,   \"control\" means (i) the power, direct or indirect, to cause the   direction or management of such entity, whether by contract or   otherwise, or (ii) ownership of fifty percent (50%) or more of the   outstanding shares, or (iii) beneficial ownership of such entity.</p> <p>\"You\" (or \"Your\") shall mean an individual or Legal Entity   exercising permissions granted by this License.</p> <p>\"Source\" form shall mean the preferred form for making modifications,   including but not limited to software source code, documentation   source, and configuration files.</p> <p>\"Object\" form shall mean any form resulting from mechanical   transformation or translation of a Source form, including but   not limited to compiled object code, generated documentation,   and conversions to other media types.</p> <p>\"Work\" shall mean the work of authorship, whether in Source or   Object form, made available under the License, as indicated by a   copyright notice that is included in or attached to the work   (an example is provided in the Appendix below).</p> <p>\"Derivative Works\" shall mean any work, whether in Source or Object   form, that is based on (or derived from) the Work and for which the   editorial revisions, annotations, elaborations, or other modifications   represent, as a whole, an original work of authorship. For the purposes   of this License, Derivative Works shall not include works that remain   separable from, or merely link (or bind by name) to the interfaces of,   the Work and Derivative Works thereof.</p> <p>\"Contribution\" shall mean any work of authorship, including   the original version of the Work and any modifications or additions   to that Work or Derivative Works thereof, that is intentionally   submitted to Licensor for inclusion in the Work by the copyright owner   or by an individual or Legal Entity authorized to submit on behalf of   the copyright owner. For the purposes of this definition, \"submitted\"   means any form of electronic, verbal, or written communication sent   to the Licensor or its representatives, including but not limited to   communication on electronic mailing lists, source code control systems,   and issue tracking systems that are managed by, or on behalf of, the   Licensor for the purpose of discussing and improving the Work, but   excluding communication that is conspicuously marked or otherwise   designated in writing by the copyright owner as \"Not a Contribution.\"</p> <p>\"Contributor\" shall mean Licensor and any individual or Legal Entity   on behalf of whom a Contribution has been received by Licensor and   subsequently incorporated within the Work.</p> </li> <li> <p>Grant of Copyright License. Subject to the terms and conditions of       this License, each Contributor hereby grants to You a perpetual,       worldwide, non-exclusive, no-charge, royalty-free, irrevocable       copyright license to reproduce, prepare Derivative Works of,       publicly display, publicly perform, sublicense, and distribute the       Work and such Derivative Works in Source or Object form.</p> </li> <li> <p>Grant of Patent License. Subject to the terms and conditions of       this License, each Contributor hereby grants to You a perpetual,       worldwide, non-exclusive, no-charge, royalty-free, irrevocable       (except as stated in this section) patent license to make, have made,       use, offer to sell, sell, import, and otherwise transfer the Work,       where such license applies only to those patent claims licensable       by such Contributor that are necessarily infringed by their       Contribution(s) alone or by combination of their Contribution(s)       with the Work to which such Contribution(s) was submitted. If You       institute patent litigation against any entity (including a       cross-claim or counterclaim in a lawsuit) alleging that the Work       or a Contribution incorporated within the Work constitutes direct       or contributory patent infringement, then any patent licenses       granted to You under this License for that Work shall terminate       as of the date such litigation is filed.</p> </li> <li> <p>Redistribution. You may reproduce and distribute copies of the       Work or Derivative Works thereof in any medium, with or without       modifications, and in Source or Object form, provided that You       meet the following conditions:</p> <p>(a) You must give any other recipients of the Work or       Derivative Works a copy of this License; and</p> <p>(b) You must cause any modified files to carry prominent notices       stating that You changed the files; and</p> <p>(c) You must retain, in the Source form of any Derivative Works       that You distribute, all copyright, patent, trademark, and       attribution notices from the Source form of the Work,       excluding those notices that do not pertain to any part of       the Derivative Works; and</p> <p>(d) If the Work includes a \"NOTICE\" text file as part of its       distribution, then any Derivative Works that You distribute must       include a readable copy of the attribution notices contained       within such NOTICE file, excluding those notices that do not       pertain to any part of the Derivative Works, in at least one       of the following places: within a NOTICE text file distributed       as part of the Derivative Works; within the Source form or       documentation, if provided along with the Derivative Works; or,       within a display generated by the Derivative Works, if and       wherever such third-party notices normally appear. The contents       of the NOTICE file are for informational purposes only and       do not modify the License. You may add Your own attribution       notices within Derivative Works that You distribute, alongside       or as an addendum to the NOTICE text from the Work, provided       that such additional attribution notices cannot be construed       as modifying the License.</p> <p>You may add Your own copyright statement to Your modifications and   may provide additional or different license terms and conditions   for use, reproduction, or distribution of Your modifications, or   for any such Derivative Works as a whole, provided Your use,   reproduction, and distribution of the Work otherwise complies with   the conditions stated in this License.</p> </li> <li> <p>Submission of Contributions. Unless You explicitly state otherwise,       any Contribution intentionally submitted for inclusion in the Work       by You to the Licensor shall be under the terms and conditions of       this License, without any additional terms or conditions.       Notwithstanding the above, nothing herein shall supersede or modify       the terms of any separate license agreement you may have executed       with Licensor regarding such Contributions.</p> </li> <li> <p>Trademarks. This License does not grant permission to use the trade       names, trademarks, service marks, or product names of the Licensor,       except as required for reasonable and customary use in describing the       origin of the Work and reproducing the content of the NOTICE file.</p> </li> <li> <p>Disclaimer of Warranty. Unless required by applicable law or       agreed to in writing, Licensor provides the Work (and each       Contributor provides its Contributions) on an \"AS IS\" BASIS,       WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or       implied, including, without limitation, any warranties or conditions       of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A       PARTICULAR PURPOSE. You are solely responsible for determining the       appropriateness of using or redistributing the Work and assume any       risks associated with Your exercise of permissions under this License.</p> </li> <li> <p>Limitation of Liability. In no event and under no legal theory,       whether in tort (including negligence), contract, or otherwise,       unless required by applicable law (such as deliberate and grossly       negligent acts) or agreed to in writing, shall any Contributor be       liable to You for damages, including any direct, indirect, special,       incidental, or consequential damages of any character arising as a       result of this License or out of the use or inability to use the       Work (including but not limited to damages for loss of goodwill,       work stoppage, computer failure or malfunction, or any and all       other commercial damages or losses), even if such Contributor       has been advised of the possibility of such damages.</p> </li> <li> <p>Accepting Warranty or Additional Liability. While redistributing       the Work or Derivative Works thereof, You may choose to offer,       and charge a fee for, acceptance of support, warranty, indemnity,       or other liability obligations and/or rights consistent with this       License. However, in accepting such obligations, You may act only       on Your own behalf and on Your sole responsibility, not on behalf       of any other Contributor, and only if You agree to indemnify,       defend, and hold each Contributor harmless for any liability       incurred by, or claims asserted against, such Contributor by reason       of your accepting any such warranty or additional liability.</p> </li> </ol> <p>END OF TERMS AND CONDITIONS</p> <p>APPENDIX: How to apply the Apache License to your work.</p> <pre><code>  To apply the Apache License to your work, attach the following\n  boilerplate notice, with the fields enclosed by brackets \"[]\"\n  replaced with your own identifying information. (Don't include\n  the brackets!)  The text should be enclosed in the appropriate\n  comment syntax for the file format. We also recommend that a\n  file or class name and description of purpose be included on the\n  same \"printed page\" as the copyright notice for easier\n  identification within third-party archives.\n</code></pre> <p>Copyright [yyyy][name of copyright owner]</p> <p>Licensed under the Apache License, Version 2.0 (the \"License\");    you may not use this file except in compliance with the License.    You may obtain a copy of the License at</p> <pre><code>   http://www.apache.org/licenses/LICENSE-2.0\n</code></pre> <p>Unless required by applicable law or agreed to in writing, software    distributed under the License is distributed on an \"AS IS\" BASIS,    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.    See the License for the specific language governing permissions and    limitations under the License.</p>"},{"location":"autoapi/summary.html","title":"Summary","text":"<ul> <li>client<ul> <li>ayon_hiero<ul> <li>addon</li> <li>api<ul> <li>constants</li> <li>events</li> <li>launchforhiero</li> <li>lib</li> <li>menu</li> <li>otio<ul> <li>hiero_export</li> <li>hiero_import</li> <li>utils</li> </ul> </li> <li>pipeline</li> <li>plugin</li> <li>startup<ul> <li>Python<ul> <li>Startup<ul> <li>SpreadsheetExport</li> <li>Startup</li> <li>otioexporter<ul> <li>OTIOExportTask</li> <li>OTIOExportUI</li> </ul> </li> <li>project_helpers</li> <li>selection_tracker</li> <li>setFrameRate</li> </ul> </li> <li>StartupUI<ul> <li>PimpMySpreadsheet</li> <li>Purge</li> <li>nukeStyleKeyboardShortcuts</li> <li>otioimporter<ul> <li>OTIOImport</li> </ul> </li> <li>setPosterFrame</li> </ul> </li> </ul> </li> </ul> </li> <li>tags</li> <li>workio</li> </ul> </li> <li>plugins<ul> <li>create<ul> <li>create_shot_clip</li> <li>create_workfile</li> </ul> </li> <li>load<ul> <li>load_clip</li> <li>load_effects</li> </ul> </li> <li>publish<ul> <li>collect_audio</li> <li>collect_clip_effects</li> <li>collect_frame_tag_instances</li> <li>collect_otio_timeline</li> <li>collect_plates</li> <li>collect_shots</li> <li>collect_tag_tasks</li> <li>collect_workfile</li> <li>extract_clip_effects</li> <li>extract_frames</li> <li>extract_thumbnail</li> <li>extract_workfile</li> <li>integrate_version_up_workfile</li> </ul> </li> <li>publish_old_workflow<ul> <li>collect_tag_comments</li> <li>precollect_retime</li> </ul> </li> </ul> </li> <li>vendor<ul> <li>google<ul> <li>protobuf<ul> <li>any_pb2</li> <li>api_pb2</li> <li>compiler<ul> <li>plugin_pb2</li> </ul> </li> <li>descriptor</li> <li>descriptor_database</li> <li>descriptor_pb2</li> <li>descriptor_pool</li> <li>duration_pb2</li> <li>empty_pb2</li> <li>field_mask_pb2</li> <li>internal<ul> <li>_parameterized</li> <li>api_implementation</li> <li>builder</li> <li>containers</li> <li>decoder</li> <li>encoder</li> <li>enum_type_wrapper</li> <li>extension_dict</li> <li>message_listener</li> <li>message_set_extensions_pb2</li> <li>missing_enum_values_pb2</li> <li>more_extensions_dynamic_pb2</li> <li>more_extensions_pb2</li> <li>more_messages_pb2</li> <li>no_package_pb2</li> <li>python_message</li> <li>type_checkers</li> <li>well_known_types</li> <li>wire_format</li> </ul> </li> <li>json_format</li> <li>message</li> <li>message_factory</li> <li>proto_builder</li> <li>pyext<ul> <li>cpp_message</li> <li>python_pb2</li> </ul> </li> <li>reflection</li> <li>service</li> <li>service_reflection</li> <li>source_context_pb2</li> <li>struct_pb2</li> <li>symbol_database</li> <li>text_encoding</li> <li>text_format</li> <li>timestamp_pb2</li> <li>type_pb2</li> <li>util<ul> <li>json_format_pb2</li> <li>json_format_proto3_pb2</li> </ul> </li> <li>wrappers_pb2</li> </ul> </li> </ul> </li> </ul> </li> <li>version</li> </ul> </li> </ul> </li> <li>server<ul> <li>settings<ul> <li>common</li> <li>create_plugins</li> <li>filters</li> <li>imageio</li> <li>loader_plugins</li> <li>main</li> <li>publish_plugins</li> <li>scriptsmenu</li> </ul> </li> </ul> </li> </ul>"},{"location":"autoapi/client/ayon_hiero/index.html","title":"ayon_hiero","text":""},{"location":"autoapi/client/ayon_hiero/addon.html","title":"addon","text":""},{"location":"autoapi/client/ayon_hiero/version.html","title":"version","text":"<p>Package declaring AYON addon 'hiero' version.</p>"},{"location":"autoapi/client/ayon_hiero/api/index.html","title":"api","text":""},{"location":"autoapi/client/ayon_hiero/api/index.html#client.ayon_hiero.api.ClipLoader","title":"<code>ClipLoader</code>","text":"Source code in <code>client/ayon_hiero/api/plugin.py</code> <pre><code>class ClipLoader:\n\n    active_bin = None\n    data = dict()\n\n    def __init__(self, cls, context, path, **options):\n        \"\"\" Initialize object\n\n        Arguments:\n            cls (ayon_core.api.Loader): plugin object\n            context (dict): loader plugin context\n            options (dict)[optional]: possible keys:\n                projectBinPath: \"path/to/binItem\"\n\n        \"\"\"\n        self.__dict__.update(cls.__dict__)\n        self.context = context\n        self.active_project = lib.get_current_project()\n        self.fname = path\n\n        # try to get value from options or evaluate key value for `handles`\n        self.with_handles = options.get(\"handles\") or bool(\n            options.get(\"handles\") is True)\n        # try to get value from options or evaluate key value for `load_how`\n        self.sequencial_load = options.get(\"sequentially\") or bool(\n            \"Sequentially in order\" in options.get(\"load_how\", \"\"))\n        # try to get value from options or evaluate key value for `load_to`\n        self.new_sequence = options.get(\"newSequence\") or bool(\n            \"New timeline\" in options.get(\"load_to\", \"\"))\n        self.clip_name_template = options.get(\n            \"clipNameTemplate\") or \"{asset}_{subset}_{representation}\"\n        assert self._populate_data(), str(\n            \"Cannot Load selected data, look into database \"\n            \"or call your supervisor\")\n\n        # inject folder data to representation dict\n        folder_entity = self.context[\"folder\"]\n        self.data[\"folderAttributes\"] = folder_entity[\"attrib\"]\n\n        # add active components to class\n        if self.new_sequence:\n            if options.get(\"sequence\"):\n                # if multiselection is set then use options sequence\n                self.active_sequence = options[\"sequence\"]\n            else:\n                # create new sequence\n                self.active_sequence = lib.get_current_sequence(new=True)\n                self.active_sequence.setFramerate(\n                    hiero.core.TimeBase.fromString(\n                        str(self.data[\"folderAttributes\"][\"fps\"])))\n        else:\n            self.active_sequence = lib.get_current_sequence()\n\n        if options.get(\"track\"):\n            # if multiselection is set then use options track\n            self.active_track = options[\"track\"]\n        else:\n            self.active_track = lib.get_current_track(\n                self.active_sequence, self.data[\"track_name\"])\n\n    def _populate_data(self):\n        \"\"\" Gets context and convert it to self.data\n        data structure:\n            {\n                \"name\": \"assetName_productName_representationName\"\n                \"path\": \"path/to/file/created/by/get_repr..\",\n                \"binPath\": \"projectBinPath\",\n            }\n        \"\"\"\n        # create name\n        repr = self.context[\"representation\"]\n        repr_cntx = repr[\"context\"]\n        folder_path = self.context[\"folder\"][\"path\"]\n        product_name = self.context[\"product\"][\"name\"]\n        representation = repr[\"name\"]\n        self.data[\"clip_name\"] = self.clip_name_template.format(**repr_cntx)\n        self.data[\"track_name\"] = \"_\".join([product_name, representation])\n        self.data[\"versionAttributes\"] = self.context[\"version\"][\"attrib\"]\n        # gets file path\n        file = get_representation_path_from_context(self.context)\n        if not file:\n            repr_id = repr[\"id\"]\n            log.warning(\n                \"Representation id `{}` is failing to load\".format(repr_id))\n            return None\n        self.data[\"path\"] = file.replace(\"\\\\\", \"/\")\n\n        # convert to hashed path\n        if repr_cntx.get(\"frame\"):\n            self._fix_path_hashes()\n\n        # solve project bin structure path\n        hierarchy = \"Loader{}\".format(folder_path)\n\n        self.data[\"binPath\"] = hierarchy\n\n        return True\n\n    def _fix_path_hashes(self):\n        \"\"\" Convert file path where it is needed padding with hashes\n        \"\"\"\n        file = self.data[\"path\"]\n        if \"#\" not in file:\n            frame = self.context[\"representation\"][\"context\"].get(\"frame\")\n            padding = len(frame)\n            file = file.replace(frame, \"#\" * padding)\n        self.data[\"path\"] = file\n\n    def _make_track_item(self, source_bin_item, audio=False):\n        \"\"\" Create track item with \"\"\"\n\n        clip = source_bin_item.activeItem()\n\n        # add to track as clip item\n        if not audio:\n            track_item = hiero.core.TrackItem(\n                self.data[\"clip_name\"], hiero.core.TrackItem.kVideo)\n        else:\n            track_item = hiero.core.TrackItem(\n                self.data[\"clip_name\"], hiero.core.TrackItem.kAudio)\n\n        track_item.setSource(clip)\n        track_item.setSourceIn(self.handle_start)\n        track_item.setTimelineIn(self.timeline_in)\n        track_item.setSourceOut((self.media_duration) - self.handle_end)\n        track_item.setTimelineOut(self.timeline_out)\n        track_item.setPlaybackSpeed(1)\n        self.active_track.addTrackItem(track_item)\n\n        return track_item\n\n    def load(self):\n        # create project bin for the media to be imported into\n        self.active_bin = lib.create_bin(self.data[\"binPath\"])\n\n        # create mediaItem in active project bin\n        # create clip media\n        self.media = hiero.core.MediaSource(self.data[\"path\"])\n        self.media_duration = int(self.media.duration())\n\n        # get handles\n        version_attributes = self.data[\"versionAttributes\"]\n        self.handle_start = version_attributes.get(\"handleStart\")\n        self.handle_end = version_attributes.get(\"handleEnd\")\n        if self.handle_start is None:\n            self.handle_start = self.data[\"folderAttributes\"][\"handleStart\"]\n        if self.handle_end is None:\n            self.handle_end = self.data[\"folderAttributes\"][\"handleEnd\"]\n\n        self.handle_start = int(self.handle_start)\n        self.handle_end = int(self.handle_end)\n\n        if self.sequencial_load:\n            last_track_item = lib.get_track_items(\n                sequence_name=self.active_sequence.name(),\n                track_name=self.active_track.name()\n            )\n            if len(last_track_item) == 0:\n                last_timeline_out = 0\n            else:\n                last_track_item = last_track_item[-1]\n                last_timeline_out = int(last_track_item.timelineOut()) + 1\n            self.timeline_in = last_timeline_out\n            self.timeline_out = last_timeline_out + int(\n                self.data[\"folderAttributes\"][\"clipOut\"]\n                - self.data[\"folderAttributes\"][\"clipIn\"])\n        else:\n            self.timeline_in = int(self.data[\"folderAttributes\"][\"clipIn\"])\n            self.timeline_out = int(self.data[\"folderAttributes\"][\"clipOut\"])\n\n        log.debug(\"__ self.timeline_in: {}\".format(self.timeline_in))\n        log.debug(\"__ self.timeline_out: {}\".format(self.timeline_out))\n\n        # check if slate is included\n        slate_on = \"slate\" in self.context[\"version\"][\"data\"].get(\n            \"families\", [])\n        log.debug(\"__ slate_on: {}\".format(slate_on))\n\n        # if slate is on then remove the slate frame from beginning\n        if slate_on:\n            self.media_duration -= 1\n            self.handle_start += 1\n\n        # create Clip from Media\n        clip = hiero.core.Clip(self.media)\n        clip.setName(self.data[\"clip_name\"])\n\n        # add Clip to bin if not there yet\n        if self.data[\"clip_name\"] not in [\n                b.name() for b in self.active_bin.items()]:\n            bin_item = hiero.core.BinItem(clip)\n            self.active_bin.addItem(bin_item)\n\n        # just make sure the clip is created\n        # there were some cases were hiero was not creating it\n        source_bin_item = None\n        for item in self.active_bin.items():\n            if self.data[\"clip_name\"] == item.name():\n                source_bin_item = item\n        if not source_bin_item:\n            log.warning(\"Problem with created Source clip: `{}`\".format(\n                self.data[\"clip_name\"]))\n\n        # include handles\n        if self.with_handles:\n            self.timeline_in -= self.handle_start\n            self.timeline_out += self.handle_end\n            self.handle_start = 0\n            self.handle_end = 0\n\n        # make track item from source in bin as item\n        track_item = self._make_track_item(source_bin_item)\n\n        log.info(\"Loading clips: `{}`\".format(self.data[\"clip_name\"]))\n        return track_item\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/api/index.html#client.ayon_hiero.api.ClipLoader.__init__","title":"<code>__init__(cls, context, path, **options)</code>","text":"<p>Initialize object</p> <p>Parameters:</p> Name Type Description Default <code>cls</code> <code>Loader</code> <p>plugin object</p> required <code>context</code> <code>dict</code> <p>loader plugin context</p> required <code>options</code> <code>dict)[optional]</code> <p>possible keys: projectBinPath: \"path/to/binItem\"</p> <code>{}</code> Source code in <code>client/ayon_hiero/api/plugin.py</code> <pre><code>def __init__(self, cls, context, path, **options):\n    \"\"\" Initialize object\n\n    Arguments:\n        cls (ayon_core.api.Loader): plugin object\n        context (dict): loader plugin context\n        options (dict)[optional]: possible keys:\n            projectBinPath: \"path/to/binItem\"\n\n    \"\"\"\n    self.__dict__.update(cls.__dict__)\n    self.context = context\n    self.active_project = lib.get_current_project()\n    self.fname = path\n\n    # try to get value from options or evaluate key value for `handles`\n    self.with_handles = options.get(\"handles\") or bool(\n        options.get(\"handles\") is True)\n    # try to get value from options or evaluate key value for `load_how`\n    self.sequencial_load = options.get(\"sequentially\") or bool(\n        \"Sequentially in order\" in options.get(\"load_how\", \"\"))\n    # try to get value from options or evaluate key value for `load_to`\n    self.new_sequence = options.get(\"newSequence\") or bool(\n        \"New timeline\" in options.get(\"load_to\", \"\"))\n    self.clip_name_template = options.get(\n        \"clipNameTemplate\") or \"{asset}_{subset}_{representation}\"\n    assert self._populate_data(), str(\n        \"Cannot Load selected data, look into database \"\n        \"or call your supervisor\")\n\n    # inject folder data to representation dict\n    folder_entity = self.context[\"folder\"]\n    self.data[\"folderAttributes\"] = folder_entity[\"attrib\"]\n\n    # add active components to class\n    if self.new_sequence:\n        if options.get(\"sequence\"):\n            # if multiselection is set then use options sequence\n            self.active_sequence = options[\"sequence\"]\n        else:\n            # create new sequence\n            self.active_sequence = lib.get_current_sequence(new=True)\n            self.active_sequence.setFramerate(\n                hiero.core.TimeBase.fromString(\n                    str(self.data[\"folderAttributes\"][\"fps\"])))\n    else:\n        self.active_sequence = lib.get_current_sequence()\n\n    if options.get(\"track\"):\n        # if multiselection is set then use options track\n        self.active_track = options[\"track\"]\n    else:\n        self.active_track = lib.get_current_track(\n            self.active_sequence, self.data[\"track_name\"])\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/api/index.html#client.ayon_hiero.api.CreatorWidget","title":"<code>CreatorWidget</code>","text":"<p>               Bases: <code>QDialog</code></p> Source code in <code>client/ayon_hiero/api/plugin.py</code> <pre><code>class CreatorWidget(QtWidgets.QDialog):\n\n    # output items\n    items = {}\n\n    def __init__(self, name, info, ui_inputs, parent=None):\n        super(CreatorWidget, self).__init__(parent)\n\n        self.setObjectName(name)\n\n        self.setWindowFlags(\n            QtCore.Qt.Window\n            | QtCore.Qt.CustomizeWindowHint\n            | QtCore.Qt.WindowTitleHint\n            | QtCore.Qt.WindowCloseButtonHint\n            | QtCore.Qt.WindowStaysOnTopHint\n        )\n        self.setWindowTitle(name or \"AYON Creator Input\")\n        self.resize(500, 700)\n\n        # Where inputs and labels are set\n        self.content_widget = [QtWidgets.QWidget(self)]\n        top_layout = QtWidgets.QFormLayout(self.content_widget[0])\n        top_layout.setObjectName(\"ContentLayout\")\n        top_layout.addWidget(Spacer(5, self))\n\n        # first add widget tag line\n        top_layout.addWidget(QtWidgets.QLabel(info))\n\n        # main dynamic layout\n        self.scroll_area = QtWidgets.QScrollArea(self, widgetResizable=True)\n        self.scroll_area.setVerticalScrollBarPolicy(\n            QtCore.Qt.ScrollBarAsNeeded)\n        self.scroll_area.setVerticalScrollBarPolicy(\n            QtCore.Qt.ScrollBarAlwaysOn)\n        self.scroll_area.setHorizontalScrollBarPolicy(\n            QtCore.Qt.ScrollBarAlwaysOff)\n        self.scroll_area.setWidgetResizable(True)\n\n        self.content_widget.append(self.scroll_area)\n\n        scroll_widget = QtWidgets.QWidget(self)\n        in_scroll_area = QtWidgets.QVBoxLayout(scroll_widget)\n        self.content_layout = [in_scroll_area]\n\n        # add preset data into input widget layout\n        self.items = self.populate_widgets(ui_inputs)\n        self.scroll_area.setWidget(scroll_widget)\n\n        # Confirmation buttons\n        btns_widget = QtWidgets.QWidget(self)\n        btns_layout = QtWidgets.QHBoxLayout(btns_widget)\n\n        cancel_btn = QtWidgets.QPushButton(\"Cancel\")\n        btns_layout.addWidget(cancel_btn)\n\n        ok_btn = QtWidgets.QPushButton(\"Ok\")\n        btns_layout.addWidget(ok_btn)\n\n        # Main layout of the dialog\n        main_layout = QtWidgets.QVBoxLayout(self)\n        main_layout.setContentsMargins(10, 10, 10, 10)\n        main_layout.setSpacing(0)\n\n        # adding content widget\n        for w in self.content_widget:\n            main_layout.addWidget(w)\n\n        main_layout.addWidget(btns_widget)\n\n        ok_btn.clicked.connect(self._on_ok_clicked)\n        cancel_btn.clicked.connect(self._on_cancel_clicked)\n\n        stylesheet = load_stylesheet()\n        self.setStyleSheet(stylesheet)\n\n    def _on_ok_clicked(self):\n        self.result = self.value(self.items)\n        self.close()\n\n    def _on_cancel_clicked(self):\n        self.result = None\n        self.close()\n\n    def value(self, data, new_data=None):\n        new_data = new_data or dict()\n        for k, v in data.items():\n            new_data[k] = {\n                \"target\": None,\n                \"value\": None\n            }\n            if v[\"type\"] == \"dict\":\n                new_data[k][\"target\"] = v[\"target\"]\n                new_data[k][\"value\"] = self.value(v[\"value\"])\n            if v[\"type\"] == \"section\":\n                new_data.pop(k)\n                new_data = self.value(v[\"value\"], new_data)\n            elif getattr(v[\"value\"], \"currentText\", None):\n                new_data[k][\"target\"] = v[\"target\"]\n                new_data[k][\"value\"] = v[\"value\"].currentText()\n            elif getattr(v[\"value\"], \"isChecked\", None):\n                new_data[k][\"target\"] = v[\"target\"]\n                new_data[k][\"value\"] = v[\"value\"].isChecked()\n            elif getattr(v[\"value\"], \"value\", None):\n                new_data[k][\"target\"] = v[\"target\"]\n                new_data[k][\"value\"] = v[\"value\"].value()\n            elif getattr(v[\"value\"], \"text\", None):\n                new_data[k][\"target\"] = v[\"target\"]\n                new_data[k][\"value\"] = v[\"value\"].text()\n\n        return new_data\n\n    def camel_case_split(self, text):\n        matches = re.finditer(\n            '.+?(?:(?&lt;=[a-z])(?=[A-Z])|(?&lt;=[A-Z])(?=[A-Z][a-z])|$)', text)\n        return \" \".join([str(m.group(0)).capitalize() for m in matches])\n\n    def create_row(self, layout, type, text, **kwargs):\n        value_keys = [\"setText\", \"setCheckState\", \"setValue\", \"setChecked\"]\n\n        # get type attribute from qwidgets\n        attr = getattr(QtWidgets, type)\n\n        # convert label text to normal capitalized text with spaces\n        label_text = self.camel_case_split(text)\n\n        # assign the new text to label widget\n        label = QtWidgets.QLabel(label_text)\n        label.setObjectName(\"LineLabel\")\n\n        # create attribute name text strip of spaces\n        attr_name = text.replace(\" \", \"\")\n\n        # create attribute and assign default values\n        setattr(\n            self,\n            attr_name,\n            attr(parent=self))\n\n        # assign the created attribute to variable\n        item = getattr(self, attr_name)\n\n        # set attributes to item which are not values\n        for func, val in kwargs.items():\n            if func in value_keys:\n                continue\n\n            if getattr(item, func):\n                log.debug(\"Setting {} to {}\".format(func, val))\n                func_attr = getattr(item, func)\n                if isinstance(val, tuple):\n                    func_attr(*val)\n                else:\n                    func_attr(val)\n\n        # set values to item\n        for value_item in value_keys:\n            if value_item not in kwargs:\n                continue\n            if getattr(item, value_item):\n                getattr(item, value_item)(kwargs[value_item])\n\n        # add to layout\n        layout.addRow(label, item)\n\n        return item\n\n    def populate_widgets(self, data, content_layout=None):\n        \"\"\"\n        Populate widget from input dict.\n\n        Each plugin has its own set of widget rows defined in dictionary\n        each row values should have following keys: `type`, `target`,\n        `label`, `order`, `value` and optionally also `toolTip`.\n\n        Args:\n            data (dict): widget rows or organized groups defined\n                         by types `dict` or `section`\n            content_layout (QtWidgets.QFormLayout)[optional]: used when nesting\n\n        Returns:\n            dict: redefined data dict updated with created widgets\n\n        \"\"\"\n\n        content_layout = content_layout or self.content_layout[-1]\n        # fix order of process by defined order value\n        ordered_keys = list(data.keys())\n        for k, v in data.items():\n            try:\n                # try removing a key from index which should\n                # be filled with new\n                ordered_keys.pop(v[\"order\"])\n            except IndexError:\n                pass\n            # add key into correct order\n            ordered_keys.insert(v[\"order\"], k)\n\n        # process ordered\n        for k in ordered_keys:\n            v = data[k]\n            tool_tip = v.get(\"toolTip\", \"\")\n            if v[\"type\"] == \"dict\":\n                # adding spacer between sections\n                self.content_layout.append(QtWidgets.QWidget(self))\n                content_layout.addWidget(self.content_layout[-1])\n                self.content_layout[-1].setObjectName(\"sectionHeadline\")\n\n                headline = QtWidgets.QVBoxLayout(self.content_layout[-1])\n                headline.addWidget(Spacer(20, self))\n                headline.addWidget(QtWidgets.QLabel(v[\"label\"]))\n\n                # adding nested layout with label\n                self.content_layout.append(QtWidgets.QWidget(self))\n                self.content_layout[-1].setObjectName(\"sectionContent\")\n\n                nested_content_layout = QtWidgets.QFormLayout(\n                    self.content_layout[-1])\n                nested_content_layout.setObjectName(\"NestedContentLayout\")\n                content_layout.addWidget(self.content_layout[-1])\n\n                # add nested key as label\n                data[k][\"value\"] = self.populate_widgets(\n                    v[\"value\"], nested_content_layout)\n\n            if v[\"type\"] == \"section\":\n                # adding spacer between sections\n                self.content_layout.append(QtWidgets.QWidget(self))\n                content_layout.addWidget(self.content_layout[-1])\n                self.content_layout[-1].setObjectName(\"sectionHeadline\")\n\n                headline = QtWidgets.QVBoxLayout(self.content_layout[-1])\n                headline.addWidget(Spacer(20, self))\n                headline.addWidget(QtWidgets.QLabel(v[\"label\"]))\n\n                # adding nested layout with label\n                self.content_layout.append(QtWidgets.QWidget(self))\n                self.content_layout[-1].setObjectName(\"sectionContent\")\n\n                nested_content_layout = QtWidgets.QFormLayout(\n                    self.content_layout[-1])\n                nested_content_layout.setObjectName(\"NestedContentLayout\")\n                content_layout.addWidget(self.content_layout[-1])\n\n                # add nested key as label\n                data[k][\"value\"] = self.populate_widgets(\n                    v[\"value\"], nested_content_layout)\n\n            elif v[\"type\"] == \"QLineEdit\":\n                data[k][\"value\"] = self.create_row(\n                    content_layout, \"QLineEdit\", v[\"label\"],\n                    setText=v[\"value\"], setToolTip=tool_tip)\n            elif v[\"type\"] == \"QComboBox\":\n                data[k][\"value\"] = self.create_row(\n                    content_layout, \"QComboBox\", v[\"label\"],\n                    addItems=v[\"value\"], setToolTip=tool_tip)\n            elif v[\"type\"] == \"QCheckBox\":\n                data[k][\"value\"] = self.create_row(\n                    content_layout, \"QCheckBox\", v[\"label\"],\n                    setChecked=v[\"value\"], setToolTip=tool_tip)\n            elif v[\"type\"] == \"QSpinBox\":\n                data[k][\"value\"] = self.create_row(\n                    content_layout, \"QSpinBox\", v[\"label\"],\n                    setValue=v[\"value\"],\n                    setDisplayIntegerBase=10000,\n                    setRange=(0, 99999), setMinimum=0,\n                    setMaximum=100000, setToolTip=tool_tip)\n\n        return data\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/api/index.html#client.ayon_hiero.api.CreatorWidget.populate_widgets","title":"<code>populate_widgets(data, content_layout=None)</code>","text":"<p>Populate widget from input dict.</p> <p>Each plugin has its own set of widget rows defined in dictionary each row values should have following keys: <code>type</code>, <code>target</code>, <code>label</code>, <code>order</code>, <code>value</code> and optionally also <code>toolTip</code>.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>widget rows or organized groups defined          by types <code>dict</code> or <code>section</code></p> required <code>content_layout</code> <code>QtWidgets.QFormLayout)[optional]</code> <p>used when nesting</p> <code>None</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>redefined data dict updated with created widgets</p> Source code in <code>client/ayon_hiero/api/plugin.py</code> <pre><code>def populate_widgets(self, data, content_layout=None):\n    \"\"\"\n    Populate widget from input dict.\n\n    Each plugin has its own set of widget rows defined in dictionary\n    each row values should have following keys: `type`, `target`,\n    `label`, `order`, `value` and optionally also `toolTip`.\n\n    Args:\n        data (dict): widget rows or organized groups defined\n                     by types `dict` or `section`\n        content_layout (QtWidgets.QFormLayout)[optional]: used when nesting\n\n    Returns:\n        dict: redefined data dict updated with created widgets\n\n    \"\"\"\n\n    content_layout = content_layout or self.content_layout[-1]\n    # fix order of process by defined order value\n    ordered_keys = list(data.keys())\n    for k, v in data.items():\n        try:\n            # try removing a key from index which should\n            # be filled with new\n            ordered_keys.pop(v[\"order\"])\n        except IndexError:\n            pass\n        # add key into correct order\n        ordered_keys.insert(v[\"order\"], k)\n\n    # process ordered\n    for k in ordered_keys:\n        v = data[k]\n        tool_tip = v.get(\"toolTip\", \"\")\n        if v[\"type\"] == \"dict\":\n            # adding spacer between sections\n            self.content_layout.append(QtWidgets.QWidget(self))\n            content_layout.addWidget(self.content_layout[-1])\n            self.content_layout[-1].setObjectName(\"sectionHeadline\")\n\n            headline = QtWidgets.QVBoxLayout(self.content_layout[-1])\n            headline.addWidget(Spacer(20, self))\n            headline.addWidget(QtWidgets.QLabel(v[\"label\"]))\n\n            # adding nested layout with label\n            self.content_layout.append(QtWidgets.QWidget(self))\n            self.content_layout[-1].setObjectName(\"sectionContent\")\n\n            nested_content_layout = QtWidgets.QFormLayout(\n                self.content_layout[-1])\n            nested_content_layout.setObjectName(\"NestedContentLayout\")\n            content_layout.addWidget(self.content_layout[-1])\n\n            # add nested key as label\n            data[k][\"value\"] = self.populate_widgets(\n                v[\"value\"], nested_content_layout)\n\n        if v[\"type\"] == \"section\":\n            # adding spacer between sections\n            self.content_layout.append(QtWidgets.QWidget(self))\n            content_layout.addWidget(self.content_layout[-1])\n            self.content_layout[-1].setObjectName(\"sectionHeadline\")\n\n            headline = QtWidgets.QVBoxLayout(self.content_layout[-1])\n            headline.addWidget(Spacer(20, self))\n            headline.addWidget(QtWidgets.QLabel(v[\"label\"]))\n\n            # adding nested layout with label\n            self.content_layout.append(QtWidgets.QWidget(self))\n            self.content_layout[-1].setObjectName(\"sectionContent\")\n\n            nested_content_layout = QtWidgets.QFormLayout(\n                self.content_layout[-1])\n            nested_content_layout.setObjectName(\"NestedContentLayout\")\n            content_layout.addWidget(self.content_layout[-1])\n\n            # add nested key as label\n            data[k][\"value\"] = self.populate_widgets(\n                v[\"value\"], nested_content_layout)\n\n        elif v[\"type\"] == \"QLineEdit\":\n            data[k][\"value\"] = self.create_row(\n                content_layout, \"QLineEdit\", v[\"label\"],\n                setText=v[\"value\"], setToolTip=tool_tip)\n        elif v[\"type\"] == \"QComboBox\":\n            data[k][\"value\"] = self.create_row(\n                content_layout, \"QComboBox\", v[\"label\"],\n                addItems=v[\"value\"], setToolTip=tool_tip)\n        elif v[\"type\"] == \"QCheckBox\":\n            data[k][\"value\"] = self.create_row(\n                content_layout, \"QCheckBox\", v[\"label\"],\n                setChecked=v[\"value\"], setToolTip=tool_tip)\n        elif v[\"type\"] == \"QSpinBox\":\n            data[k][\"value\"] = self.create_row(\n                content_layout, \"QSpinBox\", v[\"label\"],\n                setValue=v[\"value\"],\n                setDisplayIntegerBase=10000,\n                setRange=(0, 99999), setMinimum=0,\n                setMaximum=100000, setToolTip=tool_tip)\n\n    return data\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/api/index.html#client.ayon_hiero.api.HieroHost","title":"<code>HieroHost</code>","text":"<p>               Bases: <code>HostBase</code>, <code>IWorkfileHost</code>, <code>ILoadHost</code>, <code>IPublishHost</code></p> Source code in <code>client/ayon_hiero/api/pipeline.py</code> <pre><code>class HieroHost(\n    HostBase, IWorkfileHost, ILoadHost, IPublishHost\n):\n    name = \"hiero\"\n\n    def open_workfile(self, filepath):\n        return open_file(filepath)\n\n    def save_workfile(self, filepath=None):\n        return save_file(filepath)\n\n    def get_current_workfile(self):\n        return current_file()\n\n    def workfile_has_unsaved_changes(self):\n        return has_unsaved_changes()\n\n    def get_workfile_extensions(self):\n        return file_extensions()\n\n    def get_containers(self):\n        return ls()\n\n    def install(self):\n        \"\"\"Installing all requirements for hiero host\"\"\"\n\n        # adding all events\n        events.register_events()\n\n        log.info(\"Registering Hiero plug-ins..\")\n        pyblish.register_host(\"hiero\")\n        pyblish.register_plugin_path(PUBLISH_PATH)\n        register_loader_plugin_path(LOAD_PATH)\n        register_creator_plugin_path(CREATE_PATH)\n\n        # install menu\n        menu.menu_install()\n        menu.add_scripts_menu()\n\n        # register hiero events\n        events.register_hiero_events()\n\n    def get_context_data(self):\n        # TODO: implement to support persisting context attributes\n        return {}\n\n    def update_context_data(self, data, changes):\n        # TODO: implement to support persisting context attributes\n        pass\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/api/index.html#client.ayon_hiero.api.HieroHost.install","title":"<code>install()</code>","text":"<p>Installing all requirements for hiero host</p> Source code in <code>client/ayon_hiero/api/pipeline.py</code> <pre><code>def install(self):\n    \"\"\"Installing all requirements for hiero host\"\"\"\n\n    # adding all events\n    events.register_events()\n\n    log.info(\"Registering Hiero plug-ins..\")\n    pyblish.register_host(\"hiero\")\n    pyblish.register_plugin_path(PUBLISH_PATH)\n    register_loader_plugin_path(LOAD_PATH)\n    register_creator_plugin_path(CREATE_PATH)\n\n    # install menu\n    menu.menu_install()\n    menu.add_scripts_menu()\n\n    # register hiero events\n    events.register_hiero_events()\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/api/index.html#client.ayon_hiero.api.PublishClip","title":"<code>PublishClip</code>","text":"<p>Convert a track item to publishable instance</p> <p>Parameters:</p> Name Type Description Default <code>track_item</code> <code>TrackItem</code> <p>hiero track item object</p> required <code>kwargs</code> <code>optional</code> <p>additional data needed for rename=True (presets)</p> required <p>Returns:</p> Type Description <p>hiero.core.TrackItem: hiero track item object with AYON tag</p> Source code in <code>client/ayon_hiero/api/plugin.py</code> <pre><code>class PublishClip:\n    \"\"\"\n    Convert a track item to publishable instance\n\n    Args:\n        track_item (hiero.core.TrackItem): hiero track item object\n        kwargs (optional): additional data needed for rename=True (presets)\n\n    Returns:\n        hiero.core.TrackItem: hiero track item object with AYON tag\n    \"\"\"\n    tag_data = {}\n\n    types = {\n        \"shot\": \"shot\",\n        \"folder\": \"folder\",\n        \"episode\": \"episode\",\n        \"sequence\": \"sequence\",\n        \"track\": \"sequence\",\n    }\n\n    # parents search pattern\n    parents_search_pattern = r\"\\{([a-z]*?)\\}\"\n\n    # default templates for non-ui use\n    rename_default = False\n    hierarchy_default = \"{_folder_}/{_sequence_}/{_track_}\"\n    clip_name_default = \"shot_{_trackIndex_:0&gt;3}_{_clipIndex_:0&gt;4}\"\n    base_product_variant_default = \"&lt;track_name&gt;\"\n    review_source_default = None\n    product_type_default = \"plate\"\n    count_from_default = 10\n    count_steps_default = 10\n    vertical_sync_default = False\n    driving_layer_default = \"\"\n\n    # Define which keys of the pre create data should also be 'tag data'\n    tag_keys = {\n        # renameHierarchy\n        \"hierarchy\",\n        # hierarchyData\n        \"folder\", \"episode\", \"sequence\", \"track\", \"shot\",\n        # publish settings\n        \"audio\", \"sourceResolution\",\n        # shot attributes\n        \"workfileFrameStart\", \"handleStart\", \"handleEnd\",\n        # instance attributes data\n        \"reviewableSource\",\n    }\n\n    def __init__(\n            self,\n            track_item,\n            vertical_clip_match,\n            vertical_clip_used,\n            pre_create_data=None,\n            data=None,\n            rename_index=0):\n\n        self.vertical_clip_match = vertical_clip_match\n        self.vertical_clip_used = vertical_clip_used\n\n        self.rename_index = rename_index\n\n        # adding ui inputs if any\n        self.pre_create_data = pre_create_data or {}\n\n        # get main parent objects\n        self.track_item = track_item\n        sequence_name = lib.get_current_sequence().name()\n        self.sequence_name = str(sequence_name).replace(\" \", \"_\")\n\n        # track item (clip) main attributes\n        self.ti_name = track_item.name()\n        self.ti_index = int(track_item.eventNumber())\n\n        # get track name and index\n        track_name = track_item.parent().name()\n        self.track_name = str(track_name).replace(\" \", \"_\")\n        self.track_index = int(track_item.parent().trackIndex())\n\n        # adding instance_data[\"productType\"] into tag\n        if data:\n            self.tag_data.update(data)\n\n        # populate default data before we get other attributes\n        self._populate_track_item_default_data()\n\n        # use all populated default data to create all important attributes\n        self._populate_attributes()\n\n        # create parents with correct types\n        self._create_parents()\n\n    def convert(self):\n\n        # solve track item data and add them to tag data\n        self._convert_to_tag_data()\n\n        # if track name is in review track name and also if driving track name\n        # is not in review track name: skip tag creation\n        if (self.track_name in self.reviewable_source) and (\n            self.driving_layer not in self.reviewable_source\n        ):\n            return\n\n        # deal with clip name\n        new_name = self.tag_data.pop(\"newClipName\")\n\n        if self.rename:\n            # rename track item\n            self.track_item.setName(new_name)\n            self.tag_data[\"folderName\"] = new_name\n        else:\n            self.tag_data[\"folderName\"] = self.ti_name\n            self.tag_data[\"hierarchyData\"][\"shot\"] = self.ti_name\n\n        # AYON unique identifier\n        folder_path = \"/{}/{}\".format(\n            self.tag_data[\"hierarchy\"],\n            self.tag_data[\"folderName\"]\n        )\n        self.tag_data[\"folderPath\"] = folder_path\n\n        return self.track_item\n\n    def _populate_track_item_default_data(self):\n        \"\"\" Populate default formatting data from track item. \"\"\"\n\n        self.track_item_default_data = {\n            \"_folder_\": \"shots\",\n            \"_sequence_\": self.sequence_name,\n            \"_track_\": self.track_name,\n            \"_clip_\": self.ti_name,\n            \"_trackIndex_\": self.track_index,\n            \"_clipIndex_\": self.ti_index\n        }\n\n    def _populate_attributes(self):\n        \"\"\" Populate main object attributes. \"\"\"\n        # track item frame range and parent track name for vertical sync check\n        self.clip_in = int(self.track_item.timelineIn())\n        self.clip_out = int(self.track_item.timelineOut())\n\n        # define ui inputs if non gui mode was used\n        self.shot_num = self.ti_index\n        log.debug(\n            \"____ self.shot_num: {}\".format(self.shot_num))\n\n        # publisher ui attribute inputs or default values if gui was not used\n        def get(key):\n            \"\"\"Shorthand access for code readability\"\"\"\n            return self.pre_create_data.get(key)\n\n        # ui_inputs data or default values if gui was not used\n        self.rename = self.pre_create_data.get(\n            \"clipRename\", self.rename_default)\n        self.clip_name = get(\"clipName\") or self.clip_name_default\n        self.hierarchy = get(\"hierarchy\") or self.hierarchy_default\n        self.count_from = get(\"countFrom\") or self.count_from_default\n        self.count_steps = get(\"countSteps\") or self.count_steps_default\n        self.base_product_variant = (\n            get(\"clipVariant\") or self.base_product_variant_default)\n        self.product_type = get(\"productType\") or self.product_type_default\n        self.vertical_sync = get(\"vSyncOn\") or self.vertical_sync_default\n        self.driving_layer = get(\"vSyncTrack\") or self.driving_layer_default\n        self.driving_layer = self.driving_layer.replace(\" \", \"_\")\n        self.review_source = (\n            get(\"reviewableSource\") or self.review_source_default)\n        self.audio = get(\"audio\") or False\n\n        self.hierarchy_data = {\n            key: get(key) or self.track_item_default_data[key]\n            for key in [\"folder\", \"episode\", \"sequence\", \"track\", \"shot\"]\n        }\n\n        # build product name from layer name\n        if self.base_product_variant == \"&lt;track_name&gt;\":\n            self.variant = self.track_name\n        else:\n            self.variant = self.base_product_variant\n\n        # create product for publishing\n        self.product_name = f\"{self.product_type}{self.variant.capitalize()}\"\n\n    def _replace_hash_to_expression(self, name, text):\n        \"\"\" Replace hash with number in correct padding. \"\"\"\n        _spl = text.split(\"#\")\n        _len = (len(_spl) - 1)\n        _repl = \"{{{0}:0&gt;{1}}}\".format(name, _len)\n        return text.replace((\"#\" * _len), _repl)\n\n    def _convert_to_tag_data(self):\n        \"\"\" Convert internal data to tag data.\n\n        Populating the tag data into internal variable self.tag_data\n        \"\"\"\n        # define vertical sync attributes\n        hero_track = True\n        self.reviewable_source = \"\"\n        if (\n            self.vertical_sync\n            and self.track_name != self.driving_layer\n        ):\n            # check if track name is not in driving layer\n            # if it is not then define vertical sync as None\n            hero_track = False\n\n        # increasing steps by index of rename iteration\n        self.count_steps *= self.rename_index\n\n        hierarchy_formatting_data = {}\n        hierarchy_data = deepcopy(self.hierarchy_data)\n        _data = self.track_item_default_data.copy()\n\n        # in case we are running creators headless default\n        # precreate data values are used\n        if self.pre_create_data:\n\n            # adding tag metadata from ui\n            for _key, _value in self.pre_create_data.items():\n                # backward compatibility for reviewableSource (2024.11.08)\n                if (\n                    _key == \"reviewableSource\"\n                    and \"reviewTrack\" in self.tag_keys\n                ):\n                    self.tag_data.pop(\"reviewTrack\")\n                    self.tag_data[\"reviewableSource\"] = _value\n                if _key in self.tag_keys:\n                    self.tag_data[_key] = _value\n\n            # driving layer is set as positive match\n            if hero_track or self.vertical_sync:\n                # mark review layer\n                if self.review_source and (\n                        self.review_source != self.review_source_default):\n                    # if review layer is defined and not the same as default\n                    self.reviewable_source = self.review_source\n                # shot num calculate\n                if self.rename_index == 0:\n                    self.shot_num = self.count_from\n                else:\n                    self.shot_num = self.count_from + self.count_steps\n\n            # clip name sequence number\n            _data.update({\"shot\": self.shot_num})\n\n            # solve # in test to pythonic expression\n            for _key, _value in hierarchy_data.items():\n                if \"#\" not in _value:\n                    continue\n                hierarchy_data[_key] = self._replace_hash_to_expression(\n                    _key, _value)\n\n            # fill up pythonic expresisons in hierarchy data\n            for _key, _value in hierarchy_data.items():\n                formatted_value = _value.format(**_data)\n                hierarchy_formatting_data[_key] = formatted_value\n                self.tag_data[_key] = formatted_value\n        else:\n            # if no gui mode then just pass default data\n            hierarchy_formatting_data = hierarchy_data\n\n        tag_instance_data = self._solve_tag_instance_data(\n            hierarchy_formatting_data\n        )\n\n        tag_instance_data.update({\"heroTrack\": True})\n        if hero_track and self.vertical_sync:\n            self.vertical_clip_match.update(\n                {(self.clip_in, self.clip_out): tag_instance_data}\n            )\n\n        if not hero_track and self.vertical_sync:\n            # driving layer is set as negative match\n            for (hero_in, hero_out), hero_data in self.vertical_clip_match.items():  # noqa\n                \"\"\"Iterate over all clips in vertical sync match\n\n                If clip frame range is outside of hero clip frame range\n                then skip this clip and do not add to hierarchical shared\n                metadata to them.\n                \"\"\"\n                if self.clip_in &lt; hero_in or self.clip_out &gt; hero_out:\n                    continue\n\n                _distrib_data = deepcopy(hero_data)\n                _distrib_data[\"heroTrack\"] = False\n\n                # form used clip unique key\n                data_product_name = hero_data[\"productName\"]\n                new_clip_name = hero_data[\"newClipName\"]\n\n                # get used names list for duplicity check\n                used_names_list = self.vertical_clip_used.setdefault(\n                    f\"{new_clip_name}{data_product_name}\", [])\n\n                clip_product_name = self.product_name\n                variant = self.variant\n\n                # in case track name and product name is the same then add\n                if self.variant == self.track_name:\n                    clip_product_name = self.product_name\n\n                # add track index in case duplicity of names in hero data\n                # INFO: this is for case where hero clip product name\n                #    is the same as current clip product name\n                if clip_product_name in data_product_name:\n                    clip_product_name = (\n                        f\"{clip_product_name}{self.track_index}\")\n                    variant = f\"{variant}{self.track_index}\"\n\n                # in case track clip product name had been already used\n                # then add product name with clip index\n                if clip_product_name in used_names_list:\n                    clip_product_name = (\n                        f\"{clip_product_name}{self.rename_index}\")\n                    variant = f\"{variant}{self.rename_index}\"\n\n                _distrib_data[\"productName\"] = clip_product_name\n                _distrib_data[\"variant\"] = variant\n                # assign data to return hierarchy data to tag\n                tag_instance_data = _distrib_data\n\n                # add used product name to used list to avoid duplicity\n                used_names_list.append(clip_product_name)\n                break\n\n        # add data to return data dict\n        self.tag_data.update(tag_instance_data)\n\n        # add uuid to tag data\n        self.tag_data[\"uuid\"] = str(uuid.uuid4())\n\n        # add review track only to hero track\n        if hero_track and self.reviewable_source:\n            self.tag_data[\"reviewTrack\"] = self.reviewable_source\n        else:\n            self.tag_data.update({\"reviewTrack\": None})\n\n        # add only review related data if reviewable source is set\n        if self.reviewable_source:\n            review_switch = True\n            reviewable_source = self.reviewable_source\n            #\n            if self.vertical_sync and not hero_track:\n                review_switch = False\n                reviewable_source = False\n\n            if review_switch:\n                self.tag_data[\"review\"] = True\n            else:\n                self.tag_data.pop(\"review\", None)\n\n            if reviewable_source:\n                self.tag_data[\"reviewableSource\"] = reviewable_source\n            else:\n                self.tag_data.pop(\"reviewableSource\", None)\n\n    def _solve_tag_instance_data(self, hierarchy_formatting_data):\n        \"\"\" Solve tag data from hierarchy data and templates. \"\"\"\n        # fill up clip name and hierarchy keys\n        hierarchy_filled = self.hierarchy.format(**hierarchy_formatting_data)\n        clip_name_filled = self.clip_name.format(**hierarchy_formatting_data)\n\n        # remove shot from hierarchy data: is not needed anymore\n        hierarchy_formatting_data.pop(\"shot\")\n\n        return {\n            \"newClipName\": clip_name_filled,\n            \"hierarchy\": hierarchy_filled,\n            \"parents\": self.parents,\n            \"hierarchyData\": hierarchy_formatting_data,\n            \"productName\": self.product_name,\n            \"productType\": self.product_type,\n            \"variant\": self.variant,\n        }\n\n    def _convert_to_entity(self, src_type, template):\n        \"\"\" Converting input key to key with type. \"\"\"\n        # convert to entity type\n        folder_type = self.types.get(src_type, None)\n\n        assert folder_type, \"Missing folder type for `{}`\".format(\n            src_type\n        )\n        formatting_data = {}\n        for _k, _v in self.hierarchy_data.items():\n            value = _v.format(\n                **self.track_item_default_data)\n            formatting_data[_k] = value\n\n        return {\n            \"entity_type\": folder_type,\n            \"folder_type\": folder_type,\n            \"entity_name\": template.format(**formatting_data)\n        }\n\n    def _create_parents(self):\n        \"\"\" Create parents and return it in list. \"\"\"\n        self.parents = []\n\n        pattern = re.compile(self.parents_search_pattern)\n\n        par_split = [(pattern.findall(t).pop(), t)\n                     for t in self.hierarchy.split(\"/\")]\n\n        for type_, template in par_split:\n            parent = self._convert_to_entity(type_, template)\n            self.parents.append(parent)\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/api/index.html#client.ayon_hiero.api.SequenceLoader","title":"<code>SequenceLoader</code>","text":"<p>               Bases: <code>LoaderPlugin</code></p> <p>A basic SequenceLoader for Resolve</p> <p>This will implement the basic behavior for a loader to inherit from that will containerize the reference and will implement the <code>remove</code> and <code>update</code> logic.</p> Source code in <code>client/ayon_hiero/api/plugin.py</code> <pre><code>class SequenceLoader(LoaderPlugin):\n    \"\"\"A basic SequenceLoader for Resolve\n\n    This will implement the basic behavior for a loader to inherit from that\n    will containerize the reference and will implement the `remove` and\n    `update` logic.\n\n    \"\"\"\n\n    options = [\n        qargparse.Boolean(\n            \"handles\",\n            label=\"Include handles\",\n            default=0,\n            help=\"Load with handles or without?\"\n        ),\n        qargparse.Choice(\n            \"load_to\",\n            label=\"Where to load clips\",\n            items=[\n                \"Current timeline\",\n                \"New timeline\"\n            ],\n            default=\"Current timeline\",\n            help=\"Where do you want clips to be loaded?\"\n        ),\n        qargparse.Choice(\n            \"load_how\",\n            label=\"How to load clips\",\n            items=[\n                \"Original timing\",\n                \"Sequentially in order\"\n            ],\n            default=\"Original timing\",\n            help=\"Would you like to place it at original timing?\"\n        )\n    ]\n\n    def load(\n        self,\n        context,\n        name=None,\n        namespace=None,\n        options=None\n    ):\n        pass\n\n    def update(self, container, context):\n        \"\"\"Update an existing `container`\n        \"\"\"\n        pass\n\n    def remove(self, container):\n        \"\"\"Remove an existing `container`\n        \"\"\"\n        pass\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/api/index.html#client.ayon_hiero.api.SequenceLoader.remove","title":"<code>remove(container)</code>","text":"<p>Remove an existing <code>container</code></p> Source code in <code>client/ayon_hiero/api/plugin.py</code> <pre><code>def remove(self, container):\n    \"\"\"Remove an existing `container`\n    \"\"\"\n    pass\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/api/index.html#client.ayon_hiero.api.SequenceLoader.update","title":"<code>update(container, context)</code>","text":"<p>Update an existing <code>container</code></p> Source code in <code>client/ayon_hiero/api/plugin.py</code> <pre><code>def update(self, container, context):\n    \"\"\"Update an existing `container`\n    \"\"\"\n    pass\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/api/index.html#client.ayon_hiero.api.apply_colorspace_project","title":"<code>apply_colorspace_project()</code>","text":"<p>Apply colorspaces from settings.</p> <p>Due to not being able to set the project settings through the Python API, we need to do use some dubious code to find the widgets and set them. It is possible to set the project settings without traversing through the widgets but it involves reading the hrox files from disk with XML, so no in-memory support. See https://community.foundry.com/discuss/topic/137771/change-a-project-s-default-color-transform-with-python  # noqa for more details.</p> Source code in <code>client/ayon_hiero/api/lib.py</code> <pre><code>def apply_colorspace_project():\n    \"\"\"Apply colorspaces from settings.\n\n    Due to not being able to set the project settings through the Python API,\n    we need to do use some dubious code to find the widgets and set them. It is\n    possible to set the project settings without traversing through the widgets\n    but it involves reading the hrox files from disk with XML, so no in-memory\n    support. See https://community.foundry.com/discuss/topic/137771/change-a-project-s-default-color-transform-with-python  # noqa\n    for more details.\n    \"\"\"\n    # get presets for hiero\n    project_name = get_current_project_name()\n    imageio = get_project_settings(project_name)[\"hiero\"][\"imageio\"]\n    presets = imageio.get(\"workfile\")\n\n    # Open Project Settings UI.\n    for act in hiero.ui.registeredActions():\n        if act.objectName() == \"foundry.project.settings\":\n            act.trigger()\n\n    # Find widgets from their sibling label.\n    labels = {\n        \"Working Space:\": \"workingSpace\",\n        \"Viewer:\": \"viewerLut\",\n        \"Thumbnails:\": \"thumbnailLut\",\n        \"Monitor Out:\": \"monitorOutLut\",\n        \"8 Bit Files:\": \"eightBitLut\",\n        \"16 Bit Files:\": \"sixteenBitLut\",\n        \"Log Files:\": \"logLut\",\n        \"Floating Point Files:\": \"floatLut\"\n    }\n    widgets = {x: None for x in labels.values()}\n\n    def _recursive_children(widget, labels, widgets):\n        children = widget.children()\n        for count, child in enumerate(children):\n            if isinstance(child, QtWidgets.QLabel):\n                if child.text() in labels.keys():\n                    widgets[labels[child.text()]] = children[count + 1]\n            _recursive_children(child, labels, widgets)\n\n    app = QtWidgets.QApplication.instance()\n    title = \"Project Settings\"\n    for widget in app.topLevelWidgets():\n        if isinstance(widget, QtWidgets.QMainWindow):\n            if widget.windowTitle() != title:\n                continue\n            _recursive_children(widget, labels, widgets)\n            widget.close()\n\n    msg = \"Setting value \\\"{}\\\" is not a valid option for \\\"{}\\\"\"\n    for key, widget in widgets.items():\n        options = [widget.itemText(i) for i in range(widget.count())]\n        setting_value = presets[key]\n        assert setting_value in options, msg.format(setting_value, key)\n        widget.setCurrentText(presets[key])\n\n    # This code block is for setting up project colorspaces for files on disk.\n    # Due to not having Python API access to set the project settings, the\n    # Foundry recommended way is to modify the hrox files on disk with XML. See\n    # this forum thread for more details;\n    # https://community.foundry.com/discuss/topic/137771/change-a-project-s-default-color-transform-with-python  # noqa\n    '''\n    # backward compatibility layer\n    # TODO: remove this after some time\n    config_data = get_current_context_imageio_config_preset()\n\n    if config_data:\n        presets.update({\n            \"ocioConfigName\": \"custom\"\n        })\n\n    # get path the the active projects\n    project = get_current_project()\n    current_file = project.path()\n\n    msg = \"The project needs to be saved to disk to apply colorspace settings.\"\n    assert current_file, msg\n\n    # save the workfile as subversion \"comment:_colorspaceChange\"\n    split_current_file = os.path.splitext(current_file)\n    copy_current_file = current_file\n\n    if \"_colorspaceChange\" not in current_file:\n        copy_current_file = (\n            split_current_file[0]\n            + \"_colorspaceChange\"\n            + split_current_file[1]\n        )\n\n    try:\n        # duplicate the file so the changes are applied only to the copy\n        shutil.copyfile(current_file, copy_current_file)\n    except shutil.Error:\n        # in case the file already exists and it want to copy to the\n        # same filewe need to do this trick\n        # TEMP file name change\n        copy_current_file_tmp = copy_current_file + \"_tmp\"\n        # create TEMP file\n        shutil.copyfile(current_file, copy_current_file_tmp)\n        # remove original file\n        os.remove(current_file)\n        # copy TEMP back to original name\n        shutil.copyfile(copy_current_file_tmp, copy_current_file)\n        # remove the TEMP file as we dont need it\n        os.remove(copy_current_file_tmp)\n\n    # use the code from below for changing xml hrox Attributes\n    presets.update({\"name\": os.path.basename(copy_current_file)})\n\n    # read HROX in as QDomSocument\n    doc = _read_doc_from_path(copy_current_file)\n\n    # apply project colorspace properties\n    _set_hrox_project_knobs(doc, **presets)\n\n    # write QDomSocument back as HROX\n    _write_doc_to_path(doc, copy_current_file)\n\n    # open the file as current project\n    hiero.core.openProject(copy_current_file)\n    '''\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/api/index.html#client.ayon_hiero.api.containerise","title":"<code>containerise(track_item, name, namespace, context, loader=None, data=None)</code>","text":"<p>Bundle Hiero's object into an assembly and imprint it with metadata</p> <p>Containerisation enables a tracking of version, author and origin for loaded assets.</p> <p>Parameters:</p> Name Type Description Default <code>track_item</code> <code>TrackItem</code> <p>object to imprint as container</p> required <code>name</code> <code>str</code> <p>Name of resulting assembly</p> required <code>namespace</code> <code>str</code> <p>Namespace under which to host container</p> required <code>context</code> <code>dict</code> <p>Asset information</p> required <code>loader</code> <code>str</code> <p>Name of node used to produce this container.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>track_item</code> <code>TrackItem</code> <p>containerised object</p> Source code in <code>client/ayon_hiero/api/pipeline.py</code> <pre><code>def containerise(track_item,\n                 name,\n                 namespace,\n                 context,\n                 loader=None,\n                 data=None):\n    \"\"\"Bundle Hiero's object into an assembly and imprint it with metadata\n\n    Containerisation enables a tracking of version, author and origin\n    for loaded assets.\n\n    Arguments:\n        track_item (hiero.core.TrackItem): object to imprint as container\n        name (str): Name of resulting assembly\n        namespace (str): Namespace under which to host container\n        context (dict): Asset information\n        loader (str, optional): Name of node used to produce this container.\n\n    Returns:\n        track_item (hiero.core.TrackItem): containerised object\n\n    \"\"\"\n\n    data_imprint = OrderedDict({\n        \"schema\": \"ayon:container-3.0\",\n        \"id\": AYON_CONTAINER_ID,\n        \"name\": str(name),\n        \"namespace\": str(namespace),\n        \"loader\": str(loader),\n        \"representation\": context[\"representation\"][\"id\"],\n    })\n\n    if data:\n        for k, v in data.items():\n            data_imprint.update({k: v})\n\n    log.debug(\"_ data_imprint: {}\".format(data_imprint))\n    lib.set_trackitem_ayon_tag(track_item, data_imprint)\n\n    return track_item\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/api/index.html#client.ayon_hiero.api.create_bin","title":"<code>create_bin(path=None, project=None)</code>","text":"<p>Create bin in project. If the path is \"bin1/bin2/bin3\" it will create whole depth and return <code>bin3</code></p> Source code in <code>client/ayon_hiero/api/lib.py</code> <pre><code>def create_bin(path=None, project=None):\n    '''\n    Create bin in project.\n    If the path is \"bin1/bin2/bin3\" it will create whole depth\n    and return `bin3`\n\n    '''\n    # get the first loaded project\n    project = project or get_current_project()\n\n    path = path or DEFAULT_BIN_NAME\n\n    path = path.replace(\"\\\\\", \"/\").split(\"/\")\n\n    root_bin = project.clipsBin()\n\n    done_bin_lst = []\n    for i, b in enumerate(path):\n        if i == 0 and len(path) &gt; 1:\n            if b in [bin.name() for bin in root_bin.bins()]:\n                bin = [bin for bin in root_bin.bins() if b in bin.name()][0]\n                done_bin_lst.append(bin)\n            else:\n                create_bin = hiero.core.Bin(b)\n                root_bin.addItem(create_bin)\n                done_bin_lst.append(create_bin)\n\n        elif i &gt;= 1 and i &lt; len(path) - 1:\n            if b in [bin.name() for bin in done_bin_lst[i - 1].bins()]:\n                bin = [\n                    bin for bin in done_bin_lst[i - 1].bins()\n                    if b in bin.name()\n                ][0]\n                done_bin_lst.append(bin)\n            else:\n                create_bin = hiero.core.Bin(b)\n                done_bin_lst[i - 1].addItem(create_bin)\n                done_bin_lst.append(create_bin)\n\n        elif i == len(path) - 1:\n            if b in [bin.name() for bin in done_bin_lst[i - 1].bins()]:\n                bin = [\n                    bin for bin in done_bin_lst[i - 1].bins()\n                    if b in bin.name()\n                ][0]\n                done_bin_lst.append(bin)\n            else:\n                create_bin = hiero.core.Bin(b)\n                done_bin_lst[i - 1].addItem(create_bin)\n                done_bin_lst.append(create_bin)\n\n    return done_bin_lst[-1]\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/api/index.html#client.ayon_hiero.api.create_nuke_workfile_clips","title":"<code>create_nuke_workfile_clips(nuke_workfiles, seq=None)</code>","text":"<p>nuke_workfiles is list of dictionaries like: [{     'path': 'P:/Jakub_testy_pipeline/test_v01.nk',     'name': 'test',     'handleStart': 15, # added asymmetrically to handles     'handleEnd': 10, # added asymmetrically to handles     \"clipIn\": 16,     \"frameStart\": 991,     \"frameEnd\": 1023,     'task': 'Comp-tracking',     'work_dir': 'VFX_PR',     'shot': '00010' }]</p> Source code in <code>client/ayon_hiero/api/lib.py</code> <pre><code>def create_nuke_workfile_clips(nuke_workfiles, seq=None):\n    '''\n    nuke_workfiles is list of dictionaries like:\n    [{\n        'path': 'P:/Jakub_testy_pipeline/test_v01.nk',\n        'name': 'test',\n        'handleStart': 15, # added asymmetrically to handles\n        'handleEnd': 10, # added asymmetrically to handles\n        \"clipIn\": 16,\n        \"frameStart\": 991,\n        \"frameEnd\": 1023,\n        'task': 'Comp-tracking',\n        'work_dir': 'VFX_PR',\n        'shot': '00010'\n    }]\n    '''\n\n    proj = hiero.core.projects()[-1]\n    root = proj.clipsBin()\n\n    if not seq:\n        seq = hiero.core.Sequence('NewSequences')\n        root.addItem(hiero.core.BinItem(seq))\n    # todo will need to define this better\n    # track = seq[1]  # lazy example to get a destination#  track\n    clips_lst = []\n    for nk in nuke_workfiles:\n        task_path = '/'.join([nk['work_dir'], nk['shot'], nk['task']])\n        bin = create_bin(task_path, proj)\n\n        if nk['task'] not in seq.videoTracks():\n            track = hiero.core.VideoTrack(nk['task'])\n            seq.addTrack(track)\n        else:\n            track = seq.tracks(nk['task'])\n\n        # create clip media\n        media = hiero.core.MediaSource(nk['path'])\n        media_in = int(media.startTime() or 0)\n        media_duration = int(media.duration() or 0)\n\n        handle_start = nk.get(\"handleStart\")\n        handle_end = nk.get(\"handleEnd\")\n\n        if media_in:\n            source_in = media_in + handle_start\n        else:\n            source_in = nk[\"frameStart\"] + handle_start\n\n        if media_duration:\n            source_out = (media_in + media_duration - 1) - handle_end\n        else:\n            source_out = nk[\"frameEnd\"] - handle_end\n\n        source = hiero.core.Clip(media)\n\n        name = os.path.basename(os.path.splitext(nk['path'])[0])\n        split_name = split_by_client_version(name)[0] or name\n\n        # add to bin as clip item\n        items_in_bin = [b.name() for b in bin.items()]\n        if split_name not in items_in_bin:\n            binItem = hiero.core.BinItem(source)\n            bin.addItem(binItem)\n\n        new_source = [\n            item for item in bin.items() if split_name in item.name()\n        ][0].items()[0].item()\n\n        # add to track as clip item\n        trackItem = hiero.core.TrackItem(\n            split_name, hiero.core.TrackItem.kVideo)\n        trackItem.setSource(new_source)\n        trackItem.setSourceIn(source_in)\n        trackItem.setSourceOut(source_out)\n        trackItem.setTimelineIn(nk[\"clipIn\"])\n        trackItem.setTimelineOut(nk[\"clipIn\"] + (source_out - source_in))\n        track.addTrackItem(trackItem)\n        clips_lst.append(trackItem)\n\n    return clips_lst\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/api/index.html#client.ayon_hiero.api.get_current_sequence","title":"<code>get_current_sequence(name=None, new=False)</code>","text":"<p>Get current sequence in context of active project.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str)[optional]</code> <p>name of sequence we want to return</p> <code>None</code> <code>new</code> <code>bool)[optional]</code> <p>if we want to create new one</p> <code>False</code> <p>Returns:</p> Type Description <p>hiero.core.Sequence: the sequence object</p> Source code in <code>client/ayon_hiero/api/lib.py</code> <pre><code>def get_current_sequence(name=None, new=False):\n    \"\"\"\n    Get current sequence in context of active project.\n\n    Args:\n        name (str)[optional]: name of sequence we want to return\n        new (bool)[optional]: if we want to create new one\n\n    Returns:\n        hiero.core.Sequence: the sequence object\n    \"\"\"\n    sequence = None\n    project = get_current_project()\n    root_bin = project.clipsBin()\n\n    if new:\n        # create new\n        name = name or DEFAULT_SEQUENCE_NAME\n        sequence = hiero.core.Sequence(name)\n        root_bin.addItem(hiero.core.BinItem(sequence))\n    elif name:\n        # look for sequence by name\n        sequences = project.sequences()\n        for _sequence in sequences:\n            if _sequence.name() == name:\n                sequence = _sequence\n        if not sequence:\n            # if nothing found create new with input name\n            sequence = get_current_sequence(name, True)\n    else:\n        # if name is none and new is False then return current open sequence\n        sequence = hiero.ui.activeSequence()\n\n    return sequence\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/api/index.html#client.ayon_hiero.api.get_current_track","title":"<code>get_current_track(sequence, name, audio=False)</code>","text":"<p>Get current track in context of active project.</p> <p>Creates new if none is found.</p> <p>Parameters:</p> Name Type Description Default <code>sequence</code> <code>Sequence</code> <p>hiero sequence object</p> required <code>name</code> <code>str</code> <p>name of track we want to return</p> required <code>audio</code> <code>bool)[optional]</code> <p>switch to AudioTrack</p> <code>False</code> <p>Returns:</p> Type Description <p>hiero.core.Track: the track object</p> Source code in <code>client/ayon_hiero/api/lib.py</code> <pre><code>def get_current_track(sequence, name, audio=False):\n    \"\"\"\n    Get current track in context of active project.\n\n    Creates new if none is found.\n\n    Args:\n        sequence (hiero.core.Sequence): hiero sequence object\n        name (str): name of track we want to return\n        audio (bool)[optional]: switch to AudioTrack\n\n    Returns:\n        hiero.core.Track: the track object\n    \"\"\"\n    tracks = sequence.videoTracks()\n\n    if audio:\n        tracks = sequence.audioTracks()\n\n    # get track by name\n    track = None\n    for _track in tracks:\n        if _track.name() == name:\n            track = _track\n\n    if not track:\n        if not audio:\n            track = hiero.core.VideoTrack(name)\n        else:\n            track = hiero.core.AudioTrack(name)\n\n        sequence.addTrack(track)\n\n    return track\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/api/index.html#client.ayon_hiero.api.get_sequence_pattern_and_padding","title":"<code>get_sequence_pattern_and_padding(file)</code>","text":"<p>Return sequence pattern and padding from file</p> <p>Attributes:</p> Name Type Description <code>file</code> <code>string</code> <p>basename form path</p> Example <p>Can find file.0001.ext, file.%02d.ext, file.####.ext</p> Return <p>string: any matching sequence pattern int: padding of sequence numbering</p> Source code in <code>client/ayon_hiero/api/lib.py</code> <pre><code>def get_sequence_pattern_and_padding(file):\n    \"\"\" Return sequence pattern and padding from file\n\n    Attributes:\n        file (string): basename form path\n\n    Example:\n        Can find file.0001.ext, file.%02d.ext, file.####.ext\n\n    Return:\n        string: any matching sequence pattern\n        int: padding of sequence numbering\n    \"\"\"\n    foundall = re.findall(\n        r\"(#+)|(%\\d+d)|(?&lt;=[^a-zA-Z0-9])(\\d+)(?=\\.\\w+$)\", file)\n    if not foundall:\n        return None, None\n    found = sorted(list(set(foundall[0])))[-1]\n\n    padding = int(\n        re.findall(r\"\\d+\", found)[-1]) if \"%\" in found else len(found)\n    return found, padding\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/api/index.html#client.ayon_hiero.api.get_track_ayon_data","title":"<code>get_track_ayon_data(track, container_name=None)</code>","text":"<p>Get track's AYON tag data.</p> <p>Attributes:</p> Name Type Description <code>trackItem</code> <code>VideoTrack</code> <p>hiero object</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>data found on the AYON tag</p> Source code in <code>client/ayon_hiero/api/lib.py</code> <pre><code>def get_track_ayon_data(track, container_name=None):\n    \"\"\"\n    Get track's AYON tag data.\n\n    Attributes:\n        trackItem (hiero.core.VideoTrack): hiero object\n\n    Returns:\n        dict: data found on the AYON tag\n    \"\"\"\n    return_data = {}\n    # get pype data tag from track item\n    tag = get_track_ayon_tag(track)\n\n    if not tag:\n        return None\n\n    # get tag metadata attribute\n    tag_data = deepcopy(dict(tag.metadata()))\n    if tag_data.get(\"tag.json_metadata\"):\n        tag_data = json.loads(tag_data[\"tag.json_metadata\"])\n\n    ignore_names  = {\"applieswhole\", \"note\", \"label\"}\n    for obj_name, obj_data in tag_data.items():\n        obj_name = obj_name.replace(\"tag.\", \"\")\n\n        if obj_name in ignore_names:\n            continue\n        if isinstance(obj_data, dict):\n            return_data[obj_name] = obj_data\n        else:\n            return_data[obj_name] = json.loads(obj_data)\n\n    return (\n        return_data[container_name]\n        if container_name\n        else return_data\n    )\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/api/index.html#client.ayon_hiero.api.get_track_ayon_tag","title":"<code>get_track_ayon_tag(track)</code>","text":"<p>Get AYON track item tag created by creator or loader plugin.</p> <p>Attributes:</p> Name Type Description <code>trackItem</code> <code>TrackItem</code> <p>hiero object</p> <p>Returns:</p> Type Description <p>hiero.core.Tag: hierarchy, orig clip attributes</p> Source code in <code>client/ayon_hiero/api/lib.py</code> <pre><code>def get_track_ayon_tag(track):\n    \"\"\"\n    Get AYON track item tag created by creator or loader plugin.\n\n    Attributes:\n        trackItem (hiero.core.TrackItem): hiero object\n\n    Returns:\n        hiero.core.Tag: hierarchy, orig clip attributes\n    \"\"\"\n    # get all tags from track item\n    _tags = track.tags()\n    if not _tags:\n        return None\n    for tag in _tags:\n        # return only correct tag defined by global name\n        if AYON_TAG_NAME in tag.name():\n            return tag\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/api/index.html#client.ayon_hiero.api.get_track_item_tags","title":"<code>get_track_item_tags(track_item)</code>","text":"<p>Get track item tags excluding AYON tag</p> <p>Attributes:</p> Name Type Description <code>trackItem</code> <code>TrackItem</code> <p>hiero object</p> <p>Returns:</p> Type Description <p>hiero.core.Tag: hierarchy, orig clip attributes</p> Source code in <code>client/ayon_hiero/api/lib.py</code> <pre><code>def get_track_item_tags(track_item):\n    \"\"\"\n    Get track item tags excluding AYON tag\n\n    Attributes:\n        trackItem (hiero.core.TrackItem): hiero object\n\n    Returns:\n        hiero.core.Tag: hierarchy, orig clip attributes\n    \"\"\"\n    returning_tag_data = []\n    # get all tags from track item\n    _tags = track_item.tags()\n    if not _tags:\n        return []\n\n    # collect all tags which are not AYON tag\n    returning_tag_data.extend(\n        tag for tag in _tags\n        if tag.name() != AYON_TAG_NAME\n    )\n\n    return returning_tag_data\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/api/index.html#client.ayon_hiero.api.get_track_items","title":"<code>get_track_items(selection=False, sequence_name=None, track_item_name=None, track_name=None, track_type=None, check_enabled=True, check_locked=True, check_tagged=False)</code>","text":"<p>Get all available current timeline track items.</p> Attribute <p>selection (list)[optional]: list of selected track items sequence_name (str)[optional]: return only clips from input sequence track_item_name (str)[optional]: return only item with input name track_name (str)[optional]: return only items from track name track_type (str)[optional]: return only items of given type                             (<code>audio</code> or <code>video</code>) default is <code>video</code> check_enabled (bool)[optional]: ignore disabled if True check_locked (bool)[optional]: ignore locked if True</p> Return <p>list or hiero.core.TrackItem: list of track items or single track item</p> Source code in <code>client/ayon_hiero/api/lib.py</code> <pre><code>def get_track_items(\n        selection=False,\n        sequence_name=None,\n        track_item_name=None,\n        track_name=None,\n        track_type=None,\n        check_enabled=True,\n        check_locked=True,\n        check_tagged=False):\n    \"\"\"Get all available current timeline track items.\n\n    Attribute:\n        selection (list)[optional]: list of selected track items\n        sequence_name (str)[optional]: return only clips from input sequence\n        track_item_name (str)[optional]: return only item with input name\n        track_name (str)[optional]: return only items from track name\n        track_type (str)[optional]: return only items of given type\n                                    (`audio` or `video`) default is `video`\n        check_enabled (bool)[optional]: ignore disabled if True\n        check_locked (bool)[optional]: ignore locked if True\n\n    Return:\n        list or hiero.core.TrackItem: list of track items or single track item\n    \"\"\"\n    track_type = track_type or \"video\"\n    selection = selection or []\n    return_list = []\n\n    # get selected track items or all in active sequence\n    if selection:\n        try:\n            for track_item in selection:\n                log.info(\"___ track_item: {}\".format(track_item))\n                # make sure only trackitems are selected\n                if not isinstance(track_item, hiero.core.TrackItem):\n                    continue\n\n                if _validate_all_atrributes(\n                    track_item,\n                    track_item_name,\n                    track_name,\n                    track_type,\n                    check_enabled,\n                    check_tagged\n                ):\n                    log.info(\"___ valid trackitem: {}\".format(track_item))\n                    return_list.append(track_item)\n        except AttributeError:\n            pass\n\n    # collect all available active sequence track items\n    if not return_list:\n        sequence = get_current_sequence(name=sequence_name)\n        tracks = []\n        if sequence is not None:\n            # get all available tracks from sequence\n            tracks.extend(sequence.audioTracks())\n            tracks.extend(sequence.videoTracks())\n\n        # loop all tracks\n        for track in tracks:\n            if check_locked and track.isLocked():\n                continue\n            if check_enabled and not track.isEnabled():\n                continue\n            # and all items in track\n            for track_item in track.items():\n                # make sure no subtrackitem is also track items\n                if not isinstance(track_item, hiero.core.TrackItem):\n                    continue\n\n                if _validate_all_atrributes(\n                    track_item,\n                    track_item_name,\n                    track_name,\n                    track_type,\n                    check_enabled,\n                    check_tagged\n                ):\n                    return_list.append(track_item)\n\n    return return_list\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/api/index.html#client.ayon_hiero.api.get_trackitem_ayon_data","title":"<code>get_trackitem_ayon_data(track_item)</code>","text":"<p>Get track item's AYON tag data.</p> <p>Attributes:</p> Name Type Description <code>trackItem</code> <code>TrackItem</code> <p>hiero object</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>data found on pype tag</p> Source code in <code>client/ayon_hiero/api/lib.py</code> <pre><code>def get_trackitem_ayon_data(track_item):\n    \"\"\"\n    Get track item's AYON tag data.\n\n    Attributes:\n        trackItem (hiero.core.TrackItem): hiero object\n\n    Returns:\n        dict: data found on pype tag\n    \"\"\"\n    data = {}\n    # get pype data tag from track item\n    tag = get_trackitem_ayon_tag(track_item)\n\n    if not tag:\n        return None\n\n    # get tag metadata attribute\n    tag_data = deepcopy(dict(tag.metadata()))\n    if tag_data.get(\"tag.json_metadata\"):\n        return json.loads(tag_data.get(\"tag.json_metadata\"))\n\n    # convert tag metadata to normal keys names and values to correct types\n    for k, v in tag_data.items():\n        key = k.replace(\"tag.\", \"\")\n\n        try:\n            # capture exceptions which are related to strings only\n            if re.match(r\"^[\\d]+$\", v):\n                value = int(v)\n            elif re.match(r\"^True$\", v):\n                value = True\n            elif re.match(r\"^False$\", v):\n                value = False\n            elif re.match(r\"^None$\", v):\n                value = None\n            elif re.match(r\"^[\\w\\d_]+$\", v):\n                value = v\n            else:\n                value = ast.literal_eval(v)\n        except (ValueError, SyntaxError):\n            value = v\n\n        data[key] = value\n\n    return data\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/api/index.html#client.ayon_hiero.api.get_trackitem_ayon_tag","title":"<code>get_trackitem_ayon_tag(track_item, tag_name=AYON_TAG_NAME)</code>","text":"<p>Get pype track item tag created by creator or loader plugin.</p> <p>Attributes:</p> Name Type Description <code>trackItem</code> <code>TrackItem</code> <p>hiero object</p> <code>tag_name</code> <code>str</code> <p>The tag name.</p> <p>Returns:</p> Type Description <p>hiero.core.Tag: hierarchy, orig clip attributes</p> Source code in <code>client/ayon_hiero/api/lib.py</code> <pre><code>def get_trackitem_ayon_tag(track_item, tag_name=AYON_TAG_NAME):\n    \"\"\"\n    Get pype track item tag created by creator or loader plugin.\n\n    Attributes:\n        trackItem (hiero.core.TrackItem): hiero object\n        tag_name (str): The tag name.\n\n    Returns:\n        hiero.core.Tag: hierarchy, orig clip attributes\n    \"\"\"\n    # get all tags from track item\n    _tags = track_item.tags()\n    if not _tags:\n        return None\n    for tag in _tags:\n        # return only correct tag defined by global name\n        if tag_name in tag.name():\n            return tag\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/api/index.html#client.ayon_hiero.api.imprint","title":"<code>imprint(track_item, data=None)</code>","text":"<p>Adding <code>Avalon data</code> into a hiero track item tag.</p> <p>Also including publish attribute into tag.</p> <p>Parameters:</p> Name Type Description Default <code>track_item</code> <code>TrackItem</code> <p>hiero track item object</p> required <code>data</code> <code>dict</code> <p>Any data which needs to be imprinted</p> <code>None</code> <p>Examples:</p> <p>data = {     'folderPath': '/shots/sq020sh0280',     'productType': 'render',     'productName': 'productMain' }</p> Source code in <code>client/ayon_hiero/api/lib.py</code> <pre><code>def imprint(track_item, data=None):\n    \"\"\"\n    Adding `Avalon data` into a hiero track item tag.\n\n    Also including publish attribute into tag.\n\n    Arguments:\n        track_item (hiero.core.TrackItem): hiero track item object\n        data (dict): Any data which needs to be imprinted\n\n    Examples:\n        data = {\n            'folderPath': '/shots/sq020sh0280',\n            'productType': 'render',\n            'productName': 'productMain'\n        }\n    \"\"\"\n    data = data or {}\n\n    set_trackitem_ayon_tag(track_item, data)\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/api/index.html#client.ayon_hiero.api.launch_workfiles_app","title":"<code>launch_workfiles_app(*args)</code>","text":"<p>Wrapping function for workfiles launcher</p> Source code in <code>client/ayon_hiero/api/pipeline.py</code> <pre><code>def launch_workfiles_app(*args):\n    ''' Wrapping function for workfiles launcher '''\n    from .lib import get_main_window\n\n    main_window = get_main_window()\n    # show workfile gui\n    host_tools.show_workfiles(parent=main_window)\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/api/index.html#client.ayon_hiero.api.ls","title":"<code>ls()</code>","text":"<p>List available containers.</p> <p>This function is used by the Container Manager in Nuke. You'll need to implement a for-loop that then yields one Container at a time.</p> <p>See the <code>container.json</code> schema for details on how it should look, and the Maya equivalent, which is in <code>avalon.maya.pipeline</code></p> Source code in <code>client/ayon_hiero/api/pipeline.py</code> <pre><code>def ls():\n    \"\"\"List available containers.\n\n    This function is used by the Container Manager in Nuke. You'll\n    need to implement a for-loop that then *yields* one Container at\n    a time.\n\n    See the `container.json` schema for details on how it should look,\n    and the Maya equivalent, which is in `avalon.maya.pipeline`\n    \"\"\"\n\n    # get all track items from current timeline\n    all_items = lib.get_track_items()\n\n    # append all video tracks\n    for track in (lib.get_current_sequence() or []):\n        if type(track) is not hiero.core.VideoTrack:\n            continue\n        all_items.append(track)\n\n    for item in all_items:\n        container_data = parse_container(item)\n\n        if isinstance(container_data, list):\n            for _c in container_data:\n                yield _c\n        elif container_data:\n            yield container_data\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/api/index.html#client.ayon_hiero.api.maintained_selection","title":"<code>maintained_selection()</code>","text":"<p>Maintain selection during context</p> Example <p>with maintained_selection(): ...     for track_item in track_items: ...         &lt; do some stuff &gt;</p> Source code in <code>client/ayon_hiero/api/pipeline.py</code> <pre><code>@contextlib.contextmanager\ndef maintained_selection():\n    \"\"\"Maintain selection during context\n\n    Example:\n        &gt;&gt;&gt; with maintained_selection():\n        ...     for track_item in track_items:\n        ...         &lt; do some stuff &gt;\n    \"\"\"\n    from .lib import (\n        set_selected_track_items,\n        get_selected_track_items\n    )\n    previous_selection = get_selected_track_items()\n    reset_selection()\n    try:\n        # do the operation\n        yield\n    finally:\n        reset_selection()\n        set_selected_track_items(previous_selection)\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/api/index.html#client.ayon_hiero.api.open_file","title":"<code>open_file(filepath)</code>","text":"<p>Manually fire the kBeforeProjectLoad event in order to work around a bug in Hiero. The Foundry has logged this bug as:   Bug 40413 - Python API - kBeforeProjectLoad event type is not triggered   when calling hiero.core.openProject() (only triggered through UI) It exists in all versions of Hiero through (at least) v1.9v1b12.</p> <p>Once this bug is fixed, a version check will need to be added here in order to prevent accidentally firing this event twice. The following commented-out code is just an example, and will need to be updated when the bug is fixed to catch the correct versions.</p> Source code in <code>client/ayon_hiero/api/workio.py</code> <pre><code>def open_file(filepath):\n    \"\"\"Manually fire the kBeforeProjectLoad event in order to work around a bug in Hiero.\n    The Foundry has logged this bug as:\n      Bug 40413 - Python API - kBeforeProjectLoad event type is not triggered\n      when calling hiero.core.openProject() (only triggered through UI)\n    It exists in all versions of Hiero through (at least) v1.9v1b12.\n\n    Once this bug is fixed, a version check will need to be added here in order to\n    prevent accidentally firing this event twice. The following commented-out code\n    is just an example, and will need to be updated when the bug is fixed to catch the\n    correct versions.\"\"\"\n    # if (hiero.core.env['VersionMajor'] &lt; 1 or\n    #     hiero.core.env['VersionMajor'] == 1 and hiero.core.env['VersionMinor'] &lt; 10:\n    hiero.core.events.sendEvent(\"kBeforeProjectLoad\", None)\n\n    project = hiero.core.projects()[-1]\n\n    # Close previous project if its different to the current project.\n    filepath = filepath.replace(os.path.sep, \"/\")\n    if project.path().replace(os.path.sep, \"/\") != filepath:\n        # open project file\n        hiero.core.openProject(filepath)\n        project.close()\n\n    return True\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/api/index.html#client.ayon_hiero.api.parse_container","title":"<code>parse_container(item, validate=True)</code>","text":"<p>Return container data from track_item's pype tag.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>TrackItem or VideoTrack</code> <p>A containerised track item.</p> required <code>validate</code> <code>bool)[optional]</code> <p>validating with avalon scheme</p> <code>True</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>The container schema data for input containerized track item.</p> Source code in <code>client/ayon_hiero/api/pipeline.py</code> <pre><code>def parse_container(item, validate=True):\n    \"\"\"Return container data from track_item's pype tag.\n\n    Args:\n        item (hiero.core.TrackItem or hiero.core.VideoTrack):\n            A containerised track item.\n        validate (bool)[optional]: validating with avalon scheme\n\n    Returns:\n        dict: The container schema data for input containerized track item.\n\n    \"\"\"\n    def data_to_container(item, data):\n        if (\n            not data\n            or data.get(\"id\") not in {\n                AYON_CONTAINER_ID, AVALON_CONTAINER_ID\n            }\n        ):\n            return\n\n        if validate and data and data.get(\"schema\"):\n            schema.validate(data)\n\n        if not isinstance(data, dict):\n            return\n\n        # If not all required data return the empty container\n        required = ['schema', 'id', 'name',\n                    'namespace', 'loader', 'representation']\n\n        if any(key not in data for key in required):\n            return\n\n        container = {key: data[key] for key in required}\n\n        container[\"objectName\"] = item.name()\n\n        # Store reference to the node object\n        container[\"_item\"] = item\n\n        return container\n\n    # convert tag metadata to normal keys names\n    if type(item) is hiero.core.VideoTrack:\n        return_list = []\n        _data = lib.get_track_ayon_data(item)\n\n        if not _data:\n            return\n        # convert the data to list and validate them\n        for _, obj_data in _data.items():\n            container = data_to_container(item, obj_data)\n            return_list.append(container)\n        return return_list\n    else:\n        _data = lib.get_trackitem_ayon_data(item)\n        return data_to_container(item, _data)\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/api/index.html#client.ayon_hiero.api.publish","title":"<code>publish(parent)</code>","text":"<p>Shorthand to publish from within host</p> Source code in <code>client/ayon_hiero/api/pipeline.py</code> <pre><code>def publish(parent):\n    \"\"\"Shorthand to publish from within host\"\"\"\n    return host_tools.show_publish(parent)\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/api/index.html#client.ayon_hiero.api.reload_config","title":"<code>reload_config()</code>","text":"<p>Attempt to reload pipeline at run-time.</p> <p>CAUTION: This is primarily for development and debugging purposes.</p> Source code in <code>client/ayon_hiero/api/pipeline.py</code> <pre><code>def reload_config():\n    \"\"\"Attempt to reload pipeline at run-time.\n\n    CAUTION: This is primarily for development and debugging purposes.\n\n    \"\"\"\n    import importlib\n\n    for module in (\n        \"ayon_hiero.lib\",\n        \"ayon_hiero.menu\",\n        \"ayon_hiero.tags\"\n    ):\n        log.info(\"Reloading module: {}...\".format(module))\n        try:\n            module = importlib.import_module(module)\n            import imp\n            imp.reload(module)\n        except Exception as e:\n            log.warning(\"Cannot reload module: {}\".format(e))\n            importlib.reload(module)\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/api/index.html#client.ayon_hiero.api.reset_selection","title":"<code>reset_selection()</code>","text":"<p>Deselect all selected nodes</p> Source code in <code>client/ayon_hiero/api/pipeline.py</code> <pre><code>def reset_selection():\n    \"\"\"Deselect all selected nodes\n    \"\"\"\n    from .lib import set_selected_track_items\n    set_selected_track_items([])\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/api/index.html#client.ayon_hiero.api.set_track_ayon_tag","title":"<code>set_track_ayon_tag(track, data=None)</code>","text":"<p>Set AYON track tag to input track object.</p> <p>Attributes:</p> Name Type Description <code>track</code> <code>VideoTrack</code> <p>hiero object</p> <p>Returns:</p> Type Description <p>hiero.core.Tag</p> Source code in <code>client/ayon_hiero/api/lib.py</code> <pre><code>def set_track_ayon_tag(track, data=None):\n    \"\"\"\n    Set AYON track tag to input track object.\n\n    Attributes:\n        track (hiero.core.VideoTrack): hiero object\n\n    Returns:\n        hiero.core.Tag\n    \"\"\"\n    data = data or {}\n\n    # basic Tag's attribute\n    tag_data = {\n        \"editable\": \"0\",\n        \"note\": \"AYON data container\",\n        \"icon\": \"AYON_icon.png\",\n        \"metadata\": dict(data.items())\n    }\n    # get available pype tag if any\n    _tag = get_track_ayon_tag(track)\n\n    if _tag:\n        # it not tag then create one\n        tag = tags.update_tag(_tag, tag_data)\n    else:\n        # if pype tag available then update with input data\n        tag = tags.create_tag(\n            \"{}_{}\".format(\n                AYON_TAG_NAME,\n                _get_tag_unique_hash()\n            ),\n            tag_data\n        )\n        # add it to the input track item\n        track.addTag(tag)\n\n    return tag\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/api/index.html#client.ayon_hiero.api.set_trackitem_ayon_tag","title":"<code>set_trackitem_ayon_tag(track_item, data=None)</code>","text":"<p>Set AYON track tag to input track object.</p> <p>Attributes:</p> Name Type Description <code>track</code> <code>VideoTrack</code> <p>hiero object</p> <p>Returns:</p> Type Description <p>hiero.core.Tag</p> Source code in <code>client/ayon_hiero/api/lib.py</code> <pre><code>def set_trackitem_ayon_tag(track_item, data=None):\n    \"\"\"\n    Set AYON track tag to input track object.\n\n    Attributes:\n        track (hiero.core.VideoTrack): hiero object\n\n    Returns:\n        hiero.core.Tag\n    \"\"\"\n    data = data or {}\n\n    # basic Tag's attribute\n    tag_data = {\n        \"editable\": \"0\",\n        \"note\": \"AYON data container\",\n        \"icon\": \"AYON_icon.png\",\n        \"metadata\": dict(data.items())\n    }\n    # get available pype tag if any\n    _tag = get_trackitem_ayon_tag(track_item)\n    if _tag:\n        # if pype tag available then update with input data\n        tag = tags.update_tag(_tag, tag_data)\n    else:\n        # it not tag then create one\n        tag = tags.create_tag(\n            \"{}_{}\".format(\n                AYON_TAG_NAME,\n                _get_tag_unique_hash()\n            ),\n            tag_data\n        )\n        # add it to the input track item\n        track_item.addTag(tag)\n\n    return tag\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/api/index.html#client.ayon_hiero.api.update_container","title":"<code>update_container(item, data=None)</code>","text":"<p>Update container data to input track_item or track's AYON tag.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>TrackItem or VideoTrack</code> <p>A containerised track item.</p> required <code>data</code> <code>dict)[optional]</code> <p>dictionery with data to be updated</p> <code>None</code> <p>Returns:</p> Name Type Description <code>bool</code> <p>True if container was updated correctly</p> Source code in <code>client/ayon_hiero/api/pipeline.py</code> <pre><code>def update_container(item, data=None):\n    \"\"\"Update container data to input track_item or track's\n    AYON tag.\n\n    Args:\n        item (hiero.core.TrackItem or hiero.core.VideoTrack):\n            A containerised track item.\n        data (dict)[optional]: dictionery with data to be updated\n\n    Returns:\n        bool: True if container was updated correctly\n\n    \"\"\"\n\n    data = data or {}\n    data = deepcopy(data)\n\n    if type(item) is hiero.core.VideoTrack:\n        # form object data for test\n        object_name = data[\"objectName\"]\n\n        # get all available containers\n        containers = lib.get_track_ayon_data(item)\n        container = lib.get_track_ayon_data(item, object_name)\n\n        containers = deepcopy(containers)\n        container = deepcopy(container)\n\n        # update data in container\n        updated_container = _update_container_data(container, data)\n        # merge updated container back to containers\n        containers.update({object_name: updated_container})\n\n        return bool(lib.set_track_ayon_tag(item, containers))\n    else:\n        container = lib.get_trackitem_ayon_data(item)\n        updated_container = _update_container_data(container, data)\n\n        log.info(\"Updating container: `{}`\".format(item.name()))\n        return bool(lib.set_trackitem_ayon_tag(item, updated_container))\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/api/constants.html","title":"constants","text":""},{"location":"autoapi/client/ayon_hiero/api/events.html","title":"events","text":""},{"location":"autoapi/client/ayon_hiero/api/events.html#client.ayon_hiero.api.events.register_events","title":"<code>register_events()</code>","text":"<p>Adding all callbacks.</p> Source code in <code>client/ayon_hiero/api/events.py</code> <pre><code>def register_events():\n    \"\"\"\n    Adding all callbacks.\n    \"\"\"\n\n    # if task changed then change notext of hiero\n    register_event_callback(\"taskChanged\", update_menu_task_label)\n    log.info(\"Installed event callback for 'taskChanged'..\")\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/api/launchforhiero.html","title":"launchforhiero","text":""},{"location":"autoapi/client/ayon_hiero/api/launchforhiero.html#client.ayon_hiero.api.launchforhiero.find_scripts_menu","title":"<code>find_scripts_menu(title, parent)</code>","text":"<p>Check if the menu exists with the given title in the parent</p> <p>Parameters:</p> Name Type Description Default <code>title</code> <code>str</code> <p>the title name of the scripts menu</p> required <code>parent</code> <code>QMenuBar</code> <p>the menubar to check</p> required <p>Returns:</p> Type Description <p>QtWidgets.QMenu or None</p> Source code in <code>client/ayon_hiero/api/launchforhiero.py</code> <pre><code>def find_scripts_menu(title, parent):\n    \"\"\"\n    Check if the menu exists with the given title in the parent\n\n    Args:\n        title (str): the title name of the scripts menu\n\n        parent (QtWidgets.QMenuBar): the menubar to check\n\n    Returns:\n        QtWidgets.QMenu or None\n\n    \"\"\"\n\n    menu = None\n    search = [i for i in parent.children() if\n              isinstance(i, scriptsmenu.ScriptsMenu)\n              and i.title() == title]\n    if search:\n        assert len(search) &lt; 2, (\"Multiple instances of menu '{}' \"\n                                 \"in menu bar\".format(title))\n        menu = search[0]\n\n    return menu\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/api/launchforhiero.html#client.ayon_hiero.api.launchforhiero.main","title":"<code>main(title='Scripts', parent=None, objectName=None)</code>","text":"<p>Build the main scripts menu in Hiero</p> <p>Parameters:</p> Name Type Description Default <code>title</code> <code>str</code> <p>name of the menu in the application</p> <code>'Scripts'</code> <code>parent</code> <code>QtMenuBar</code> <p>the parent object for the menu</p> <code>None</code> <code>objectName</code> <code>str</code> <p>custom objectName for scripts menu</p> <code>None</code> <p>Returns:</p> Type Description <p>scriptsmenu.ScriptsMenu instance</p> Source code in <code>client/ayon_hiero/api/launchforhiero.py</code> <pre><code>def main(title=\"Scripts\", parent=None, objectName=None):\n    \"\"\"Build the main scripts menu in Hiero\n\n    Args:\n        title (str): name of the menu in the application\n\n        parent (QtWidgets.QtMenuBar): the parent object for the menu\n\n        objectName (str): custom objectName for scripts menu\n\n    Returns:\n        scriptsmenu.ScriptsMenu instance\n\n    \"\"\"\n    hieromainbar = parent or _hiero_main_menubar()\n    try:\n        # check menu already exists\n        menu = find_scripts_menu(title, hieromainbar)\n        if not menu:\n            log.info(\"Attempting to build menu ...\")\n            object_name = objectName or title.lower()\n            menu = scriptsmenu.ScriptsMenu(title=title,\n                                           parent=hieromainbar,\n                                           objectName=object_name)\n    except Exception as e:\n        log.error(e)\n        return\n\n    return menu\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/api/lib.html","title":"lib","text":"<p>Host specific functions where host api is connected</p>"},{"location":"autoapi/client/ayon_hiero/api/lib.html#client.ayon_hiero.api.lib.PublishAction","title":"<code>PublishAction</code>","text":"<p>               Bases: <code>QAction</code></p> <p>Action with is showing as menu item</p> Source code in <code>client/ayon_hiero/api/lib.py</code> <pre><code>class PublishAction(QtWidgets.QAction):\n    \"\"\"\n    Action with is showing as menu item\n    \"\"\"\n\n    def __init__(self):\n        QtWidgets.QAction.__init__(self, \"Publish\", None)\n        self.triggered.connect(self.publish)\n\n        for interest in [\"kShowContextMenu/kTimeline\",\n                         \"kShowContextMenukBin\",\n                         \"kShowContextMenu/kSpreadsheet\"]:\n            hiero.core.events.registerInterest(interest, self.eventHandler)\n\n        self.setShortcut(\"Ctrl+Alt+P\")\n\n    def publish(self):\n        from . import publish\n        # Removing \"submission\" attribute from hiero module, to prevent tasks\n        # from getting picked up when not using the \"Export\" dialog.\n        if hasattr(hiero, \"submission\"):\n            del hiero.submission\n        publish(hiero.ui.mainWindow())\n\n    def eventHandler(self, event):\n        # Add the Menu to the right-click menu\n        event.menu.addAction(self)\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/api/lib.html#client.ayon_hiero.api.lib.apply_colorspace_project","title":"<code>apply_colorspace_project()</code>","text":"<p>Apply colorspaces from settings.</p> <p>Due to not being able to set the project settings through the Python API, we need to do use some dubious code to find the widgets and set them. It is possible to set the project settings without traversing through the widgets but it involves reading the hrox files from disk with XML, so no in-memory support. See https://community.foundry.com/discuss/topic/137771/change-a-project-s-default-color-transform-with-python  # noqa for more details.</p> Source code in <code>client/ayon_hiero/api/lib.py</code> <pre><code>def apply_colorspace_project():\n    \"\"\"Apply colorspaces from settings.\n\n    Due to not being able to set the project settings through the Python API,\n    we need to do use some dubious code to find the widgets and set them. It is\n    possible to set the project settings without traversing through the widgets\n    but it involves reading the hrox files from disk with XML, so no in-memory\n    support. See https://community.foundry.com/discuss/topic/137771/change-a-project-s-default-color-transform-with-python  # noqa\n    for more details.\n    \"\"\"\n    # get presets for hiero\n    project_name = get_current_project_name()\n    imageio = get_project_settings(project_name)[\"hiero\"][\"imageio\"]\n    presets = imageio.get(\"workfile\")\n\n    # Open Project Settings UI.\n    for act in hiero.ui.registeredActions():\n        if act.objectName() == \"foundry.project.settings\":\n            act.trigger()\n\n    # Find widgets from their sibling label.\n    labels = {\n        \"Working Space:\": \"workingSpace\",\n        \"Viewer:\": \"viewerLut\",\n        \"Thumbnails:\": \"thumbnailLut\",\n        \"Monitor Out:\": \"monitorOutLut\",\n        \"8 Bit Files:\": \"eightBitLut\",\n        \"16 Bit Files:\": \"sixteenBitLut\",\n        \"Log Files:\": \"logLut\",\n        \"Floating Point Files:\": \"floatLut\"\n    }\n    widgets = {x: None for x in labels.values()}\n\n    def _recursive_children(widget, labels, widgets):\n        children = widget.children()\n        for count, child in enumerate(children):\n            if isinstance(child, QtWidgets.QLabel):\n                if child.text() in labels.keys():\n                    widgets[labels[child.text()]] = children[count + 1]\n            _recursive_children(child, labels, widgets)\n\n    app = QtWidgets.QApplication.instance()\n    title = \"Project Settings\"\n    for widget in app.topLevelWidgets():\n        if isinstance(widget, QtWidgets.QMainWindow):\n            if widget.windowTitle() != title:\n                continue\n            _recursive_children(widget, labels, widgets)\n            widget.close()\n\n    msg = \"Setting value \\\"{}\\\" is not a valid option for \\\"{}\\\"\"\n    for key, widget in widgets.items():\n        options = [widget.itemText(i) for i in range(widget.count())]\n        setting_value = presets[key]\n        assert setting_value in options, msg.format(setting_value, key)\n        widget.setCurrentText(presets[key])\n\n    # This code block is for setting up project colorspaces for files on disk.\n    # Due to not having Python API access to set the project settings, the\n    # Foundry recommended way is to modify the hrox files on disk with XML. See\n    # this forum thread for more details;\n    # https://community.foundry.com/discuss/topic/137771/change-a-project-s-default-color-transform-with-python  # noqa\n    '''\n    # backward compatibility layer\n    # TODO: remove this after some time\n    config_data = get_current_context_imageio_config_preset()\n\n    if config_data:\n        presets.update({\n            \"ocioConfigName\": \"custom\"\n        })\n\n    # get path the the active projects\n    project = get_current_project()\n    current_file = project.path()\n\n    msg = \"The project needs to be saved to disk to apply colorspace settings.\"\n    assert current_file, msg\n\n    # save the workfile as subversion \"comment:_colorspaceChange\"\n    split_current_file = os.path.splitext(current_file)\n    copy_current_file = current_file\n\n    if \"_colorspaceChange\" not in current_file:\n        copy_current_file = (\n            split_current_file[0]\n            + \"_colorspaceChange\"\n            + split_current_file[1]\n        )\n\n    try:\n        # duplicate the file so the changes are applied only to the copy\n        shutil.copyfile(current_file, copy_current_file)\n    except shutil.Error:\n        # in case the file already exists and it want to copy to the\n        # same filewe need to do this trick\n        # TEMP file name change\n        copy_current_file_tmp = copy_current_file + \"_tmp\"\n        # create TEMP file\n        shutil.copyfile(current_file, copy_current_file_tmp)\n        # remove original file\n        os.remove(current_file)\n        # copy TEMP back to original name\n        shutil.copyfile(copy_current_file_tmp, copy_current_file)\n        # remove the TEMP file as we dont need it\n        os.remove(copy_current_file_tmp)\n\n    # use the code from below for changing xml hrox Attributes\n    presets.update({\"name\": os.path.basename(copy_current_file)})\n\n    # read HROX in as QDomSocument\n    doc = _read_doc_from_path(copy_current_file)\n\n    # apply project colorspace properties\n    _set_hrox_project_knobs(doc, **presets)\n\n    # write QDomSocument back as HROX\n    _write_doc_to_path(doc, copy_current_file)\n\n    # open the file as current project\n    hiero.core.openProject(copy_current_file)\n    '''\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/api/lib.html#client.ayon_hiero.api.lib.check_inventory_versions","title":"<code>check_inventory_versions(track_items=None)</code>","text":"<p>Actual version color identifier of Loaded containers</p> <p>Check all track items and filter only Loader nodes for its version. It will get all versions from database and check if the node is having actual version. If not then it will color it to red.</p> Source code in <code>client/ayon_hiero/api/lib.py</code> <pre><code>def check_inventory_versions(track_items=None):\n    \"\"\"\n    Actual version color identifier of Loaded containers\n\n    Check all track items and filter only\n    Loader nodes for its version. It will get all versions from database\n    and check if the node is having actual version. If not then it will color\n    it to red.\n    \"\"\"\n    from . import parse_container\n\n    track_items = track_items or get_track_items()\n    # presets\n    clip_color_last = \"green\"\n    clip_color = \"red\"\n\n    containers = []\n    # Find all containers and collect it's node and representation ids\n    for track_item in track_items:\n        container = parse_container(track_item)\n        if container:\n            containers.append(container)\n\n    # Skip if nothing was found\n    if not containers:\n        return\n\n    project_name = get_current_project_name()\n    filter_result = filter_containers(containers, project_name)\n    for container in filter_result.latest:\n        set_track_color(container[\"_item\"], clip_color_last)\n\n    for container in filter_result.outdated:\n        set_track_color(container[\"_item\"], clip_color)\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/api/lib.html#client.ayon_hiero.api.lib.create_bin","title":"<code>create_bin(path=None, project=None)</code>","text":"<p>Create bin in project. If the path is \"bin1/bin2/bin3\" it will create whole depth and return <code>bin3</code></p> Source code in <code>client/ayon_hiero/api/lib.py</code> <pre><code>def create_bin(path=None, project=None):\n    '''\n    Create bin in project.\n    If the path is \"bin1/bin2/bin3\" it will create whole depth\n    and return `bin3`\n\n    '''\n    # get the first loaded project\n    project = project or get_current_project()\n\n    path = path or DEFAULT_BIN_NAME\n\n    path = path.replace(\"\\\\\", \"/\").split(\"/\")\n\n    root_bin = project.clipsBin()\n\n    done_bin_lst = []\n    for i, b in enumerate(path):\n        if i == 0 and len(path) &gt; 1:\n            if b in [bin.name() for bin in root_bin.bins()]:\n                bin = [bin for bin in root_bin.bins() if b in bin.name()][0]\n                done_bin_lst.append(bin)\n            else:\n                create_bin = hiero.core.Bin(b)\n                root_bin.addItem(create_bin)\n                done_bin_lst.append(create_bin)\n\n        elif i &gt;= 1 and i &lt; len(path) - 1:\n            if b in [bin.name() for bin in done_bin_lst[i - 1].bins()]:\n                bin = [\n                    bin for bin in done_bin_lst[i - 1].bins()\n                    if b in bin.name()\n                ][0]\n                done_bin_lst.append(bin)\n            else:\n                create_bin = hiero.core.Bin(b)\n                done_bin_lst[i - 1].addItem(create_bin)\n                done_bin_lst.append(create_bin)\n\n        elif i == len(path) - 1:\n            if b in [bin.name() for bin in done_bin_lst[i - 1].bins()]:\n                bin = [\n                    bin for bin in done_bin_lst[i - 1].bins()\n                    if b in bin.name()\n                ][0]\n                done_bin_lst.append(bin)\n            else:\n                create_bin = hiero.core.Bin(b)\n                done_bin_lst[i - 1].addItem(create_bin)\n                done_bin_lst.append(create_bin)\n\n    return done_bin_lst[-1]\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/api/lib.html#client.ayon_hiero.api.lib.create_nuke_workfile_clips","title":"<code>create_nuke_workfile_clips(nuke_workfiles, seq=None)</code>","text":"<p>nuke_workfiles is list of dictionaries like: [{     'path': 'P:/Jakub_testy_pipeline/test_v01.nk',     'name': 'test',     'handleStart': 15, # added asymmetrically to handles     'handleEnd': 10, # added asymmetrically to handles     \"clipIn\": 16,     \"frameStart\": 991,     \"frameEnd\": 1023,     'task': 'Comp-tracking',     'work_dir': 'VFX_PR',     'shot': '00010' }]</p> Source code in <code>client/ayon_hiero/api/lib.py</code> <pre><code>def create_nuke_workfile_clips(nuke_workfiles, seq=None):\n    '''\n    nuke_workfiles is list of dictionaries like:\n    [{\n        'path': 'P:/Jakub_testy_pipeline/test_v01.nk',\n        'name': 'test',\n        'handleStart': 15, # added asymmetrically to handles\n        'handleEnd': 10, # added asymmetrically to handles\n        \"clipIn\": 16,\n        \"frameStart\": 991,\n        \"frameEnd\": 1023,\n        'task': 'Comp-tracking',\n        'work_dir': 'VFX_PR',\n        'shot': '00010'\n    }]\n    '''\n\n    proj = hiero.core.projects()[-1]\n    root = proj.clipsBin()\n\n    if not seq:\n        seq = hiero.core.Sequence('NewSequences')\n        root.addItem(hiero.core.BinItem(seq))\n    # todo will need to define this better\n    # track = seq[1]  # lazy example to get a destination#  track\n    clips_lst = []\n    for nk in nuke_workfiles:\n        task_path = '/'.join([nk['work_dir'], nk['shot'], nk['task']])\n        bin = create_bin(task_path, proj)\n\n        if nk['task'] not in seq.videoTracks():\n            track = hiero.core.VideoTrack(nk['task'])\n            seq.addTrack(track)\n        else:\n            track = seq.tracks(nk['task'])\n\n        # create clip media\n        media = hiero.core.MediaSource(nk['path'])\n        media_in = int(media.startTime() or 0)\n        media_duration = int(media.duration() or 0)\n\n        handle_start = nk.get(\"handleStart\")\n        handle_end = nk.get(\"handleEnd\")\n\n        if media_in:\n            source_in = media_in + handle_start\n        else:\n            source_in = nk[\"frameStart\"] + handle_start\n\n        if media_duration:\n            source_out = (media_in + media_duration - 1) - handle_end\n        else:\n            source_out = nk[\"frameEnd\"] - handle_end\n\n        source = hiero.core.Clip(media)\n\n        name = os.path.basename(os.path.splitext(nk['path'])[0])\n        split_name = split_by_client_version(name)[0] or name\n\n        # add to bin as clip item\n        items_in_bin = [b.name() for b in bin.items()]\n        if split_name not in items_in_bin:\n            binItem = hiero.core.BinItem(source)\n            bin.addItem(binItem)\n\n        new_source = [\n            item for item in bin.items() if split_name in item.name()\n        ][0].items()[0].item()\n\n        # add to track as clip item\n        trackItem = hiero.core.TrackItem(\n            split_name, hiero.core.TrackItem.kVideo)\n        trackItem.setSource(new_source)\n        trackItem.setSourceIn(source_in)\n        trackItem.setSourceOut(source_out)\n        trackItem.setTimelineIn(nk[\"clipIn\"])\n        trackItem.setTimelineOut(nk[\"clipIn\"] + (source_out - source_in))\n        track.addTrackItem(trackItem)\n        clips_lst.append(trackItem)\n\n    return clips_lst\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/api/lib.html#client.ayon_hiero.api.lib.deprecated","title":"<code>deprecated(new_destination)</code>","text":"<p>Mark functions as deprecated.</p> <p>It will result in a warning being emitted when the function is used.</p> Source code in <code>client/ayon_hiero/api/lib.py</code> <pre><code>def deprecated(new_destination):\n    \"\"\"Mark functions as deprecated.\n\n    It will result in a warning being emitted when the function is used.\n    \"\"\"\n\n    func = None\n    if callable(new_destination):\n        func = new_destination\n        new_destination = None\n\n    def _decorator(decorated_func):\n        if new_destination is None:\n            warning_message = (\n                \" Please check content of deprecated function to figure out\"\n                \" possible replacement.\"\n            )\n        else:\n            warning_message = \" Please replace your usage with '{}'.\".format(\n                new_destination\n            )\n\n        @functools.wraps(decorated_func)\n        def wrapper(*args, **kwargs):\n            warnings.simplefilter(\"always\", DeprecatedWarning)\n            warnings.warn(\n                (\n                    \"Call to deprecated function '{}'\"\n                    \"\\nFunction was moved or removed.{}\"\n                ).format(decorated_func.__name__, warning_message),\n                category=DeprecatedWarning,\n                stacklevel=4\n            )\n            return decorated_func(*args, **kwargs)\n        return wrapper\n\n    if func is None:\n        return _decorator\n    return _decorator(func)\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/api/lib.html#client.ayon_hiero.api.lib.get_current_sequence","title":"<code>get_current_sequence(name=None, new=False)</code>","text":"<p>Get current sequence in context of active project.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str)[optional]</code> <p>name of sequence we want to return</p> <code>None</code> <code>new</code> <code>bool)[optional]</code> <p>if we want to create new one</p> <code>False</code> <p>Returns:</p> Type Description <p>hiero.core.Sequence: the sequence object</p> Source code in <code>client/ayon_hiero/api/lib.py</code> <pre><code>def get_current_sequence(name=None, new=False):\n    \"\"\"\n    Get current sequence in context of active project.\n\n    Args:\n        name (str)[optional]: name of sequence we want to return\n        new (bool)[optional]: if we want to create new one\n\n    Returns:\n        hiero.core.Sequence: the sequence object\n    \"\"\"\n    sequence = None\n    project = get_current_project()\n    root_bin = project.clipsBin()\n\n    if new:\n        # create new\n        name = name or DEFAULT_SEQUENCE_NAME\n        sequence = hiero.core.Sequence(name)\n        root_bin.addItem(hiero.core.BinItem(sequence))\n    elif name:\n        # look for sequence by name\n        sequences = project.sequences()\n        for _sequence in sequences:\n            if _sequence.name() == name:\n                sequence = _sequence\n        if not sequence:\n            # if nothing found create new with input name\n            sequence = get_current_sequence(name, True)\n    else:\n        # if name is none and new is False then return current open sequence\n        sequence = hiero.ui.activeSequence()\n\n    return sequence\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/api/lib.html#client.ayon_hiero.api.lib.get_current_track","title":"<code>get_current_track(sequence, name, audio=False)</code>","text":"<p>Get current track in context of active project.</p> <p>Creates new if none is found.</p> <p>Parameters:</p> Name Type Description Default <code>sequence</code> <code>Sequence</code> <p>hiero sequence object</p> required <code>name</code> <code>str</code> <p>name of track we want to return</p> required <code>audio</code> <code>bool)[optional]</code> <p>switch to AudioTrack</p> <code>False</code> <p>Returns:</p> Type Description <p>hiero.core.Track: the track object</p> Source code in <code>client/ayon_hiero/api/lib.py</code> <pre><code>def get_current_track(sequence, name, audio=False):\n    \"\"\"\n    Get current track in context of active project.\n\n    Creates new if none is found.\n\n    Args:\n        sequence (hiero.core.Sequence): hiero sequence object\n        name (str): name of track we want to return\n        audio (bool)[optional]: switch to AudioTrack\n\n    Returns:\n        hiero.core.Track: the track object\n    \"\"\"\n    tracks = sequence.videoTracks()\n\n    if audio:\n        tracks = sequence.audioTracks()\n\n    # get track by name\n    track = None\n    for _track in tracks:\n        if _track.name() == name:\n            track = _track\n\n    if not track:\n        if not audio:\n            track = hiero.core.VideoTrack(name)\n        else:\n            track = hiero.core.AudioTrack(name)\n\n        sequence.addTrack(track)\n\n    return track\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/api/lib.html#client.ayon_hiero.api.lib.get_main_window","title":"<code>get_main_window()</code>","text":"<p>Acquire Nuke's main window</p> Source code in <code>client/ayon_hiero/api/lib.py</code> <pre><code>def get_main_window():\n    \"\"\"Acquire Nuke's main window\"\"\"\n    if _CTX.parent_gui is None:\n        top_widgets = QtWidgets.QApplication.topLevelWidgets()\n        name = \"Foundry::UI::DockMainWindow\"\n        main_window = next(widget for widget in top_widgets if\n                           widget.inherits(\"QMainWindow\") and\n                           widget.metaObject().className() == name)\n        _CTX.parent_gui = main_window\n    return _CTX.parent_gui\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/api/lib.html#client.ayon_hiero.api.lib.get_sequence_pattern_and_padding","title":"<code>get_sequence_pattern_and_padding(file)</code>","text":"<p>Return sequence pattern and padding from file</p> <p>Attributes:</p> Name Type Description <code>file</code> <code>string</code> <p>basename form path</p> Example <p>Can find file.0001.ext, file.%02d.ext, file.####.ext</p> Return <p>string: any matching sequence pattern int: padding of sequence numbering</p> Source code in <code>client/ayon_hiero/api/lib.py</code> <pre><code>def get_sequence_pattern_and_padding(file):\n    \"\"\" Return sequence pattern and padding from file\n\n    Attributes:\n        file (string): basename form path\n\n    Example:\n        Can find file.0001.ext, file.%02d.ext, file.####.ext\n\n    Return:\n        string: any matching sequence pattern\n        int: padding of sequence numbering\n    \"\"\"\n    foundall = re.findall(\n        r\"(#+)|(%\\d+d)|(?&lt;=[^a-zA-Z0-9])(\\d+)(?=\\.\\w+$)\", file)\n    if not foundall:\n        return None, None\n    found = sorted(list(set(foundall[0])))[-1]\n\n    padding = int(\n        re.findall(r\"\\d+\", found)[-1]) if \"%\" in found else len(found)\n    return found, padding\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/api/lib.html#client.ayon_hiero.api.lib.get_track_ayon_data","title":"<code>get_track_ayon_data(track, container_name=None)</code>","text":"<p>Get track's AYON tag data.</p> <p>Attributes:</p> Name Type Description <code>trackItem</code> <code>VideoTrack</code> <p>hiero object</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>data found on the AYON tag</p> Source code in <code>client/ayon_hiero/api/lib.py</code> <pre><code>def get_track_ayon_data(track, container_name=None):\n    \"\"\"\n    Get track's AYON tag data.\n\n    Attributes:\n        trackItem (hiero.core.VideoTrack): hiero object\n\n    Returns:\n        dict: data found on the AYON tag\n    \"\"\"\n    return_data = {}\n    # get pype data tag from track item\n    tag = get_track_ayon_tag(track)\n\n    if not tag:\n        return None\n\n    # get tag metadata attribute\n    tag_data = deepcopy(dict(tag.metadata()))\n    if tag_data.get(\"tag.json_metadata\"):\n        tag_data = json.loads(tag_data[\"tag.json_metadata\"])\n\n    ignore_names  = {\"applieswhole\", \"note\", \"label\"}\n    for obj_name, obj_data in tag_data.items():\n        obj_name = obj_name.replace(\"tag.\", \"\")\n\n        if obj_name in ignore_names:\n            continue\n        if isinstance(obj_data, dict):\n            return_data[obj_name] = obj_data\n        else:\n            return_data[obj_name] = json.loads(obj_data)\n\n    return (\n        return_data[container_name]\n        if container_name\n        else return_data\n    )\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/api/lib.html#client.ayon_hiero.api.lib.get_track_ayon_tag","title":"<code>get_track_ayon_tag(track)</code>","text":"<p>Get AYON track item tag created by creator or loader plugin.</p> <p>Attributes:</p> Name Type Description <code>trackItem</code> <code>TrackItem</code> <p>hiero object</p> <p>Returns:</p> Type Description <p>hiero.core.Tag: hierarchy, orig clip attributes</p> Source code in <code>client/ayon_hiero/api/lib.py</code> <pre><code>def get_track_ayon_tag(track):\n    \"\"\"\n    Get AYON track item tag created by creator or loader plugin.\n\n    Attributes:\n        trackItem (hiero.core.TrackItem): hiero object\n\n    Returns:\n        hiero.core.Tag: hierarchy, orig clip attributes\n    \"\"\"\n    # get all tags from track item\n    _tags = track.tags()\n    if not _tags:\n        return None\n    for tag in _tags:\n        # return only correct tag defined by global name\n        if AYON_TAG_NAME in tag.name():\n            return tag\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/api/lib.html#client.ayon_hiero.api.lib.get_track_item_tags","title":"<code>get_track_item_tags(track_item)</code>","text":"<p>Get track item tags excluding AYON tag</p> <p>Attributes:</p> Name Type Description <code>trackItem</code> <code>TrackItem</code> <p>hiero object</p> <p>Returns:</p> Type Description <p>hiero.core.Tag: hierarchy, orig clip attributes</p> Source code in <code>client/ayon_hiero/api/lib.py</code> <pre><code>def get_track_item_tags(track_item):\n    \"\"\"\n    Get track item tags excluding AYON tag\n\n    Attributes:\n        trackItem (hiero.core.TrackItem): hiero object\n\n    Returns:\n        hiero.core.Tag: hierarchy, orig clip attributes\n    \"\"\"\n    returning_tag_data = []\n    # get all tags from track item\n    _tags = track_item.tags()\n    if not _tags:\n        return []\n\n    # collect all tags which are not AYON tag\n    returning_tag_data.extend(\n        tag for tag in _tags\n        if tag.name() != AYON_TAG_NAME\n    )\n\n    return returning_tag_data\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/api/lib.html#client.ayon_hiero.api.lib.get_track_items","title":"<code>get_track_items(selection=False, sequence_name=None, track_item_name=None, track_name=None, track_type=None, check_enabled=True, check_locked=True, check_tagged=False)</code>","text":"<p>Get all available current timeline track items.</p> Attribute <p>selection (list)[optional]: list of selected track items sequence_name (str)[optional]: return only clips from input sequence track_item_name (str)[optional]: return only item with input name track_name (str)[optional]: return only items from track name track_type (str)[optional]: return only items of given type                             (<code>audio</code> or <code>video</code>) default is <code>video</code> check_enabled (bool)[optional]: ignore disabled if True check_locked (bool)[optional]: ignore locked if True</p> Return <p>list or hiero.core.TrackItem: list of track items or single track item</p> Source code in <code>client/ayon_hiero/api/lib.py</code> <pre><code>def get_track_items(\n        selection=False,\n        sequence_name=None,\n        track_item_name=None,\n        track_name=None,\n        track_type=None,\n        check_enabled=True,\n        check_locked=True,\n        check_tagged=False):\n    \"\"\"Get all available current timeline track items.\n\n    Attribute:\n        selection (list)[optional]: list of selected track items\n        sequence_name (str)[optional]: return only clips from input sequence\n        track_item_name (str)[optional]: return only item with input name\n        track_name (str)[optional]: return only items from track name\n        track_type (str)[optional]: return only items of given type\n                                    (`audio` or `video`) default is `video`\n        check_enabled (bool)[optional]: ignore disabled if True\n        check_locked (bool)[optional]: ignore locked if True\n\n    Return:\n        list or hiero.core.TrackItem: list of track items or single track item\n    \"\"\"\n    track_type = track_type or \"video\"\n    selection = selection or []\n    return_list = []\n\n    # get selected track items or all in active sequence\n    if selection:\n        try:\n            for track_item in selection:\n                log.info(\"___ track_item: {}\".format(track_item))\n                # make sure only trackitems are selected\n                if not isinstance(track_item, hiero.core.TrackItem):\n                    continue\n\n                if _validate_all_atrributes(\n                    track_item,\n                    track_item_name,\n                    track_name,\n                    track_type,\n                    check_enabled,\n                    check_tagged\n                ):\n                    log.info(\"___ valid trackitem: {}\".format(track_item))\n                    return_list.append(track_item)\n        except AttributeError:\n            pass\n\n    # collect all available active sequence track items\n    if not return_list:\n        sequence = get_current_sequence(name=sequence_name)\n        tracks = []\n        if sequence is not None:\n            # get all available tracks from sequence\n            tracks.extend(sequence.audioTracks())\n            tracks.extend(sequence.videoTracks())\n\n        # loop all tracks\n        for track in tracks:\n            if check_locked and track.isLocked():\n                continue\n            if check_enabled and not track.isEnabled():\n                continue\n            # and all items in track\n            for track_item in track.items():\n                # make sure no subtrackitem is also track items\n                if not isinstance(track_item, hiero.core.TrackItem):\n                    continue\n\n                if _validate_all_atrributes(\n                    track_item,\n                    track_item_name,\n                    track_name,\n                    track_type,\n                    check_enabled,\n                    check_tagged\n                ):\n                    return_list.append(track_item)\n\n    return return_list\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/api/lib.html#client.ayon_hiero.api.lib.get_trackitem_ayon_data","title":"<code>get_trackitem_ayon_data(track_item)</code>","text":"<p>Get track item's AYON tag data.</p> <p>Attributes:</p> Name Type Description <code>trackItem</code> <code>TrackItem</code> <p>hiero object</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>data found on pype tag</p> Source code in <code>client/ayon_hiero/api/lib.py</code> <pre><code>def get_trackitem_ayon_data(track_item):\n    \"\"\"\n    Get track item's AYON tag data.\n\n    Attributes:\n        trackItem (hiero.core.TrackItem): hiero object\n\n    Returns:\n        dict: data found on pype tag\n    \"\"\"\n    data = {}\n    # get pype data tag from track item\n    tag = get_trackitem_ayon_tag(track_item)\n\n    if not tag:\n        return None\n\n    # get tag metadata attribute\n    tag_data = deepcopy(dict(tag.metadata()))\n    if tag_data.get(\"tag.json_metadata\"):\n        return json.loads(tag_data.get(\"tag.json_metadata\"))\n\n    # convert tag metadata to normal keys names and values to correct types\n    for k, v in tag_data.items():\n        key = k.replace(\"tag.\", \"\")\n\n        try:\n            # capture exceptions which are related to strings only\n            if re.match(r\"^[\\d]+$\", v):\n                value = int(v)\n            elif re.match(r\"^True$\", v):\n                value = True\n            elif re.match(r\"^False$\", v):\n                value = False\n            elif re.match(r\"^None$\", v):\n                value = None\n            elif re.match(r\"^[\\w\\d_]+$\", v):\n                value = v\n            else:\n                value = ast.literal_eval(v)\n        except (ValueError, SyntaxError):\n            value = v\n\n        data[key] = value\n\n    return data\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/api/lib.html#client.ayon_hiero.api.lib.get_trackitem_ayon_tag","title":"<code>get_trackitem_ayon_tag(track_item, tag_name=AYON_TAG_NAME)</code>","text":"<p>Get pype track item tag created by creator or loader plugin.</p> <p>Attributes:</p> Name Type Description <code>trackItem</code> <code>TrackItem</code> <p>hiero object</p> <code>tag_name</code> <code>str</code> <p>The tag name.</p> <p>Returns:</p> Type Description <p>hiero.core.Tag: hierarchy, orig clip attributes</p> Source code in <code>client/ayon_hiero/api/lib.py</code> <pre><code>def get_trackitem_ayon_tag(track_item, tag_name=AYON_TAG_NAME):\n    \"\"\"\n    Get pype track item tag created by creator or loader plugin.\n\n    Attributes:\n        trackItem (hiero.core.TrackItem): hiero object\n        tag_name (str): The tag name.\n\n    Returns:\n        hiero.core.Tag: hierarchy, orig clip attributes\n    \"\"\"\n    # get all tags from track item\n    _tags = track_item.tags()\n    if not _tags:\n        return None\n    for tag in _tags:\n        # return only correct tag defined by global name\n        if tag_name in tag.name():\n            return tag\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/api/lib.html#client.ayon_hiero.api.lib.imprint","title":"<code>imprint(track_item, data=None)</code>","text":"<p>Adding <code>Avalon data</code> into a hiero track item tag.</p> <p>Also including publish attribute into tag.</p> <p>Parameters:</p> Name Type Description Default <code>track_item</code> <code>TrackItem</code> <p>hiero track item object</p> required <code>data</code> <code>dict</code> <p>Any data which needs to be imprinted</p> <code>None</code> <p>Examples:</p> <p>data = {     'folderPath': '/shots/sq020sh0280',     'productType': 'render',     'productName': 'productMain' }</p> Source code in <code>client/ayon_hiero/api/lib.py</code> <pre><code>def imprint(track_item, data=None):\n    \"\"\"\n    Adding `Avalon data` into a hiero track item tag.\n\n    Also including publish attribute into tag.\n\n    Arguments:\n        track_item (hiero.core.TrackItem): hiero track item object\n        data (dict): Any data which needs to be imprinted\n\n    Examples:\n        data = {\n            'folderPath': '/shots/sq020sh0280',\n            'productType': 'render',\n            'productName': 'productMain'\n        }\n    \"\"\"\n    data = data or {}\n\n    set_trackitem_ayon_tag(track_item, data)\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/api/lib.html#client.ayon_hiero.api.lib.launch_workfiles_app","title":"<code>launch_workfiles_app(event)</code>","text":"<p>Event for launching workfiles after hiero start</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>obj</code> <p>required but unused</p> required Source code in <code>client/ayon_hiero/api/lib.py</code> <pre><code>def launch_workfiles_app(event):\n    \"\"\"\n    Event for launching workfiles after hiero start\n\n    Args:\n        event (obj): required but unused\n    \"\"\"\n    from . import launch_workfiles_app\n    launch_workfiles_app()\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/api/lib.html#client.ayon_hiero.api.lib.selection_changed_timeline","title":"<code>selection_changed_timeline(event)</code>","text":"<p>Callback on timeline to check if asset in data is the same as clip name.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>Event</code> <p>timeline event</p> required Source code in <code>client/ayon_hiero/api/lib.py</code> <pre><code>def selection_changed_timeline(event):\n    \"\"\"Callback on timeline to check if asset in data is the same as clip name.\n\n    Args:\n        event (hiero.core.Event): timeline event\n    \"\"\"\n    timeline_editor = event.sender\n    selection = timeline_editor.selection()\n\n    track_items = get_track_items(\n        selection=selection,\n        track_type=\"video\",\n        check_enabled=True,\n        check_locked=True,\n        check_tagged=True\n    )\n\n    # run checking function\n    sync_clip_name_to_data_asset(track_items)\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/api/lib.html#client.ayon_hiero.api.lib.set_track_ayon_tag","title":"<code>set_track_ayon_tag(track, data=None)</code>","text":"<p>Set AYON track tag to input track object.</p> <p>Attributes:</p> Name Type Description <code>track</code> <code>VideoTrack</code> <p>hiero object</p> <p>Returns:</p> Type Description <p>hiero.core.Tag</p> Source code in <code>client/ayon_hiero/api/lib.py</code> <pre><code>def set_track_ayon_tag(track, data=None):\n    \"\"\"\n    Set AYON track tag to input track object.\n\n    Attributes:\n        track (hiero.core.VideoTrack): hiero object\n\n    Returns:\n        hiero.core.Tag\n    \"\"\"\n    data = data or {}\n\n    # basic Tag's attribute\n    tag_data = {\n        \"editable\": \"0\",\n        \"note\": \"AYON data container\",\n        \"icon\": \"AYON_icon.png\",\n        \"metadata\": dict(data.items())\n    }\n    # get available pype tag if any\n    _tag = get_track_ayon_tag(track)\n\n    if _tag:\n        # it not tag then create one\n        tag = tags.update_tag(_tag, tag_data)\n    else:\n        # if pype tag available then update with input data\n        tag = tags.create_tag(\n            \"{}_{}\".format(\n                AYON_TAG_NAME,\n                _get_tag_unique_hash()\n            ),\n            tag_data\n        )\n        # add it to the input track item\n        track.addTag(tag)\n\n    return tag\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/api/lib.html#client.ayon_hiero.api.lib.set_trackitem_ayon_tag","title":"<code>set_trackitem_ayon_tag(track_item, data=None)</code>","text":"<p>Set AYON track tag to input track object.</p> <p>Attributes:</p> Name Type Description <code>track</code> <code>VideoTrack</code> <p>hiero object</p> <p>Returns:</p> Type Description <p>hiero.core.Tag</p> Source code in <code>client/ayon_hiero/api/lib.py</code> <pre><code>def set_trackitem_ayon_tag(track_item, data=None):\n    \"\"\"\n    Set AYON track tag to input track object.\n\n    Attributes:\n        track (hiero.core.VideoTrack): hiero object\n\n    Returns:\n        hiero.core.Tag\n    \"\"\"\n    data = data or {}\n\n    # basic Tag's attribute\n    tag_data = {\n        \"editable\": \"0\",\n        \"note\": \"AYON data container\",\n        \"icon\": \"AYON_icon.png\",\n        \"metadata\": dict(data.items())\n    }\n    # get available pype tag if any\n    _tag = get_trackitem_ayon_tag(track_item)\n    if _tag:\n        # if pype tag available then update with input data\n        tag = tags.update_tag(_tag, tag_data)\n    else:\n        # it not tag then create one\n        tag = tags.create_tag(\n            \"{}_{}\".format(\n                AYON_TAG_NAME,\n                _get_tag_unique_hash()\n            ),\n            tag_data\n        )\n        # add it to the input track item\n        track_item.addTag(tag)\n\n    return tag\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/api/lib.html#client.ayon_hiero.api.lib.setup","title":"<code>setup(console=False, port=None, menu=True)</code>","text":"<p>Setup integration</p> <p>Registers Pyblish for Hiero plug-ins and appends an item to the File-menu</p> <p>Parameters:</p> Name Type Description Default <code>console</code> <code>bool</code> <p>Display console with GUI</p> <code>False</code> <code>port</code> <code>int</code> <p>Port from which to start looking for an available port to connect with Pyblish QML, default provided by Pyblish Integration.</p> <code>None</code> <code>menu</code> <code>bool</code> <p>Display file menu in Hiero.</p> <code>True</code> Source code in <code>client/ayon_hiero/api/lib.py</code> <pre><code>def setup(console=False, port=None, menu=True):\n    \"\"\"Setup integration\n\n    Registers Pyblish for Hiero plug-ins and appends an item to the File-menu\n\n    Arguments:\n        console (bool): Display console with GUI\n        port (int, optional): Port from which to start looking for an\n            available port to connect with Pyblish QML, default\n            provided by Pyblish Integration.\n        menu (bool, optional): Display file menu in Hiero.\n    \"\"\"\n\n    if _CTX.has_been_setup:\n        teardown()\n\n    add_submission()\n\n    if menu:\n        add_to_filemenu()\n        _CTX.has_menu = True\n\n    _CTX.has_been_setup = True\n    log.debug(\"pyblish: Loaded successfully.\")\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/api/lib.html#client.ayon_hiero.api.lib.teardown","title":"<code>teardown()</code>","text":"<p>Remove integration</p> Source code in <code>client/ayon_hiero/api/lib.py</code> <pre><code>def teardown():\n    \"\"\"Remove integration\"\"\"\n    if not _CTX.has_been_setup:\n        return\n\n    if _CTX.has_menu:\n        remove_from_filemenu()\n        _CTX.has_menu = False\n\n    _CTX.has_been_setup = False\n    log.debug(\"pyblish: Integration torn down successfully\")\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/api/menu.html","title":"menu","text":""},{"location":"autoapi/client/ayon_hiero/api/menu.html#client.ayon_hiero.api.menu.menu_install","title":"<code>menu_install()</code>","text":"<p>Installing menu into Hiero</p> Source code in <code>client/ayon_hiero/api/menu.py</code> <pre><code>def menu_install():\n    \"\"\"\n    Installing menu into Hiero\n\n    \"\"\"\n\n    from . import (\n        launch_workfiles_app, reload_config,\n        apply_colorspace_project, apply_colorspace_clips\n    )\n    from .lib import get_main_window\n\n    main_window = get_main_window()\n\n    # here is the best place to add menu\n\n    menu_name = os.environ['AYON_MENU_LABEL']\n\n    context_label = get_context_label()\n\n    self._change_context_menu = context_label\n\n    try:\n        check_made_menu = findMenuAction(menu_name)\n    except Exception:\n        check_made_menu = None\n\n    if not check_made_menu:\n        # Grab Hiero's MenuBar\n        menu = hiero.ui.menuBar().addMenu(menu_name)\n    else:\n        menu = check_made_menu.menu()\n\n    context_label_action = menu.addAction(context_label)\n    context_label_action.setEnabled(False)\n\n    menu.addSeparator()\n\n    workfiles_action = menu.addAction(\"Work Files...\")\n    workfiles_action.setIcon(QtGui.QIcon(\"icons:Position.png\"))\n    workfiles_action.triggered.connect(launch_workfiles_app)\n\n    default_tags_action = menu.addAction(\"Create Default Tags\")\n    default_tags_action.setIcon(QtGui.QIcon(\"icons:Position.png\"))\n    default_tags_action.triggered.connect(tags.add_tags_to_workfile)\n\n    menu.addSeparator()\n\n    creator_action = menu.addAction(\"Create...\")\n    creator_action.setIcon(QtGui.QIcon(\"icons:CopyRectangle.png\"))\n    creator_action.triggered.connect(\n        lambda: host_tools.show_publisher(tab=\"create\", parent=main_window)\n    )\n\n    publish_action = menu.addAction(\"Publish...\")\n    publish_action.setIcon(QtGui.QIcon(\"icons:Output.png\"))\n    publish_action.triggered.connect(\n        lambda *args: host_tools.show_publisher(tab=\"publish\", parent=main_window)\n    )\n\n    loader_action = menu.addAction(\"Load...\")\n    loader_action.setIcon(QtGui.QIcon(\"icons:CopyRectangle.png\"))\n    loader_action.triggered.connect(\n        lambda: host_tools.show_loader(parent=main_window)\n    )\n\n    sceneinventory_action = menu.addAction(\"Manage...\")\n    sceneinventory_action.setIcon(QtGui.QIcon(\"icons:CopyRectangle.png\"))\n    sceneinventory_action.triggered.connect(\n        lambda: host_tools.show_scene_inventory(parent=main_window)\n    )\n\n    library_action = menu.addAction(\"Library...\")\n    library_action.setIcon(QtGui.QIcon(\"icons:CopyRectangle.png\"))\n    library_action.triggered.connect(\n        lambda: host_tools.show_library_loader(parent=main_window)\n    )\n\n    if is_dev_mode_enabled():\n        menu.addSeparator()\n        reload_action = menu.addAction(\"Reload pipeline\")\n        reload_action.setIcon(QtGui.QIcon(\"icons:ColorAdd.png\"))\n        reload_action.triggered.connect(reload_config)\n\n    menu.addSeparator()\n    apply_colorspace_p_action = menu.addAction(\"Apply Colorspace Project\")\n    apply_colorspace_p_action.setIcon(QtGui.QIcon(\"icons:ColorAdd.png\"))\n    apply_colorspace_p_action.triggered.connect(apply_colorspace_project)\n\n    apply_colorspace_c_action = menu.addAction(\"Apply Colorspace Clips\")\n    apply_colorspace_c_action.setIcon(QtGui.QIcon(\"icons:ColorAdd.png\"))\n    apply_colorspace_c_action.triggered.connect(apply_colorspace_clips)\n\n    menu.addSeparator()\n\n    exeprimental_action = menu.addAction(\"Experimental tools...\")\n    exeprimental_action.triggered.connect(\n        lambda: host_tools.show_experimental_tools_dialog(parent=main_window)\n    )\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/api/menu.html#client.ayon_hiero.api.menu.update_menu_task_label","title":"<code>update_menu_task_label()</code>","text":"<p>Update the task label in Avalon menu to current session</p> Source code in <code>client/ayon_hiero/api/menu.py</code> <pre><code>def update_menu_task_label():\n    \"\"\"Update the task label in Avalon menu to current session\"\"\"\n\n    object_name = self._change_context_menu\n    found_menu = findMenuAction(object_name)\n\n    if not found_menu:\n        log.warning(\"Can't find menuItem: {}\".format(object_name))\n        return\n\n    label = get_context_label()\n\n    menu = found_menu.menu()\n    self._change_context_menu = label\n    menu.setTitle(label)\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/api/pipeline.html","title":"pipeline","text":"<p>Basic avalon integration</p>"},{"location":"autoapi/client/ayon_hiero/api/pipeline.html#client.ayon_hiero.api.pipeline.HieroHost","title":"<code>HieroHost</code>","text":"<p>               Bases: <code>HostBase</code>, <code>IWorkfileHost</code>, <code>ILoadHost</code>, <code>IPublishHost</code></p> Source code in <code>client/ayon_hiero/api/pipeline.py</code> <pre><code>class HieroHost(\n    HostBase, IWorkfileHost, ILoadHost, IPublishHost\n):\n    name = \"hiero\"\n\n    def open_workfile(self, filepath):\n        return open_file(filepath)\n\n    def save_workfile(self, filepath=None):\n        return save_file(filepath)\n\n    def get_current_workfile(self):\n        return current_file()\n\n    def workfile_has_unsaved_changes(self):\n        return has_unsaved_changes()\n\n    def get_workfile_extensions(self):\n        return file_extensions()\n\n    def get_containers(self):\n        return ls()\n\n    def install(self):\n        \"\"\"Installing all requirements for hiero host\"\"\"\n\n        # adding all events\n        events.register_events()\n\n        log.info(\"Registering Hiero plug-ins..\")\n        pyblish.register_host(\"hiero\")\n        pyblish.register_plugin_path(PUBLISH_PATH)\n        register_loader_plugin_path(LOAD_PATH)\n        register_creator_plugin_path(CREATE_PATH)\n\n        # install menu\n        menu.menu_install()\n        menu.add_scripts_menu()\n\n        # register hiero events\n        events.register_hiero_events()\n\n    def get_context_data(self):\n        # TODO: implement to support persisting context attributes\n        return {}\n\n    def update_context_data(self, data, changes):\n        # TODO: implement to support persisting context attributes\n        pass\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/api/pipeline.html#client.ayon_hiero.api.pipeline.HieroHost.install","title":"<code>install()</code>","text":"<p>Installing all requirements for hiero host</p> Source code in <code>client/ayon_hiero/api/pipeline.py</code> <pre><code>def install(self):\n    \"\"\"Installing all requirements for hiero host\"\"\"\n\n    # adding all events\n    events.register_events()\n\n    log.info(\"Registering Hiero plug-ins..\")\n    pyblish.register_host(\"hiero\")\n    pyblish.register_plugin_path(PUBLISH_PATH)\n    register_loader_plugin_path(LOAD_PATH)\n    register_creator_plugin_path(CREATE_PATH)\n\n    # install menu\n    menu.menu_install()\n    menu.add_scripts_menu()\n\n    # register hiero events\n    events.register_hiero_events()\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/api/pipeline.html#client.ayon_hiero.api.pipeline.containerise","title":"<code>containerise(track_item, name, namespace, context, loader=None, data=None)</code>","text":"<p>Bundle Hiero's object into an assembly and imprint it with metadata</p> <p>Containerisation enables a tracking of version, author and origin for loaded assets.</p> <p>Parameters:</p> Name Type Description Default <code>track_item</code> <code>TrackItem</code> <p>object to imprint as container</p> required <code>name</code> <code>str</code> <p>Name of resulting assembly</p> required <code>namespace</code> <code>str</code> <p>Namespace under which to host container</p> required <code>context</code> <code>dict</code> <p>Asset information</p> required <code>loader</code> <code>str</code> <p>Name of node used to produce this container.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>track_item</code> <code>TrackItem</code> <p>containerised object</p> Source code in <code>client/ayon_hiero/api/pipeline.py</code> <pre><code>def containerise(track_item,\n                 name,\n                 namespace,\n                 context,\n                 loader=None,\n                 data=None):\n    \"\"\"Bundle Hiero's object into an assembly and imprint it with metadata\n\n    Containerisation enables a tracking of version, author and origin\n    for loaded assets.\n\n    Arguments:\n        track_item (hiero.core.TrackItem): object to imprint as container\n        name (str): Name of resulting assembly\n        namespace (str): Namespace under which to host container\n        context (dict): Asset information\n        loader (str, optional): Name of node used to produce this container.\n\n    Returns:\n        track_item (hiero.core.TrackItem): containerised object\n\n    \"\"\"\n\n    data_imprint = OrderedDict({\n        \"schema\": \"ayon:container-3.0\",\n        \"id\": AYON_CONTAINER_ID,\n        \"name\": str(name),\n        \"namespace\": str(namespace),\n        \"loader\": str(loader),\n        \"representation\": context[\"representation\"][\"id\"],\n    })\n\n    if data:\n        for k, v in data.items():\n            data_imprint.update({k: v})\n\n    log.debug(\"_ data_imprint: {}\".format(data_imprint))\n    lib.set_trackitem_ayon_tag(track_item, data_imprint)\n\n    return track_item\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/api/pipeline.html#client.ayon_hiero.api.pipeline.launch_workfiles_app","title":"<code>launch_workfiles_app(*args)</code>","text":"<p>Wrapping function for workfiles launcher</p> Source code in <code>client/ayon_hiero/api/pipeline.py</code> <pre><code>def launch_workfiles_app(*args):\n    ''' Wrapping function for workfiles launcher '''\n    from .lib import get_main_window\n\n    main_window = get_main_window()\n    # show workfile gui\n    host_tools.show_workfiles(parent=main_window)\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/api/pipeline.html#client.ayon_hiero.api.pipeline.ls","title":"<code>ls()</code>","text":"<p>List available containers.</p> <p>This function is used by the Container Manager in Nuke. You'll need to implement a for-loop that then yields one Container at a time.</p> <p>See the <code>container.json</code> schema for details on how it should look, and the Maya equivalent, which is in <code>avalon.maya.pipeline</code></p> Source code in <code>client/ayon_hiero/api/pipeline.py</code> <pre><code>def ls():\n    \"\"\"List available containers.\n\n    This function is used by the Container Manager in Nuke. You'll\n    need to implement a for-loop that then *yields* one Container at\n    a time.\n\n    See the `container.json` schema for details on how it should look,\n    and the Maya equivalent, which is in `avalon.maya.pipeline`\n    \"\"\"\n\n    # get all track items from current timeline\n    all_items = lib.get_track_items()\n\n    # append all video tracks\n    for track in (lib.get_current_sequence() or []):\n        if type(track) is not hiero.core.VideoTrack:\n            continue\n        all_items.append(track)\n\n    for item in all_items:\n        container_data = parse_container(item)\n\n        if isinstance(container_data, list):\n            for _c in container_data:\n                yield _c\n        elif container_data:\n            yield container_data\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/api/pipeline.html#client.ayon_hiero.api.pipeline.maintained_selection","title":"<code>maintained_selection()</code>","text":"<p>Maintain selection during context</p> Example <p>with maintained_selection(): ...     for track_item in track_items: ...         &lt; do some stuff &gt;</p> Source code in <code>client/ayon_hiero/api/pipeline.py</code> <pre><code>@contextlib.contextmanager\ndef maintained_selection():\n    \"\"\"Maintain selection during context\n\n    Example:\n        &gt;&gt;&gt; with maintained_selection():\n        ...     for track_item in track_items:\n        ...         &lt; do some stuff &gt;\n    \"\"\"\n    from .lib import (\n        set_selected_track_items,\n        get_selected_track_items\n    )\n    previous_selection = get_selected_track_items()\n    reset_selection()\n    try:\n        # do the operation\n        yield\n    finally:\n        reset_selection()\n        set_selected_track_items(previous_selection)\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/api/pipeline.html#client.ayon_hiero.api.pipeline.parse_container","title":"<code>parse_container(item, validate=True)</code>","text":"<p>Return container data from track_item's pype tag.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>TrackItem or VideoTrack</code> <p>A containerised track item.</p> required <code>validate</code> <code>bool)[optional]</code> <p>validating with avalon scheme</p> <code>True</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>The container schema data for input containerized track item.</p> Source code in <code>client/ayon_hiero/api/pipeline.py</code> <pre><code>def parse_container(item, validate=True):\n    \"\"\"Return container data from track_item's pype tag.\n\n    Args:\n        item (hiero.core.TrackItem or hiero.core.VideoTrack):\n            A containerised track item.\n        validate (bool)[optional]: validating with avalon scheme\n\n    Returns:\n        dict: The container schema data for input containerized track item.\n\n    \"\"\"\n    def data_to_container(item, data):\n        if (\n            not data\n            or data.get(\"id\") not in {\n                AYON_CONTAINER_ID, AVALON_CONTAINER_ID\n            }\n        ):\n            return\n\n        if validate and data and data.get(\"schema\"):\n            schema.validate(data)\n\n        if not isinstance(data, dict):\n            return\n\n        # If not all required data return the empty container\n        required = ['schema', 'id', 'name',\n                    'namespace', 'loader', 'representation']\n\n        if any(key not in data for key in required):\n            return\n\n        container = {key: data[key] for key in required}\n\n        container[\"objectName\"] = item.name()\n\n        # Store reference to the node object\n        container[\"_item\"] = item\n\n        return container\n\n    # convert tag metadata to normal keys names\n    if type(item) is hiero.core.VideoTrack:\n        return_list = []\n        _data = lib.get_track_ayon_data(item)\n\n        if not _data:\n            return\n        # convert the data to list and validate them\n        for _, obj_data in _data.items():\n            container = data_to_container(item, obj_data)\n            return_list.append(container)\n        return return_list\n    else:\n        _data = lib.get_trackitem_ayon_data(item)\n        return data_to_container(item, _data)\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/api/pipeline.html#client.ayon_hiero.api.pipeline.publish","title":"<code>publish(parent)</code>","text":"<p>Shorthand to publish from within host</p> Source code in <code>client/ayon_hiero/api/pipeline.py</code> <pre><code>def publish(parent):\n    \"\"\"Shorthand to publish from within host\"\"\"\n    return host_tools.show_publish(parent)\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/api/pipeline.html#client.ayon_hiero.api.pipeline.reload_config","title":"<code>reload_config()</code>","text":"<p>Attempt to reload pipeline at run-time.</p> <p>CAUTION: This is primarily for development and debugging purposes.</p> Source code in <code>client/ayon_hiero/api/pipeline.py</code> <pre><code>def reload_config():\n    \"\"\"Attempt to reload pipeline at run-time.\n\n    CAUTION: This is primarily for development and debugging purposes.\n\n    \"\"\"\n    import importlib\n\n    for module in (\n        \"ayon_hiero.lib\",\n        \"ayon_hiero.menu\",\n        \"ayon_hiero.tags\"\n    ):\n        log.info(\"Reloading module: {}...\".format(module))\n        try:\n            module = importlib.import_module(module)\n            import imp\n            imp.reload(module)\n        except Exception as e:\n            log.warning(\"Cannot reload module: {}\".format(e))\n            importlib.reload(module)\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/api/pipeline.html#client.ayon_hiero.api.pipeline.reset_selection","title":"<code>reset_selection()</code>","text":"<p>Deselect all selected nodes</p> Source code in <code>client/ayon_hiero/api/pipeline.py</code> <pre><code>def reset_selection():\n    \"\"\"Deselect all selected nodes\n    \"\"\"\n    from .lib import set_selected_track_items\n    set_selected_track_items([])\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/api/pipeline.html#client.ayon_hiero.api.pipeline.update_container","title":"<code>update_container(item, data=None)</code>","text":"<p>Update container data to input track_item or track's AYON tag.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>TrackItem or VideoTrack</code> <p>A containerised track item.</p> required <code>data</code> <code>dict)[optional]</code> <p>dictionery with data to be updated</p> <code>None</code> <p>Returns:</p> Name Type Description <code>bool</code> <p>True if container was updated correctly</p> Source code in <code>client/ayon_hiero/api/pipeline.py</code> <pre><code>def update_container(item, data=None):\n    \"\"\"Update container data to input track_item or track's\n    AYON tag.\n\n    Args:\n        item (hiero.core.TrackItem or hiero.core.VideoTrack):\n            A containerised track item.\n        data (dict)[optional]: dictionery with data to be updated\n\n    Returns:\n        bool: True if container was updated correctly\n\n    \"\"\"\n\n    data = data or {}\n    data = deepcopy(data)\n\n    if type(item) is hiero.core.VideoTrack:\n        # form object data for test\n        object_name = data[\"objectName\"]\n\n        # get all available containers\n        containers = lib.get_track_ayon_data(item)\n        container = lib.get_track_ayon_data(item, object_name)\n\n        containers = deepcopy(containers)\n        container = deepcopy(container)\n\n        # update data in container\n        updated_container = _update_container_data(container, data)\n        # merge updated container back to containers\n        containers.update({object_name: updated_container})\n\n        return bool(lib.set_track_ayon_tag(item, containers))\n    else:\n        container = lib.get_trackitem_ayon_data(item)\n        updated_container = _update_container_data(container, data)\n\n        log.info(\"Updating container: `{}`\".format(item.name()))\n        return bool(lib.set_trackitem_ayon_tag(item, updated_container))\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/api/plugin.html","title":"plugin","text":""},{"location":"autoapi/client/ayon_hiero/api/plugin.html#client.ayon_hiero.api.plugin.ClipLoader","title":"<code>ClipLoader</code>","text":"Source code in <code>client/ayon_hiero/api/plugin.py</code> <pre><code>class ClipLoader:\n\n    active_bin = None\n    data = dict()\n\n    def __init__(self, cls, context, path, **options):\n        \"\"\" Initialize object\n\n        Arguments:\n            cls (ayon_core.api.Loader): plugin object\n            context (dict): loader plugin context\n            options (dict)[optional]: possible keys:\n                projectBinPath: \"path/to/binItem\"\n\n        \"\"\"\n        self.__dict__.update(cls.__dict__)\n        self.context = context\n        self.active_project = lib.get_current_project()\n        self.fname = path\n\n        # try to get value from options or evaluate key value for `handles`\n        self.with_handles = options.get(\"handles\") or bool(\n            options.get(\"handles\") is True)\n        # try to get value from options or evaluate key value for `load_how`\n        self.sequencial_load = options.get(\"sequentially\") or bool(\n            \"Sequentially in order\" in options.get(\"load_how\", \"\"))\n        # try to get value from options or evaluate key value for `load_to`\n        self.new_sequence = options.get(\"newSequence\") or bool(\n            \"New timeline\" in options.get(\"load_to\", \"\"))\n        self.clip_name_template = options.get(\n            \"clipNameTemplate\") or \"{asset}_{subset}_{representation}\"\n        assert self._populate_data(), str(\n            \"Cannot Load selected data, look into database \"\n            \"or call your supervisor\")\n\n        # inject folder data to representation dict\n        folder_entity = self.context[\"folder\"]\n        self.data[\"folderAttributes\"] = folder_entity[\"attrib\"]\n\n        # add active components to class\n        if self.new_sequence:\n            if options.get(\"sequence\"):\n                # if multiselection is set then use options sequence\n                self.active_sequence = options[\"sequence\"]\n            else:\n                # create new sequence\n                self.active_sequence = lib.get_current_sequence(new=True)\n                self.active_sequence.setFramerate(\n                    hiero.core.TimeBase.fromString(\n                        str(self.data[\"folderAttributes\"][\"fps\"])))\n        else:\n            self.active_sequence = lib.get_current_sequence()\n\n        if options.get(\"track\"):\n            # if multiselection is set then use options track\n            self.active_track = options[\"track\"]\n        else:\n            self.active_track = lib.get_current_track(\n                self.active_sequence, self.data[\"track_name\"])\n\n    def _populate_data(self):\n        \"\"\" Gets context and convert it to self.data\n        data structure:\n            {\n                \"name\": \"assetName_productName_representationName\"\n                \"path\": \"path/to/file/created/by/get_repr..\",\n                \"binPath\": \"projectBinPath\",\n            }\n        \"\"\"\n        # create name\n        repr = self.context[\"representation\"]\n        repr_cntx = repr[\"context\"]\n        folder_path = self.context[\"folder\"][\"path\"]\n        product_name = self.context[\"product\"][\"name\"]\n        representation = repr[\"name\"]\n        self.data[\"clip_name\"] = self.clip_name_template.format(**repr_cntx)\n        self.data[\"track_name\"] = \"_\".join([product_name, representation])\n        self.data[\"versionAttributes\"] = self.context[\"version\"][\"attrib\"]\n        # gets file path\n        file = get_representation_path_from_context(self.context)\n        if not file:\n            repr_id = repr[\"id\"]\n            log.warning(\n                \"Representation id `{}` is failing to load\".format(repr_id))\n            return None\n        self.data[\"path\"] = file.replace(\"\\\\\", \"/\")\n\n        # convert to hashed path\n        if repr_cntx.get(\"frame\"):\n            self._fix_path_hashes()\n\n        # solve project bin structure path\n        hierarchy = \"Loader{}\".format(folder_path)\n\n        self.data[\"binPath\"] = hierarchy\n\n        return True\n\n    def _fix_path_hashes(self):\n        \"\"\" Convert file path where it is needed padding with hashes\n        \"\"\"\n        file = self.data[\"path\"]\n        if \"#\" not in file:\n            frame = self.context[\"representation\"][\"context\"].get(\"frame\")\n            padding = len(frame)\n            file = file.replace(frame, \"#\" * padding)\n        self.data[\"path\"] = file\n\n    def _make_track_item(self, source_bin_item, audio=False):\n        \"\"\" Create track item with \"\"\"\n\n        clip = source_bin_item.activeItem()\n\n        # add to track as clip item\n        if not audio:\n            track_item = hiero.core.TrackItem(\n                self.data[\"clip_name\"], hiero.core.TrackItem.kVideo)\n        else:\n            track_item = hiero.core.TrackItem(\n                self.data[\"clip_name\"], hiero.core.TrackItem.kAudio)\n\n        track_item.setSource(clip)\n        track_item.setSourceIn(self.handle_start)\n        track_item.setTimelineIn(self.timeline_in)\n        track_item.setSourceOut((self.media_duration) - self.handle_end)\n        track_item.setTimelineOut(self.timeline_out)\n        track_item.setPlaybackSpeed(1)\n        self.active_track.addTrackItem(track_item)\n\n        return track_item\n\n    def load(self):\n        # create project bin for the media to be imported into\n        self.active_bin = lib.create_bin(self.data[\"binPath\"])\n\n        # create mediaItem in active project bin\n        # create clip media\n        self.media = hiero.core.MediaSource(self.data[\"path\"])\n        self.media_duration = int(self.media.duration())\n\n        # get handles\n        version_attributes = self.data[\"versionAttributes\"]\n        self.handle_start = version_attributes.get(\"handleStart\")\n        self.handle_end = version_attributes.get(\"handleEnd\")\n        if self.handle_start is None:\n            self.handle_start = self.data[\"folderAttributes\"][\"handleStart\"]\n        if self.handle_end is None:\n            self.handle_end = self.data[\"folderAttributes\"][\"handleEnd\"]\n\n        self.handle_start = int(self.handle_start)\n        self.handle_end = int(self.handle_end)\n\n        if self.sequencial_load:\n            last_track_item = lib.get_track_items(\n                sequence_name=self.active_sequence.name(),\n                track_name=self.active_track.name()\n            )\n            if len(last_track_item) == 0:\n                last_timeline_out = 0\n            else:\n                last_track_item = last_track_item[-1]\n                last_timeline_out = int(last_track_item.timelineOut()) + 1\n            self.timeline_in = last_timeline_out\n            self.timeline_out = last_timeline_out + int(\n                self.data[\"folderAttributes\"][\"clipOut\"]\n                - self.data[\"folderAttributes\"][\"clipIn\"])\n        else:\n            self.timeline_in = int(self.data[\"folderAttributes\"][\"clipIn\"])\n            self.timeline_out = int(self.data[\"folderAttributes\"][\"clipOut\"])\n\n        log.debug(\"__ self.timeline_in: {}\".format(self.timeline_in))\n        log.debug(\"__ self.timeline_out: {}\".format(self.timeline_out))\n\n        # check if slate is included\n        slate_on = \"slate\" in self.context[\"version\"][\"data\"].get(\n            \"families\", [])\n        log.debug(\"__ slate_on: {}\".format(slate_on))\n\n        # if slate is on then remove the slate frame from beginning\n        if slate_on:\n            self.media_duration -= 1\n            self.handle_start += 1\n\n        # create Clip from Media\n        clip = hiero.core.Clip(self.media)\n        clip.setName(self.data[\"clip_name\"])\n\n        # add Clip to bin if not there yet\n        if self.data[\"clip_name\"] not in [\n                b.name() for b in self.active_bin.items()]:\n            bin_item = hiero.core.BinItem(clip)\n            self.active_bin.addItem(bin_item)\n\n        # just make sure the clip is created\n        # there were some cases were hiero was not creating it\n        source_bin_item = None\n        for item in self.active_bin.items():\n            if self.data[\"clip_name\"] == item.name():\n                source_bin_item = item\n        if not source_bin_item:\n            log.warning(\"Problem with created Source clip: `{}`\".format(\n                self.data[\"clip_name\"]))\n\n        # include handles\n        if self.with_handles:\n            self.timeline_in -= self.handle_start\n            self.timeline_out += self.handle_end\n            self.handle_start = 0\n            self.handle_end = 0\n\n        # make track item from source in bin as item\n        track_item = self._make_track_item(source_bin_item)\n\n        log.info(\"Loading clips: `{}`\".format(self.data[\"clip_name\"]))\n        return track_item\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/api/plugin.html#client.ayon_hiero.api.plugin.ClipLoader.__init__","title":"<code>__init__(cls, context, path, **options)</code>","text":"<p>Initialize object</p> <p>Parameters:</p> Name Type Description Default <code>cls</code> <code>Loader</code> <p>plugin object</p> required <code>context</code> <code>dict</code> <p>loader plugin context</p> required <code>options</code> <code>dict)[optional]</code> <p>possible keys: projectBinPath: \"path/to/binItem\"</p> <code>{}</code> Source code in <code>client/ayon_hiero/api/plugin.py</code> <pre><code>def __init__(self, cls, context, path, **options):\n    \"\"\" Initialize object\n\n    Arguments:\n        cls (ayon_core.api.Loader): plugin object\n        context (dict): loader plugin context\n        options (dict)[optional]: possible keys:\n            projectBinPath: \"path/to/binItem\"\n\n    \"\"\"\n    self.__dict__.update(cls.__dict__)\n    self.context = context\n    self.active_project = lib.get_current_project()\n    self.fname = path\n\n    # try to get value from options or evaluate key value for `handles`\n    self.with_handles = options.get(\"handles\") or bool(\n        options.get(\"handles\") is True)\n    # try to get value from options or evaluate key value for `load_how`\n    self.sequencial_load = options.get(\"sequentially\") or bool(\n        \"Sequentially in order\" in options.get(\"load_how\", \"\"))\n    # try to get value from options or evaluate key value for `load_to`\n    self.new_sequence = options.get(\"newSequence\") or bool(\n        \"New timeline\" in options.get(\"load_to\", \"\"))\n    self.clip_name_template = options.get(\n        \"clipNameTemplate\") or \"{asset}_{subset}_{representation}\"\n    assert self._populate_data(), str(\n        \"Cannot Load selected data, look into database \"\n        \"or call your supervisor\")\n\n    # inject folder data to representation dict\n    folder_entity = self.context[\"folder\"]\n    self.data[\"folderAttributes\"] = folder_entity[\"attrib\"]\n\n    # add active components to class\n    if self.new_sequence:\n        if options.get(\"sequence\"):\n            # if multiselection is set then use options sequence\n            self.active_sequence = options[\"sequence\"]\n        else:\n            # create new sequence\n            self.active_sequence = lib.get_current_sequence(new=True)\n            self.active_sequence.setFramerate(\n                hiero.core.TimeBase.fromString(\n                    str(self.data[\"folderAttributes\"][\"fps\"])))\n    else:\n        self.active_sequence = lib.get_current_sequence()\n\n    if options.get(\"track\"):\n        # if multiselection is set then use options track\n        self.active_track = options[\"track\"]\n    else:\n        self.active_track = lib.get_current_track(\n            self.active_sequence, self.data[\"track_name\"])\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/api/plugin.html#client.ayon_hiero.api.plugin.CreatorWidget","title":"<code>CreatorWidget</code>","text":"<p>               Bases: <code>QDialog</code></p> Source code in <code>client/ayon_hiero/api/plugin.py</code> <pre><code>class CreatorWidget(QtWidgets.QDialog):\n\n    # output items\n    items = {}\n\n    def __init__(self, name, info, ui_inputs, parent=None):\n        super(CreatorWidget, self).__init__(parent)\n\n        self.setObjectName(name)\n\n        self.setWindowFlags(\n            QtCore.Qt.Window\n            | QtCore.Qt.CustomizeWindowHint\n            | QtCore.Qt.WindowTitleHint\n            | QtCore.Qt.WindowCloseButtonHint\n            | QtCore.Qt.WindowStaysOnTopHint\n        )\n        self.setWindowTitle(name or \"AYON Creator Input\")\n        self.resize(500, 700)\n\n        # Where inputs and labels are set\n        self.content_widget = [QtWidgets.QWidget(self)]\n        top_layout = QtWidgets.QFormLayout(self.content_widget[0])\n        top_layout.setObjectName(\"ContentLayout\")\n        top_layout.addWidget(Spacer(5, self))\n\n        # first add widget tag line\n        top_layout.addWidget(QtWidgets.QLabel(info))\n\n        # main dynamic layout\n        self.scroll_area = QtWidgets.QScrollArea(self, widgetResizable=True)\n        self.scroll_area.setVerticalScrollBarPolicy(\n            QtCore.Qt.ScrollBarAsNeeded)\n        self.scroll_area.setVerticalScrollBarPolicy(\n            QtCore.Qt.ScrollBarAlwaysOn)\n        self.scroll_area.setHorizontalScrollBarPolicy(\n            QtCore.Qt.ScrollBarAlwaysOff)\n        self.scroll_area.setWidgetResizable(True)\n\n        self.content_widget.append(self.scroll_area)\n\n        scroll_widget = QtWidgets.QWidget(self)\n        in_scroll_area = QtWidgets.QVBoxLayout(scroll_widget)\n        self.content_layout = [in_scroll_area]\n\n        # add preset data into input widget layout\n        self.items = self.populate_widgets(ui_inputs)\n        self.scroll_area.setWidget(scroll_widget)\n\n        # Confirmation buttons\n        btns_widget = QtWidgets.QWidget(self)\n        btns_layout = QtWidgets.QHBoxLayout(btns_widget)\n\n        cancel_btn = QtWidgets.QPushButton(\"Cancel\")\n        btns_layout.addWidget(cancel_btn)\n\n        ok_btn = QtWidgets.QPushButton(\"Ok\")\n        btns_layout.addWidget(ok_btn)\n\n        # Main layout of the dialog\n        main_layout = QtWidgets.QVBoxLayout(self)\n        main_layout.setContentsMargins(10, 10, 10, 10)\n        main_layout.setSpacing(0)\n\n        # adding content widget\n        for w in self.content_widget:\n            main_layout.addWidget(w)\n\n        main_layout.addWidget(btns_widget)\n\n        ok_btn.clicked.connect(self._on_ok_clicked)\n        cancel_btn.clicked.connect(self._on_cancel_clicked)\n\n        stylesheet = load_stylesheet()\n        self.setStyleSheet(stylesheet)\n\n    def _on_ok_clicked(self):\n        self.result = self.value(self.items)\n        self.close()\n\n    def _on_cancel_clicked(self):\n        self.result = None\n        self.close()\n\n    def value(self, data, new_data=None):\n        new_data = new_data or dict()\n        for k, v in data.items():\n            new_data[k] = {\n                \"target\": None,\n                \"value\": None\n            }\n            if v[\"type\"] == \"dict\":\n                new_data[k][\"target\"] = v[\"target\"]\n                new_data[k][\"value\"] = self.value(v[\"value\"])\n            if v[\"type\"] == \"section\":\n                new_data.pop(k)\n                new_data = self.value(v[\"value\"], new_data)\n            elif getattr(v[\"value\"], \"currentText\", None):\n                new_data[k][\"target\"] = v[\"target\"]\n                new_data[k][\"value\"] = v[\"value\"].currentText()\n            elif getattr(v[\"value\"], \"isChecked\", None):\n                new_data[k][\"target\"] = v[\"target\"]\n                new_data[k][\"value\"] = v[\"value\"].isChecked()\n            elif getattr(v[\"value\"], \"value\", None):\n                new_data[k][\"target\"] = v[\"target\"]\n                new_data[k][\"value\"] = v[\"value\"].value()\n            elif getattr(v[\"value\"], \"text\", None):\n                new_data[k][\"target\"] = v[\"target\"]\n                new_data[k][\"value\"] = v[\"value\"].text()\n\n        return new_data\n\n    def camel_case_split(self, text):\n        matches = re.finditer(\n            '.+?(?:(?&lt;=[a-z])(?=[A-Z])|(?&lt;=[A-Z])(?=[A-Z][a-z])|$)', text)\n        return \" \".join([str(m.group(0)).capitalize() for m in matches])\n\n    def create_row(self, layout, type, text, **kwargs):\n        value_keys = [\"setText\", \"setCheckState\", \"setValue\", \"setChecked\"]\n\n        # get type attribute from qwidgets\n        attr = getattr(QtWidgets, type)\n\n        # convert label text to normal capitalized text with spaces\n        label_text = self.camel_case_split(text)\n\n        # assign the new text to label widget\n        label = QtWidgets.QLabel(label_text)\n        label.setObjectName(\"LineLabel\")\n\n        # create attribute name text strip of spaces\n        attr_name = text.replace(\" \", \"\")\n\n        # create attribute and assign default values\n        setattr(\n            self,\n            attr_name,\n            attr(parent=self))\n\n        # assign the created attribute to variable\n        item = getattr(self, attr_name)\n\n        # set attributes to item which are not values\n        for func, val in kwargs.items():\n            if func in value_keys:\n                continue\n\n            if getattr(item, func):\n                log.debug(\"Setting {} to {}\".format(func, val))\n                func_attr = getattr(item, func)\n                if isinstance(val, tuple):\n                    func_attr(*val)\n                else:\n                    func_attr(val)\n\n        # set values to item\n        for value_item in value_keys:\n            if value_item not in kwargs:\n                continue\n            if getattr(item, value_item):\n                getattr(item, value_item)(kwargs[value_item])\n\n        # add to layout\n        layout.addRow(label, item)\n\n        return item\n\n    def populate_widgets(self, data, content_layout=None):\n        \"\"\"\n        Populate widget from input dict.\n\n        Each plugin has its own set of widget rows defined in dictionary\n        each row values should have following keys: `type`, `target`,\n        `label`, `order`, `value` and optionally also `toolTip`.\n\n        Args:\n            data (dict): widget rows or organized groups defined\n                         by types `dict` or `section`\n            content_layout (QtWidgets.QFormLayout)[optional]: used when nesting\n\n        Returns:\n            dict: redefined data dict updated with created widgets\n\n        \"\"\"\n\n        content_layout = content_layout or self.content_layout[-1]\n        # fix order of process by defined order value\n        ordered_keys = list(data.keys())\n        for k, v in data.items():\n            try:\n                # try removing a key from index which should\n                # be filled with new\n                ordered_keys.pop(v[\"order\"])\n            except IndexError:\n                pass\n            # add key into correct order\n            ordered_keys.insert(v[\"order\"], k)\n\n        # process ordered\n        for k in ordered_keys:\n            v = data[k]\n            tool_tip = v.get(\"toolTip\", \"\")\n            if v[\"type\"] == \"dict\":\n                # adding spacer between sections\n                self.content_layout.append(QtWidgets.QWidget(self))\n                content_layout.addWidget(self.content_layout[-1])\n                self.content_layout[-1].setObjectName(\"sectionHeadline\")\n\n                headline = QtWidgets.QVBoxLayout(self.content_layout[-1])\n                headline.addWidget(Spacer(20, self))\n                headline.addWidget(QtWidgets.QLabel(v[\"label\"]))\n\n                # adding nested layout with label\n                self.content_layout.append(QtWidgets.QWidget(self))\n                self.content_layout[-1].setObjectName(\"sectionContent\")\n\n                nested_content_layout = QtWidgets.QFormLayout(\n                    self.content_layout[-1])\n                nested_content_layout.setObjectName(\"NestedContentLayout\")\n                content_layout.addWidget(self.content_layout[-1])\n\n                # add nested key as label\n                data[k][\"value\"] = self.populate_widgets(\n                    v[\"value\"], nested_content_layout)\n\n            if v[\"type\"] == \"section\":\n                # adding spacer between sections\n                self.content_layout.append(QtWidgets.QWidget(self))\n                content_layout.addWidget(self.content_layout[-1])\n                self.content_layout[-1].setObjectName(\"sectionHeadline\")\n\n                headline = QtWidgets.QVBoxLayout(self.content_layout[-1])\n                headline.addWidget(Spacer(20, self))\n                headline.addWidget(QtWidgets.QLabel(v[\"label\"]))\n\n                # adding nested layout with label\n                self.content_layout.append(QtWidgets.QWidget(self))\n                self.content_layout[-1].setObjectName(\"sectionContent\")\n\n                nested_content_layout = QtWidgets.QFormLayout(\n                    self.content_layout[-1])\n                nested_content_layout.setObjectName(\"NestedContentLayout\")\n                content_layout.addWidget(self.content_layout[-1])\n\n                # add nested key as label\n                data[k][\"value\"] = self.populate_widgets(\n                    v[\"value\"], nested_content_layout)\n\n            elif v[\"type\"] == \"QLineEdit\":\n                data[k][\"value\"] = self.create_row(\n                    content_layout, \"QLineEdit\", v[\"label\"],\n                    setText=v[\"value\"], setToolTip=tool_tip)\n            elif v[\"type\"] == \"QComboBox\":\n                data[k][\"value\"] = self.create_row(\n                    content_layout, \"QComboBox\", v[\"label\"],\n                    addItems=v[\"value\"], setToolTip=tool_tip)\n            elif v[\"type\"] == \"QCheckBox\":\n                data[k][\"value\"] = self.create_row(\n                    content_layout, \"QCheckBox\", v[\"label\"],\n                    setChecked=v[\"value\"], setToolTip=tool_tip)\n            elif v[\"type\"] == \"QSpinBox\":\n                data[k][\"value\"] = self.create_row(\n                    content_layout, \"QSpinBox\", v[\"label\"],\n                    setValue=v[\"value\"],\n                    setDisplayIntegerBase=10000,\n                    setRange=(0, 99999), setMinimum=0,\n                    setMaximum=100000, setToolTip=tool_tip)\n\n        return data\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/api/plugin.html#client.ayon_hiero.api.plugin.CreatorWidget.populate_widgets","title":"<code>populate_widgets(data, content_layout=None)</code>","text":"<p>Populate widget from input dict.</p> <p>Each plugin has its own set of widget rows defined in dictionary each row values should have following keys: <code>type</code>, <code>target</code>, <code>label</code>, <code>order</code>, <code>value</code> and optionally also <code>toolTip</code>.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>widget rows or organized groups defined          by types <code>dict</code> or <code>section</code></p> required <code>content_layout</code> <code>QtWidgets.QFormLayout)[optional]</code> <p>used when nesting</p> <code>None</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>redefined data dict updated with created widgets</p> Source code in <code>client/ayon_hiero/api/plugin.py</code> <pre><code>def populate_widgets(self, data, content_layout=None):\n    \"\"\"\n    Populate widget from input dict.\n\n    Each plugin has its own set of widget rows defined in dictionary\n    each row values should have following keys: `type`, `target`,\n    `label`, `order`, `value` and optionally also `toolTip`.\n\n    Args:\n        data (dict): widget rows or organized groups defined\n                     by types `dict` or `section`\n        content_layout (QtWidgets.QFormLayout)[optional]: used when nesting\n\n    Returns:\n        dict: redefined data dict updated with created widgets\n\n    \"\"\"\n\n    content_layout = content_layout or self.content_layout[-1]\n    # fix order of process by defined order value\n    ordered_keys = list(data.keys())\n    for k, v in data.items():\n        try:\n            # try removing a key from index which should\n            # be filled with new\n            ordered_keys.pop(v[\"order\"])\n        except IndexError:\n            pass\n        # add key into correct order\n        ordered_keys.insert(v[\"order\"], k)\n\n    # process ordered\n    for k in ordered_keys:\n        v = data[k]\n        tool_tip = v.get(\"toolTip\", \"\")\n        if v[\"type\"] == \"dict\":\n            # adding spacer between sections\n            self.content_layout.append(QtWidgets.QWidget(self))\n            content_layout.addWidget(self.content_layout[-1])\n            self.content_layout[-1].setObjectName(\"sectionHeadline\")\n\n            headline = QtWidgets.QVBoxLayout(self.content_layout[-1])\n            headline.addWidget(Spacer(20, self))\n            headline.addWidget(QtWidgets.QLabel(v[\"label\"]))\n\n            # adding nested layout with label\n            self.content_layout.append(QtWidgets.QWidget(self))\n            self.content_layout[-1].setObjectName(\"sectionContent\")\n\n            nested_content_layout = QtWidgets.QFormLayout(\n                self.content_layout[-1])\n            nested_content_layout.setObjectName(\"NestedContentLayout\")\n            content_layout.addWidget(self.content_layout[-1])\n\n            # add nested key as label\n            data[k][\"value\"] = self.populate_widgets(\n                v[\"value\"], nested_content_layout)\n\n        if v[\"type\"] == \"section\":\n            # adding spacer between sections\n            self.content_layout.append(QtWidgets.QWidget(self))\n            content_layout.addWidget(self.content_layout[-1])\n            self.content_layout[-1].setObjectName(\"sectionHeadline\")\n\n            headline = QtWidgets.QVBoxLayout(self.content_layout[-1])\n            headline.addWidget(Spacer(20, self))\n            headline.addWidget(QtWidgets.QLabel(v[\"label\"]))\n\n            # adding nested layout with label\n            self.content_layout.append(QtWidgets.QWidget(self))\n            self.content_layout[-1].setObjectName(\"sectionContent\")\n\n            nested_content_layout = QtWidgets.QFormLayout(\n                self.content_layout[-1])\n            nested_content_layout.setObjectName(\"NestedContentLayout\")\n            content_layout.addWidget(self.content_layout[-1])\n\n            # add nested key as label\n            data[k][\"value\"] = self.populate_widgets(\n                v[\"value\"], nested_content_layout)\n\n        elif v[\"type\"] == \"QLineEdit\":\n            data[k][\"value\"] = self.create_row(\n                content_layout, \"QLineEdit\", v[\"label\"],\n                setText=v[\"value\"], setToolTip=tool_tip)\n        elif v[\"type\"] == \"QComboBox\":\n            data[k][\"value\"] = self.create_row(\n                content_layout, \"QComboBox\", v[\"label\"],\n                addItems=v[\"value\"], setToolTip=tool_tip)\n        elif v[\"type\"] == \"QCheckBox\":\n            data[k][\"value\"] = self.create_row(\n                content_layout, \"QCheckBox\", v[\"label\"],\n                setChecked=v[\"value\"], setToolTip=tool_tip)\n        elif v[\"type\"] == \"QSpinBox\":\n            data[k][\"value\"] = self.create_row(\n                content_layout, \"QSpinBox\", v[\"label\"],\n                setValue=v[\"value\"],\n                setDisplayIntegerBase=10000,\n                setRange=(0, 99999), setMinimum=0,\n                setMaximum=100000, setToolTip=tool_tip)\n\n    return data\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/api/plugin.html#client.ayon_hiero.api.plugin.HiddenHieroCreator","title":"<code>HiddenHieroCreator</code>","text":"<p>               Bases: <code>HiddenCreator</code></p> <p>HiddenCreator class wrapper</p> Source code in <code>client/ayon_hiero/api/plugin.py</code> <pre><code>class HiddenHieroCreator(HiddenCreator):\n    \"\"\"HiddenCreator class wrapper\n    \"\"\"\n    settings_category = \"hiero\"\n\n    def collect_instances(self):\n        pass\n\n    def update_instances(self, update_list):\n        pass\n\n    def remove_instances(self, instances):\n        pass\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/api/plugin.html#client.ayon_hiero.api.plugin.HieroCreator","title":"<code>HieroCreator</code>","text":"<p>               Bases: <code>Creator</code></p> <p>Creator class wrapper</p> Source code in <code>client/ayon_hiero/api/plugin.py</code> <pre><code>class HieroCreator(Creator):\n    \"\"\"Creator class wrapper\n    \"\"\"\n    settings_category = \"hiero\"\n\n    def __init__(self, *args, **kwargs):\n        super(Creator, self).__init__(*args, **kwargs)\n        self.presets = get_current_project_settings()[\n            \"hiero\"][\"create\"].get(self.__class__.__name__, {})\n\n    def create(self, product_name, instance_data, pre_create_data):\n        \"\"\"Prepare data for new instance creation.\n\n        Args:\n            product_name(str): Product name of created instance.\n            instance_data(dict): Base data for instance.\n            pre_create_data(dict): Data based on pre creation attributes.\n                Those may affect how creator works.\n        \"\"\"\n        # adding basic current context resolve objects\n        self.project = lib.get_current_project()\n        self.sequence = lib.get_current_sequence()\n\n        if pre_create_data.get(\"use_selection\", False):\n            timeline_selection = lib.get_timeline_selection()\n            self.selected = lib.get_track_items(\n                selection=timeline_selection\n            )\n        else:\n            self.selected = lib.get_track_items()\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/api/plugin.html#client.ayon_hiero.api.plugin.HieroCreator.create","title":"<code>create(product_name, instance_data, pre_create_data)</code>","text":"<p>Prepare data for new instance creation.</p> <p>Parameters:</p> Name Type Description Default <code>product_name(str)</code> <p>Product name of created instance.</p> required <code>instance_data(dict)</code> <p>Base data for instance.</p> required <code>pre_create_data(dict)</code> <p>Data based on pre creation attributes. Those may affect how creator works.</p> required Source code in <code>client/ayon_hiero/api/plugin.py</code> <pre><code>def create(self, product_name, instance_data, pre_create_data):\n    \"\"\"Prepare data for new instance creation.\n\n    Args:\n        product_name(str): Product name of created instance.\n        instance_data(dict): Base data for instance.\n        pre_create_data(dict): Data based on pre creation attributes.\n            Those may affect how creator works.\n    \"\"\"\n    # adding basic current context resolve objects\n    self.project = lib.get_current_project()\n    self.sequence = lib.get_current_sequence()\n\n    if pre_create_data.get(\"use_selection\", False):\n        timeline_selection = lib.get_timeline_selection()\n        self.selected = lib.get_track_items(\n            selection=timeline_selection\n        )\n    else:\n        self.selected = lib.get_track_items()\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/api/plugin.html#client.ayon_hiero.api.plugin.PublishClip","title":"<code>PublishClip</code>","text":"<p>Convert a track item to publishable instance</p> <p>Parameters:</p> Name Type Description Default <code>track_item</code> <code>TrackItem</code> <p>hiero track item object</p> required <code>kwargs</code> <code>optional</code> <p>additional data needed for rename=True (presets)</p> required <p>Returns:</p> Type Description <p>hiero.core.TrackItem: hiero track item object with AYON tag</p> Source code in <code>client/ayon_hiero/api/plugin.py</code> <pre><code>class PublishClip:\n    \"\"\"\n    Convert a track item to publishable instance\n\n    Args:\n        track_item (hiero.core.TrackItem): hiero track item object\n        kwargs (optional): additional data needed for rename=True (presets)\n\n    Returns:\n        hiero.core.TrackItem: hiero track item object with AYON tag\n    \"\"\"\n    tag_data = {}\n\n    types = {\n        \"shot\": \"shot\",\n        \"folder\": \"folder\",\n        \"episode\": \"episode\",\n        \"sequence\": \"sequence\",\n        \"track\": \"sequence\",\n    }\n\n    # parents search pattern\n    parents_search_pattern = r\"\\{([a-z]*?)\\}\"\n\n    # default templates for non-ui use\n    rename_default = False\n    hierarchy_default = \"{_folder_}/{_sequence_}/{_track_}\"\n    clip_name_default = \"shot_{_trackIndex_:0&gt;3}_{_clipIndex_:0&gt;4}\"\n    base_product_variant_default = \"&lt;track_name&gt;\"\n    review_source_default = None\n    product_type_default = \"plate\"\n    count_from_default = 10\n    count_steps_default = 10\n    vertical_sync_default = False\n    driving_layer_default = \"\"\n\n    # Define which keys of the pre create data should also be 'tag data'\n    tag_keys = {\n        # renameHierarchy\n        \"hierarchy\",\n        # hierarchyData\n        \"folder\", \"episode\", \"sequence\", \"track\", \"shot\",\n        # publish settings\n        \"audio\", \"sourceResolution\",\n        # shot attributes\n        \"workfileFrameStart\", \"handleStart\", \"handleEnd\",\n        # instance attributes data\n        \"reviewableSource\",\n    }\n\n    def __init__(\n            self,\n            track_item,\n            vertical_clip_match,\n            vertical_clip_used,\n            pre_create_data=None,\n            data=None,\n            rename_index=0):\n\n        self.vertical_clip_match = vertical_clip_match\n        self.vertical_clip_used = vertical_clip_used\n\n        self.rename_index = rename_index\n\n        # adding ui inputs if any\n        self.pre_create_data = pre_create_data or {}\n\n        # get main parent objects\n        self.track_item = track_item\n        sequence_name = lib.get_current_sequence().name()\n        self.sequence_name = str(sequence_name).replace(\" \", \"_\")\n\n        # track item (clip) main attributes\n        self.ti_name = track_item.name()\n        self.ti_index = int(track_item.eventNumber())\n\n        # get track name and index\n        track_name = track_item.parent().name()\n        self.track_name = str(track_name).replace(\" \", \"_\")\n        self.track_index = int(track_item.parent().trackIndex())\n\n        # adding instance_data[\"productType\"] into tag\n        if data:\n            self.tag_data.update(data)\n\n        # populate default data before we get other attributes\n        self._populate_track_item_default_data()\n\n        # use all populated default data to create all important attributes\n        self._populate_attributes()\n\n        # create parents with correct types\n        self._create_parents()\n\n    def convert(self):\n\n        # solve track item data and add them to tag data\n        self._convert_to_tag_data()\n\n        # if track name is in review track name and also if driving track name\n        # is not in review track name: skip tag creation\n        if (self.track_name in self.reviewable_source) and (\n            self.driving_layer not in self.reviewable_source\n        ):\n            return\n\n        # deal with clip name\n        new_name = self.tag_data.pop(\"newClipName\")\n\n        if self.rename:\n            # rename track item\n            self.track_item.setName(new_name)\n            self.tag_data[\"folderName\"] = new_name\n        else:\n            self.tag_data[\"folderName\"] = self.ti_name\n            self.tag_data[\"hierarchyData\"][\"shot\"] = self.ti_name\n\n        # AYON unique identifier\n        folder_path = \"/{}/{}\".format(\n            self.tag_data[\"hierarchy\"],\n            self.tag_data[\"folderName\"]\n        )\n        self.tag_data[\"folderPath\"] = folder_path\n\n        return self.track_item\n\n    def _populate_track_item_default_data(self):\n        \"\"\" Populate default formatting data from track item. \"\"\"\n\n        self.track_item_default_data = {\n            \"_folder_\": \"shots\",\n            \"_sequence_\": self.sequence_name,\n            \"_track_\": self.track_name,\n            \"_clip_\": self.ti_name,\n            \"_trackIndex_\": self.track_index,\n            \"_clipIndex_\": self.ti_index\n        }\n\n    def _populate_attributes(self):\n        \"\"\" Populate main object attributes. \"\"\"\n        # track item frame range and parent track name for vertical sync check\n        self.clip_in = int(self.track_item.timelineIn())\n        self.clip_out = int(self.track_item.timelineOut())\n\n        # define ui inputs if non gui mode was used\n        self.shot_num = self.ti_index\n        log.debug(\n            \"____ self.shot_num: {}\".format(self.shot_num))\n\n        # publisher ui attribute inputs or default values if gui was not used\n        def get(key):\n            \"\"\"Shorthand access for code readability\"\"\"\n            return self.pre_create_data.get(key)\n\n        # ui_inputs data or default values if gui was not used\n        self.rename = self.pre_create_data.get(\n            \"clipRename\", self.rename_default)\n        self.clip_name = get(\"clipName\") or self.clip_name_default\n        self.hierarchy = get(\"hierarchy\") or self.hierarchy_default\n        self.count_from = get(\"countFrom\") or self.count_from_default\n        self.count_steps = get(\"countSteps\") or self.count_steps_default\n        self.base_product_variant = (\n            get(\"clipVariant\") or self.base_product_variant_default)\n        self.product_type = get(\"productType\") or self.product_type_default\n        self.vertical_sync = get(\"vSyncOn\") or self.vertical_sync_default\n        self.driving_layer = get(\"vSyncTrack\") or self.driving_layer_default\n        self.driving_layer = self.driving_layer.replace(\" \", \"_\")\n        self.review_source = (\n            get(\"reviewableSource\") or self.review_source_default)\n        self.audio = get(\"audio\") or False\n\n        self.hierarchy_data = {\n            key: get(key) or self.track_item_default_data[key]\n            for key in [\"folder\", \"episode\", \"sequence\", \"track\", \"shot\"]\n        }\n\n        # build product name from layer name\n        if self.base_product_variant == \"&lt;track_name&gt;\":\n            self.variant = self.track_name\n        else:\n            self.variant = self.base_product_variant\n\n        # create product for publishing\n        self.product_name = f\"{self.product_type}{self.variant.capitalize()}\"\n\n    def _replace_hash_to_expression(self, name, text):\n        \"\"\" Replace hash with number in correct padding. \"\"\"\n        _spl = text.split(\"#\")\n        _len = (len(_spl) - 1)\n        _repl = \"{{{0}:0&gt;{1}}}\".format(name, _len)\n        return text.replace((\"#\" * _len), _repl)\n\n    def _convert_to_tag_data(self):\n        \"\"\" Convert internal data to tag data.\n\n        Populating the tag data into internal variable self.tag_data\n        \"\"\"\n        # define vertical sync attributes\n        hero_track = True\n        self.reviewable_source = \"\"\n        if (\n            self.vertical_sync\n            and self.track_name != self.driving_layer\n        ):\n            # check if track name is not in driving layer\n            # if it is not then define vertical sync as None\n            hero_track = False\n\n        # increasing steps by index of rename iteration\n        self.count_steps *= self.rename_index\n\n        hierarchy_formatting_data = {}\n        hierarchy_data = deepcopy(self.hierarchy_data)\n        _data = self.track_item_default_data.copy()\n\n        # in case we are running creators headless default\n        # precreate data values are used\n        if self.pre_create_data:\n\n            # adding tag metadata from ui\n            for _key, _value in self.pre_create_data.items():\n                # backward compatibility for reviewableSource (2024.11.08)\n                if (\n                    _key == \"reviewableSource\"\n                    and \"reviewTrack\" in self.tag_keys\n                ):\n                    self.tag_data.pop(\"reviewTrack\")\n                    self.tag_data[\"reviewableSource\"] = _value\n                if _key in self.tag_keys:\n                    self.tag_data[_key] = _value\n\n            # driving layer is set as positive match\n            if hero_track or self.vertical_sync:\n                # mark review layer\n                if self.review_source and (\n                        self.review_source != self.review_source_default):\n                    # if review layer is defined and not the same as default\n                    self.reviewable_source = self.review_source\n                # shot num calculate\n                if self.rename_index == 0:\n                    self.shot_num = self.count_from\n                else:\n                    self.shot_num = self.count_from + self.count_steps\n\n            # clip name sequence number\n            _data.update({\"shot\": self.shot_num})\n\n            # solve # in test to pythonic expression\n            for _key, _value in hierarchy_data.items():\n                if \"#\" not in _value:\n                    continue\n                hierarchy_data[_key] = self._replace_hash_to_expression(\n                    _key, _value)\n\n            # fill up pythonic expresisons in hierarchy data\n            for _key, _value in hierarchy_data.items():\n                formatted_value = _value.format(**_data)\n                hierarchy_formatting_data[_key] = formatted_value\n                self.tag_data[_key] = formatted_value\n        else:\n            # if no gui mode then just pass default data\n            hierarchy_formatting_data = hierarchy_data\n\n        tag_instance_data = self._solve_tag_instance_data(\n            hierarchy_formatting_data\n        )\n\n        tag_instance_data.update({\"heroTrack\": True})\n        if hero_track and self.vertical_sync:\n            self.vertical_clip_match.update(\n                {(self.clip_in, self.clip_out): tag_instance_data}\n            )\n\n        if not hero_track and self.vertical_sync:\n            # driving layer is set as negative match\n            for (hero_in, hero_out), hero_data in self.vertical_clip_match.items():  # noqa\n                \"\"\"Iterate over all clips in vertical sync match\n\n                If clip frame range is outside of hero clip frame range\n                then skip this clip and do not add to hierarchical shared\n                metadata to them.\n                \"\"\"\n                if self.clip_in &lt; hero_in or self.clip_out &gt; hero_out:\n                    continue\n\n                _distrib_data = deepcopy(hero_data)\n                _distrib_data[\"heroTrack\"] = False\n\n                # form used clip unique key\n                data_product_name = hero_data[\"productName\"]\n                new_clip_name = hero_data[\"newClipName\"]\n\n                # get used names list for duplicity check\n                used_names_list = self.vertical_clip_used.setdefault(\n                    f\"{new_clip_name}{data_product_name}\", [])\n\n                clip_product_name = self.product_name\n                variant = self.variant\n\n                # in case track name and product name is the same then add\n                if self.variant == self.track_name:\n                    clip_product_name = self.product_name\n\n                # add track index in case duplicity of names in hero data\n                # INFO: this is for case where hero clip product name\n                #    is the same as current clip product name\n                if clip_product_name in data_product_name:\n                    clip_product_name = (\n                        f\"{clip_product_name}{self.track_index}\")\n                    variant = f\"{variant}{self.track_index}\"\n\n                # in case track clip product name had been already used\n                # then add product name with clip index\n                if clip_product_name in used_names_list:\n                    clip_product_name = (\n                        f\"{clip_product_name}{self.rename_index}\")\n                    variant = f\"{variant}{self.rename_index}\"\n\n                _distrib_data[\"productName\"] = clip_product_name\n                _distrib_data[\"variant\"] = variant\n                # assign data to return hierarchy data to tag\n                tag_instance_data = _distrib_data\n\n                # add used product name to used list to avoid duplicity\n                used_names_list.append(clip_product_name)\n                break\n\n        # add data to return data dict\n        self.tag_data.update(tag_instance_data)\n\n        # add uuid to tag data\n        self.tag_data[\"uuid\"] = str(uuid.uuid4())\n\n        # add review track only to hero track\n        if hero_track and self.reviewable_source:\n            self.tag_data[\"reviewTrack\"] = self.reviewable_source\n        else:\n            self.tag_data.update({\"reviewTrack\": None})\n\n        # add only review related data if reviewable source is set\n        if self.reviewable_source:\n            review_switch = True\n            reviewable_source = self.reviewable_source\n            #\n            if self.vertical_sync and not hero_track:\n                review_switch = False\n                reviewable_source = False\n\n            if review_switch:\n                self.tag_data[\"review\"] = True\n            else:\n                self.tag_data.pop(\"review\", None)\n\n            if reviewable_source:\n                self.tag_data[\"reviewableSource\"] = reviewable_source\n            else:\n                self.tag_data.pop(\"reviewableSource\", None)\n\n    def _solve_tag_instance_data(self, hierarchy_formatting_data):\n        \"\"\" Solve tag data from hierarchy data and templates. \"\"\"\n        # fill up clip name and hierarchy keys\n        hierarchy_filled = self.hierarchy.format(**hierarchy_formatting_data)\n        clip_name_filled = self.clip_name.format(**hierarchy_formatting_data)\n\n        # remove shot from hierarchy data: is not needed anymore\n        hierarchy_formatting_data.pop(\"shot\")\n\n        return {\n            \"newClipName\": clip_name_filled,\n            \"hierarchy\": hierarchy_filled,\n            \"parents\": self.parents,\n            \"hierarchyData\": hierarchy_formatting_data,\n            \"productName\": self.product_name,\n            \"productType\": self.product_type,\n            \"variant\": self.variant,\n        }\n\n    def _convert_to_entity(self, src_type, template):\n        \"\"\" Converting input key to key with type. \"\"\"\n        # convert to entity type\n        folder_type = self.types.get(src_type, None)\n\n        assert folder_type, \"Missing folder type for `{}`\".format(\n            src_type\n        )\n        formatting_data = {}\n        for _k, _v in self.hierarchy_data.items():\n            value = _v.format(\n                **self.track_item_default_data)\n            formatting_data[_k] = value\n\n        return {\n            \"entity_type\": folder_type,\n            \"folder_type\": folder_type,\n            \"entity_name\": template.format(**formatting_data)\n        }\n\n    def _create_parents(self):\n        \"\"\" Create parents and return it in list. \"\"\"\n        self.parents = []\n\n        pattern = re.compile(self.parents_search_pattern)\n\n        par_split = [(pattern.findall(t).pop(), t)\n                     for t in self.hierarchy.split(\"/\")]\n\n        for type_, template in par_split:\n            parent = self._convert_to_entity(type_, template)\n            self.parents.append(parent)\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/api/plugin.html#client.ayon_hiero.api.plugin.SequenceLoader","title":"<code>SequenceLoader</code>","text":"<p>               Bases: <code>LoaderPlugin</code></p> <p>A basic SequenceLoader for Resolve</p> <p>This will implement the basic behavior for a loader to inherit from that will containerize the reference and will implement the <code>remove</code> and <code>update</code> logic.</p> Source code in <code>client/ayon_hiero/api/plugin.py</code> <pre><code>class SequenceLoader(LoaderPlugin):\n    \"\"\"A basic SequenceLoader for Resolve\n\n    This will implement the basic behavior for a loader to inherit from that\n    will containerize the reference and will implement the `remove` and\n    `update` logic.\n\n    \"\"\"\n\n    options = [\n        qargparse.Boolean(\n            \"handles\",\n            label=\"Include handles\",\n            default=0,\n            help=\"Load with handles or without?\"\n        ),\n        qargparse.Choice(\n            \"load_to\",\n            label=\"Where to load clips\",\n            items=[\n                \"Current timeline\",\n                \"New timeline\"\n            ],\n            default=\"Current timeline\",\n            help=\"Where do you want clips to be loaded?\"\n        ),\n        qargparse.Choice(\n            \"load_how\",\n            label=\"How to load clips\",\n            items=[\n                \"Original timing\",\n                \"Sequentially in order\"\n            ],\n            default=\"Original timing\",\n            help=\"Would you like to place it at original timing?\"\n        )\n    ]\n\n    def load(\n        self,\n        context,\n        name=None,\n        namespace=None,\n        options=None\n    ):\n        pass\n\n    def update(self, container, context):\n        \"\"\"Update an existing `container`\n        \"\"\"\n        pass\n\n    def remove(self, container):\n        \"\"\"Remove an existing `container`\n        \"\"\"\n        pass\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/api/plugin.html#client.ayon_hiero.api.plugin.SequenceLoader.remove","title":"<code>remove(container)</code>","text":"<p>Remove an existing <code>container</code></p> Source code in <code>client/ayon_hiero/api/plugin.py</code> <pre><code>def remove(self, container):\n    \"\"\"Remove an existing `container`\n    \"\"\"\n    pass\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/api/plugin.html#client.ayon_hiero.api.plugin.SequenceLoader.update","title":"<code>update(container, context)</code>","text":"<p>Update an existing <code>container</code></p> Source code in <code>client/ayon_hiero/api/plugin.py</code> <pre><code>def update(self, container, context):\n    \"\"\"Update an existing `container`\n    \"\"\"\n    pass\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/api/tags.html","title":"tags","text":""},{"location":"autoapi/client/ayon_hiero/api/tags.html#client.ayon_hiero.api.tags.add_tags_to_workfile","title":"<code>add_tags_to_workfile()</code>","text":"<p>Will create default tags from presets.</p> Source code in <code>client/ayon_hiero/api/tags.py</code> <pre><code>def add_tags_to_workfile():\n    \"\"\"\n    Will create default tags from presets.\n    \"\"\"\n    from .lib import get_current_project\n\n    def add_tag_to_bin(root_bin, name, data):\n        # for Tags to be created in root level Bin\n        # at first check if any of input data tag is not already created\n        done_tag = next((t for t in root_bin.items()\n                        if str(name) in t.name()), None)\n\n        if not done_tag:\n            # create Tag\n            tag = create_tag(name, data)\n            tag.setName(str(name))\n\n            log.debug(\"__ creating tag: {}\".format(tag))\n            # adding Tag to Root Bin\n            root_bin.addItem(tag)\n        else:\n            # update only non hierarchy tags\n            update_tag(done_tag, data)\n            done_tag.setName(str(name))\n            log.debug(\"__ updating tag: {}\".format(done_tag))\n\n    # get project and root bin object\n    project = get_current_project()\n    root_bin = project.tagsBin()\n\n    if \"Tag Presets\" in project.name():\n        return\n\n    log.debug(\"Setting default tags on project: {}\".format(project.name()))\n\n    # get hiero tags.json\n    nks_pres_tags = tag_data()\n\n    # Get project task types.\n    project_name = get_current_project_name()\n    project_entity = ayon_api.get_project(project_name)\n    task_types = project_entity[\"taskTypes\"]\n    nks_pres_tags[\"[Tasks]\"] = {}\n    log.debug(\"__ tasks: {}\".format(task_types))\n    for task_type in task_types:\n        task_type_name = task_type[\"name\"]\n        nks_pres_tags[\"[Tasks]\"][task_type_name.lower()] = {\n            \"editable\": \"1\",\n            \"note\": task_type_name,\n            \"icon\": \"icons:TagGood.png\",\n            \"metadata\": {\n                \"productType\": \"task\",\n                \"type\": task_type_name\n            }\n        }\n\n    # loop through tag data dict and create deep tag structure\n    for _k, _val in nks_pres_tags.items():\n        # check if key is not decorated with [] so it is defined as bin\n        bin_find = None\n        pattern = re.compile(r\"\\[(.*)\\]\")\n        _bin_finds = pattern.findall(_k)\n        # if there is available any then pop it to string\n        if _bin_finds:\n            bin_find = _bin_finds.pop()\n\n        # if bin was found then create or update\n        if bin_find:\n            root_add = False\n            # first check if in root lever is not already created bins\n            bins = [b for b in root_bin.items()\n                    if b.name() in str(bin_find)]\n\n            if bins:\n                bin = bins.pop()\n            else:\n                root_add = True\n                # create Bin object for processing\n                bin = hiero.core.Bin(str(bin_find))\n\n            # update or create tags in the bin\n            for __k, __v in _val.items():\n                add_tag_to_bin(bin, __k, __v)\n\n            # finally add the Bin object to the root level Bin\n            if root_add:\n                # adding Tag to Root Bin\n                root_bin.addItem(bin)\n        else:\n            add_tag_to_bin(root_bin, _k, _val)\n\n    log.info(\"Default Tags were set...\")\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/api/tags.html#client.ayon_hiero.api.tags.create_tag","title":"<code>create_tag(key, data)</code>","text":"<p>Creating Tag object.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>name of tag</p> required <code>data</code> <code>dict</code> <p>parameters of tag</p> required <p>Returns:</p> Name Type Description <code>object</code> <p>Tag object</p> Source code in <code>client/ayon_hiero/api/tags.py</code> <pre><code>def create_tag(key, data):\n    \"\"\"\n    Creating Tag object.\n\n    Args:\n        key (str): name of tag\n        data (dict): parameters of tag\n\n    Returns:\n        object: Tag object\n    \"\"\"\n    tag = hiero.core.Tag(str(key))\n    return update_tag(tag, data)\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/api/tags.html#client.ayon_hiero.api.tags.get_or_create_workfile_tag","title":"<code>get_or_create_workfile_tag(create=False)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>create</code> <code>bool</code> <p>Create the project tag if missing.</p> <code>False</code> <p>Returns:</p> Type Description <p>hiero.core.Tag: The workfile tag or None</p> Source code in <code>client/ayon_hiero/api/tags.py</code> <pre><code>def get_or_create_workfile_tag(create=False):\n    \"\"\"\n    Args:\n        create (bool): Create the project tag if missing.\n\n    Returns:\n        hiero.core.Tag: The workfile tag or None\n    \"\"\"\n    from .lib import get_current_project  # noqa prevent-circular-import\n    current_project = get_current_project()\n\n    # retrieve parent tag bin\n    project_tag_bin = current_project.tagsBin()\n    for tag_bin in project_tag_bin.bins():\n        if tag_bin.name() == constants.AYON_WORKFILE_TAG_BIN:\n            break\n    else:\n        if create:\n            tag_bin = project_tag_bin.addItem(constants.AYON_WORKFILE_TAG_BIN)\n        else:\n            return None\n\n    # retrieve tag\n    for item in tag_bin.items():\n        if (isinstance(item, hiero.core.Tag)\n            and item.name() == constants.AYON_WORKFILE_TAG_NAME):\n            return item\n\n    workfile_tag = hiero.core.Tag(constants.AYON_WORKFILE_TAG_NAME)\n    tag_bin.addItem(workfile_tag)\n    return workfile_tag\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/api/tags.html#client.ayon_hiero.api.tags.get_tag_data","title":"<code>get_tag_data(tag)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>tag</code> <code>Tag</code> <p>The tag to retrieve data from.</p> required <p>Returns:</p> Type Description <p>dict. The tag data.</p> Source code in <code>client/ayon_hiero/api/tags.py</code> <pre><code>def get_tag_data(tag):\n    \"\"\"\n    Args:\n        tag (hiero.core.Tag): The tag to retrieve data from.\n\n    Returns:\n        dict. The tag data.\n    \"\"\"\n    tag_data = dict(tag.metadata())\n\n    try:\n        json_data = tag_data[\"tag.json_metadata\"]\n        return json.loads(json_data)\n\n    except (KeyError, json.JSONDecodeError):\n        return {}\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/api/tags.html#client.ayon_hiero.api.tags.update_tag","title":"<code>update_tag(tag, data)</code>","text":"<p>Fixing Tag object.</p> <p>Parameters:</p> Name Type Description Default <code>tag</code> <code>obj</code> <p>Tag object</p> required <code>data</code> <code>dict</code> <p>parameters of tag</p> required Source code in <code>client/ayon_hiero/api/tags.py</code> <pre><code>def update_tag(tag, data):\n    \"\"\"\n    Fixing Tag object.\n\n    Args:\n        tag (obj): Tag object\n        data (dict): parameters of tag\n    \"\"\"\n    # set icon if any available in input data\n    if data.get(\"icon\"):\n        tag.setIcon(str(data[\"icon\"]))\n\n    # get metadata of tag\n    mtd = tag.metadata()\n    # get metadata key from data\n    data_mtd = data.get(\"metadata\", {})\n\n    mtd.setValue(\n        \"tag.json_metadata\",\n        json.dumps(data_mtd)\n    )\n    # set note description of tag\n    if \"note\" in data:\n        tag.setNote(str(data[\"note\"]))\n\n    return tag\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/api/workio.html","title":"workio","text":""},{"location":"autoapi/client/ayon_hiero/api/workio.html#client.ayon_hiero.api.workio.open_file","title":"<code>open_file(filepath)</code>","text":"<p>Manually fire the kBeforeProjectLoad event in order to work around a bug in Hiero. The Foundry has logged this bug as:   Bug 40413 - Python API - kBeforeProjectLoad event type is not triggered   when calling hiero.core.openProject() (only triggered through UI) It exists in all versions of Hiero through (at least) v1.9v1b12.</p> <p>Once this bug is fixed, a version check will need to be added here in order to prevent accidentally firing this event twice. The following commented-out code is just an example, and will need to be updated when the bug is fixed to catch the correct versions.</p> Source code in <code>client/ayon_hiero/api/workio.py</code> <pre><code>def open_file(filepath):\n    \"\"\"Manually fire the kBeforeProjectLoad event in order to work around a bug in Hiero.\n    The Foundry has logged this bug as:\n      Bug 40413 - Python API - kBeforeProjectLoad event type is not triggered\n      when calling hiero.core.openProject() (only triggered through UI)\n    It exists in all versions of Hiero through (at least) v1.9v1b12.\n\n    Once this bug is fixed, a version check will need to be added here in order to\n    prevent accidentally firing this event twice. The following commented-out code\n    is just an example, and will need to be updated when the bug is fixed to catch the\n    correct versions.\"\"\"\n    # if (hiero.core.env['VersionMajor'] &lt; 1 or\n    #     hiero.core.env['VersionMajor'] == 1 and hiero.core.env['VersionMinor'] &lt; 10:\n    hiero.core.events.sendEvent(\"kBeforeProjectLoad\", None)\n\n    project = hiero.core.projects()[-1]\n\n    # Close previous project if its different to the current project.\n    filepath = filepath.replace(os.path.sep, \"/\")\n    if project.path().replace(os.path.sep, \"/\") != filepath:\n        # open project file\n        hiero.core.openProject(filepath)\n        project.close()\n\n    return True\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/api/otio/index.html","title":"otio","text":""},{"location":"autoapi/client/ayon_hiero/api/otio/hiero_export.html","title":"hiero_export","text":"<p>compatibility OpenTimelineIO 0.12.0 and newer</p>"},{"location":"autoapi/client/ayon_hiero/api/otio/hiero_import.html","title":"hiero_import","text":""},{"location":"autoapi/client/ayon_hiero/api/otio/utils.html","title":"utils","text":""},{"location":"autoapi/client/ayon_hiero/api/otio/utils.html#client.ayon_hiero.api.otio.utils.get_marker_from_clip_index","title":"<code>get_marker_from_clip_index(otio_timeline, clip_index)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>otio_timeline</code> <code>Timeline</code> <p>The otio timeline to inspect</p> required <code>clip_index</code> <code>int</code> <p>The clip index metadata to retrieve.</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>(Clip, Marker)</code> <p>The associated clip and marker or (None, None)</p> Source code in <code>client/ayon_hiero/api/otio/utils.py</code> <pre><code>def get_marker_from_clip_index(otio_timeline, clip_index):\n    \"\"\"\n    Args:\n        otio_timeline (otio.Timeline): The otio timeline to inspect\n        clip_index (int): The clip index metadata to retrieve.\n\n    Returns:\n        tuple(otio.Clip, otio.Marker): The associated clip and marker\n            or (None, None)\n    \"\"\"\n    try:  # opentimelineio &gt;= 0.16.0\n        all_clips = otio_timeline.find_clips()\n    except AttributeError:  # legacy\n        all_clips = otio_timeline.each_clip()\n\n    # Retrieve otioClip from parent context otioTimeline\n    # See collect_current_project\n    for otio_clip in all_clips:\n        for marker in otio_clip.markers:\n\n            try:\n                json_metadata = marker.metadata[\"json_metadata\"]\n            except KeyError:\n                continue\n\n            else:\n                metadata = json.loads(json_metadata)\n                if metadata.get(\"clip_index\") == clip_index:\n                    return otio_clip, marker\n\n    return None, None\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/api/otio/utils.html#client.ayon_hiero.api.otio.utils.get_padding_from_path","title":"<code>get_padding_from_path(path)</code>","text":"<p>Return padding number from DaVinci Resolve sequence path style</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>path url or simple file name</p> required <p>Returns:</p> Name Type Description <code>int</code> <p>padding number</p> Example <p>get_padding_from_path(\"plate.[0001-1008].exr\") &gt; 4</p> Source code in <code>client/ayon_hiero/api/otio/utils.py</code> <pre><code>def get_padding_from_path(path):\n    \"\"\"\n    Return padding number from DaVinci Resolve sequence path style\n\n    Args:\n        path (str): path url or simple file name\n\n    Returns:\n        int: padding number\n\n    Example:\n        get_padding_from_path(\"plate.[0001-1008].exr\") &gt; 4\n\n    \"\"\"\n    padding_pattern = \"(\\\\d+)(?=-)\"\n    if \"[\" in path:\n        return len(re.findall(padding_pattern, path).pop())\n\n    return None\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/api/otio/utils.html#client.ayon_hiero.api.otio.utils.get_reformated_path","title":"<code>get_reformated_path(path, padded=True)</code>","text":"<p>Return fixed python expression path</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>path url or simple file name</p> required <p>Returns:</p> Name Type Description <code>type</code> <p>string with reformatted path</p> Example <p>get_reformated_path(\"plate.[0001-1008].exr\") &gt; plate.%04d.exr</p> Source code in <code>client/ayon_hiero/api/otio/utils.py</code> <pre><code>def get_reformated_path(path, padded=True):\n    \"\"\"\n    Return fixed python expression path\n\n    Args:\n        path (str): path url or simple file name\n\n    Returns:\n        type: string with reformatted path\n\n    Example:\n        get_reformated_path(\"plate.[0001-1008].exr\") &gt; plate.%04d.exr\n\n    \"\"\"\n    if \"%\" in path:\n        padding_pattern = r\"(\\d+)\"\n        padding = int(re.findall(padding_pattern, path).pop())\n        num_pattern = r\"(%\\d+d)\"\n        if padded:\n            path = re.sub(num_pattern, \"%0{}d\".format(padding), path)\n        else:\n            path = re.sub(num_pattern, \"%d\", path)\n    return path\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/api/startup/index.html","title":"startup","text":""},{"location":"autoapi/client/ayon_hiero/api/startup/Python/index.html","title":"Python","text":""},{"location":"autoapi/client/ayon_hiero/api/startup/Python/Startup/index.html","title":"Startup","text":""},{"location":"autoapi/client/ayon_hiero/api/startup/Python/Startup/SpreadsheetExport.html","title":"SpreadsheetExport","text":""},{"location":"autoapi/client/ayon_hiero/api/startup/Python/Startup/SpreadsheetExport.html#client.ayon_hiero.api.startup.Python.Startup.SpreadsheetExport.activeSpreadsheetTreeView","title":"<code>activeSpreadsheetTreeView()</code>","text":"<p>Does some PySide widget Magic to detect the Active Spreadsheet TreeView.</p> Source code in <code>client/ayon_hiero/api/startup/Python/Startup/SpreadsheetExport.py</code> <pre><code>def activeSpreadsheetTreeView():\n    \"\"\"\n  Does some PySide widget Magic to detect the Active Spreadsheet TreeView.\n  \"\"\"\n    spreadsheetViews = getFoundryWidgetsWithClassName(\n        filter=\"SpreadsheetTreeView\")\n    for spreadSheet in spreadsheetViews:\n        if spreadSheet.hasFocus():\n            activeSpreadSheet = spreadSheet\n            return activeSpreadSheet\n    return None\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/api/startup/Python/Startup/Startup.html","title":"Startup","text":""},{"location":"autoapi/client/ayon_hiero/api/startup/Python/Startup/project_helpers.html","title":"project_helpers","text":""},{"location":"autoapi/client/ayon_hiero/api/startup/Python/Startup/project_helpers.html#client.ayon_hiero.api.startup.Python.Startup.project_helpers.activeProject","title":"<code>activeProject()</code>","text":"<p>hiero.ui.activeProject() -&gt; returns the current Project</p> <p>Note: There is not technically a notion of a \"active\" Project in Hiero/NukeStudio, as it is a multi-project App. This method determines what is \"active\" by going down the following rules...</p>"},{"location":"autoapi/client/ayon_hiero/api/startup/Python/Startup/project_helpers.html#client.ayon_hiero.api.startup.Python.Startup.project_helpers.activeProject--1-if-the-current-viewer-hierouicurrentviewer-contains-a-clip-or-sequence-this-item-is-assumed-to-give-the-active-project","title":"1 - If the current Viewer (hiero.ui.currentViewer) contains a Clip or Sequence, this item is assumed to give the active Project","text":""},{"location":"autoapi/client/ayon_hiero/api/startup/Python/Startup/project_helpers.html#client.ayon_hiero.api.startup.Python.Startup.project_helpers.activeProject--2-if-nothing-is-currently-in-the-viewer-look-to-the-active-view-determine-project-from-active-selection","title":"2 - If nothing is currently in the Viewer, look to the active View, determine project from active selection","text":""},{"location":"autoapi/client/ayon_hiero/api/startup/Python/Startup/project_helpers.html#client.ayon_hiero.api.startup.Python.Startup.project_helpers.activeProject--3-if-no-current-selection-can-be-determined-fall-back-to-a-globally-tracked-last-selection-from-trackactiveprojecthandler","title":"3 - If no current selection can be determined, fall back to a globally tracked last selection from trackActiveProjectHandler","text":""},{"location":"autoapi/client/ayon_hiero/api/startup/Python/Startup/project_helpers.html#client.ayon_hiero.api.startup.Python.Startup.project_helpers.activeProject--4-if-all-those-rules-fail-fall-back-to-the-last-project-in-the-list-of-hierocoreprojects","title":"4 - If all those rules fail, fall back to the last project in the list of hiero.core.projects()","text":"<p>@return: hiero.core.Project</p> Source code in <code>client/ayon_hiero/api/startup/Python/Startup/project_helpers.py</code> <pre><code>def activeProject():\n    \"\"\"hiero.ui.activeProject() -&gt; returns the current Project\n\n    Note: There is not technically a notion of a \"active\" Project in Hiero/NukeStudio, as it is a multi-project App.\n    This method determines what is \"active\" by going down the following rules...\n\n    # 1 - If the current Viewer (hiero.ui.currentViewer) contains a Clip or Sequence, this item is assumed to give the active Project\n    # 2 - If nothing is currently in the Viewer, look to the active View, determine project from active selection\n    # 3 - If no current selection can be determined, fall back to a globally tracked last selection from trackActiveProjectHandler\n    # 4 - If all those rules fail, fall back to the last project in the list of hiero.core.projects()\n\n    @return: hiero.core.Project\"\"\"\n    global gTrackedActiveProject\n    activeProject = None\n\n    # Case 1 : Look for what the current Viewr tells us - this might not be what we want, and relies on hiero.ui.currentViewer() being robust.\n    cv = hiero.ui.currentViewer().player().sequence()\n    if hasattr(cv, \"project\"):\n        activeProject = cv.project()\n    else:\n        # Case 2: We can't determine a project from the current Viewer, so try seeing what's selected in the activeView\n        # Note that currently, if you run activeProject from the Script Editor, the activeView is always None, so this will rarely get used!\n        activeView = hiero.ui.activeView()\n        if activeView:\n            # We can determine an active View.. see what's being worked with\n            selection = activeView.selection()\n\n            # Handle the case where nothing is selected in the active view\n            if len(selection) == 0:\n                # It's possible that there is no selection in a Timeline/Spreadsheet, but these views have \"sequence\" method, so try that...\n                if isinstance(hiero.ui.activeView(), (hiero.ui.TimelineEditor, hiero.ui.SpreadsheetView)):\n                    activeSequence = activeView.sequence()\n                    if hasattr(currentItem, \"project\"):\n                        activeProject = activeSequence.project()\n\n            # The active view has a selection... assume that the first item in the selection has the active Project\n            else:\n                currentItem = selection[0]\n                if hasattr(currentItem, \"project\"):\n                    activeProject = currentItem.project()\n\n    # Finally, Cases 3 and 4...\n    if not activeProject:\n        activeProjects = hiero.core.projects(hiero.core.Project.kUserProjects)\n        if gTrackedActiveProject in activeProjects:\n            activeProject = gTrackedActiveProject\n        else:\n            activeProject = activeProjects[-1]\n\n    return activeProject\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/api/startup/Python/Startup/project_helpers.html#client.ayon_hiero.api.startup.Python.Startup.project_helpers.openRecentProject","title":"<code>openRecentProject(k=0)</code>","text":"<p>hiero.core.openRecentProject(k) -&gt; Opens the most the recent project as listed in the Open Recent list.</p> <p>@param: k (optional, default = 0) - an integer from 0-4, relating to the index of recent projects. @return: hiero.core.Project</p> Source code in <code>client/ayon_hiero/api/startup/Python/Startup/project_helpers.py</code> <pre><code>def openRecentProject(k=0):\n    \"\"\"hiero.core.openRecentProject(k) -&gt; Opens the most the recent project as listed in the Open Recent list.\n\n    @param: k (optional, default = 0) - an integer from 0-4, relating to the index of recent projects.\n    @return: hiero.core.Project\"\"\"\n\n    appSettings = hiero.core.ApplicationSettings()\n    proj = appSettings.value('recentFile/%i' % int(k), None)\n    proj = hiero.core.openProject(proj)\n    return proj\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/api/startup/Python/Startup/project_helpers.html#client.ayon_hiero.api.startup.Python.Startup.project_helpers.recentProject","title":"<code>recentProject(k=0)</code>","text":"<p>hiero.core.recentProject(k) -&gt; Returns the recent project path, specified by integer k (0-4)</p> <p>@param: k (optional, default = 0) - an integer from 0-4, relating to the index of recent projects.</p> <p>@return: hiero.core.Project</p> Source code in <code>client/ayon_hiero/api/startup/Python/Startup/project_helpers.py</code> <pre><code>def recentProject(k=0):\n    \"\"\"hiero.core.recentProject(k) -&gt; Returns the recent project path, specified by integer k (0-4)\n\n    @param: k (optional, default = 0) - an integer from 0-4, relating to the index of recent projects.\n\n    @return: hiero.core.Project\"\"\"\n\n    appSettings = hiero.core.ApplicationSettings()\n    proj = appSettings.value('recentFile/%i' % int(k), None)\n    return proj\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/api/startup/Python/Startup/project_helpers.html#client.ayon_hiero.api.startup.Python.Startup.project_helpers.recentProjects","title":"<code>recentProjects()</code>","text":"<p>hiero.core.recentProjects() -&gt; Returns a list of paths to recently opened projects</p> <p>Hiero stores up to 5 recent projects in uistate.ini with the [recentFile]/# key.</p> <p>@return: list of paths to .hrox Projects</p> Source code in <code>client/ayon_hiero/api/startup/Python/Startup/project_helpers.py</code> <pre><code>def recentProjects():\n    \"\"\"hiero.core.recentProjects() -&gt; Returns a list of paths to recently opened projects\n\n    Hiero stores up to 5 recent projects in uistate.ini with the [recentFile]/# key.\n\n    @return: list of paths to .hrox Projects\"\"\"\n\n    appSettings = hiero.core.ApplicationSettings()\n    recentProjects = []\n    for i in range(0, 5):\n        proj = appSettings.value('recentFile/%i' % i)\n        if len(proj) &gt; 0:\n            recentProjects.append(proj)\n    return recentProjects\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/api/startup/Python/Startup/selection_tracker.html","title":"selection_tracker","text":"<p>Puts the selection project into \"hiero.selection</p>"},{"location":"autoapi/client/ayon_hiero/api/startup/Python/Startup/setFrameRate.html","title":"setFrameRate","text":""},{"location":"autoapi/client/ayon_hiero/api/startup/Python/Startup/otioexporter/index.html","title":"otioexporter","text":""},{"location":"autoapi/client/ayon_hiero/api/startup/Python/Startup/otioexporter/OTIOExportTask.html","title":"OTIOExportTask","text":""},{"location":"autoapi/client/ayon_hiero/api/startup/Python/Startup/otioexporter/OTIOExportTask.html#client.ayon_hiero.api.startup.Python.Startup.otioexporter.OTIOExportTask.OTIOExportPreset","title":"<code>OTIOExportPreset</code>","text":"<p>               Bases: <code>TaskPresetBase</code></p> Source code in <code>client/ayon_hiero/api/startup/Python/Startup/otioexporter/OTIOExportTask.py</code> <pre><code>class OTIOExportPreset(hiero.core.TaskPresetBase):\n    def __init__(self, name, properties):\n        \"\"\"Initialise presets to default values\"\"\"\n        hiero.core.TaskPresetBase.__init__(self, OTIOExportTask, name)\n\n        self.properties()[\"includeTags\"] = hiero_export.include_tags = True\n        self.properties().update(properties)\n\n    def supportedItems(self):\n        return hiero.core.TaskPresetBase.kSequence\n\n    def addCustomResolveEntries(self, resolver):\n        resolver.addResolver(\n            \"{ext}\",\n            \"Extension of the file to be output\",\n            lambda keyword, task: \"otio\"\n        )\n\n    def supportsAudio(self):\n        return True\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/api/startup/Python/Startup/otioexporter/OTIOExportTask.html#client.ayon_hiero.api.startup.Python.Startup.otioexporter.OTIOExportTask.OTIOExportPreset.__init__","title":"<code>__init__(name, properties)</code>","text":"<p>Initialise presets to default values</p> Source code in <code>client/ayon_hiero/api/startup/Python/Startup/otioexporter/OTIOExportTask.py</code> <pre><code>def __init__(self, name, properties):\n    \"\"\"Initialise presets to default values\"\"\"\n    hiero.core.TaskPresetBase.__init__(self, OTIOExportTask, name)\n\n    self.properties()[\"includeTags\"] = hiero_export.include_tags = True\n    self.properties().update(properties)\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/api/startup/Python/Startup/otioexporter/OTIOExportTask.html#client.ayon_hiero.api.startup.Python.Startup.otioexporter.OTIOExportTask.OTIOExportTask","title":"<code>OTIOExportTask</code>","text":"<p>               Bases: <code>TaskBase</code></p> Source code in <code>client/ayon_hiero/api/startup/Python/Startup/otioexporter/OTIOExportTask.py</code> <pre><code>class OTIOExportTask(hiero.core.TaskBase):\n\n    def __init__(self, initDict):\n        \"\"\"Initialize\"\"\"\n        hiero.core.TaskBase.__init__(self, initDict)\n        self.otio_timeline = None\n\n    def name(self):\n        return str(type(self))\n\n    def startTask(self):\n        self.otio_timeline = hiero_export.create_otio_timeline()\n\n    def taskStep(self):\n        return False\n\n    def finishTask(self):\n        try:\n            exportPath = self.resolvedExportPath()\n\n            # Check file extension\n            if not exportPath.lower().endswith(\".otio\"):\n                exportPath += \".otio\"\n\n            # check export root exists\n            dirname = os.path.dirname(exportPath)\n            util.filesystem.makeDirs(dirname)\n\n            # write otio file\n            hiero_export.write_to_file(self.otio_timeline, exportPath)\n\n        # Catch all exceptions and log error\n        except Exception as e:\n            self.setError(\"failed to write file {f}\\n{e}\".format(\n                f=exportPath,\n                e=e)\n            )\n\n        hiero.core.TaskBase.finishTask(self)\n\n    def forcedAbort(self):\n        pass\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/api/startup/Python/Startup/otioexporter/OTIOExportTask.html#client.ayon_hiero.api.startup.Python.Startup.otioexporter.OTIOExportTask.OTIOExportTask.__init__","title":"<code>__init__(initDict)</code>","text":"<p>Initialize</p> Source code in <code>client/ayon_hiero/api/startup/Python/Startup/otioexporter/OTIOExportTask.py</code> <pre><code>def __init__(self, initDict):\n    \"\"\"Initialize\"\"\"\n    hiero.core.TaskBase.__init__(self, initDict)\n    self.otio_timeline = None\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/api/startup/Python/Startup/otioexporter/OTIOExportUI.html","title":"OTIOExportUI","text":""},{"location":"autoapi/client/ayon_hiero/api/startup/Python/Startup/otioexporter/OTIOExportUI.html#client.ayon_hiero.api.startup.Python.Startup.otioexporter.OTIOExportUI.OTIOExportUI","title":"<code>OTIOExportUI</code>","text":"<p>               Bases: <code>TaskUIBase</code></p> Source code in <code>client/ayon_hiero/api/startup/Python/Startup/otioexporter/OTIOExportUI.py</code> <pre><code>class OTIOExportUI(hiero.ui.TaskUIBase):\n    def __init__(self, preset):\n        \"\"\"Initialize\"\"\"\n        hiero.ui.TaskUIBase.__init__(\n            self,\n            OTIOExportTask,\n            preset,\n            \"OTIO Exporter\"\n        )\n\n    def includeMarkersCheckboxChanged(self, state):\n        # Slot to handle change of checkbox state\n        hiero_export.include_tags = state == QtCore.Qt.Checked\n\n    def populateUI(self, widget, exportTemplate):\n        layout = widget.layout()\n        formLayout = FormLayout()\n\n        # Hiero ~= 10.0v4\n        if layout is None:\n            layout = formLayout\n            widget.setLayout(layout)\n\n        else:\n            layout.addLayout(formLayout)\n\n        # Checkboxes for whether the OTIO should contain markers or not\n        self.includeMarkersCheckbox = QCheckBox()\n        self.includeMarkersCheckbox.setToolTip(\n            \"Enable to include Tags as markers in the exported OTIO file.\"\n        )\n        self.includeMarkersCheckbox.setCheckState(QtCore.Qt.Unchecked)\n\n        if self._preset.properties()[\"includeTags\"]:\n            self.includeMarkersCheckbox.setCheckState(QtCore.Qt.Checked)\n\n        self.includeMarkersCheckbox.stateChanged.connect(\n            self.includeMarkersCheckboxChanged\n        )\n\n        # Add Checkbox to layout\n        formLayout.addRow(\"Include Tags:\", self.includeMarkersCheckbox)\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/api/startup/Python/Startup/otioexporter/OTIOExportUI.html#client.ayon_hiero.api.startup.Python.Startup.otioexporter.OTIOExportUI.OTIOExportUI.__init__","title":"<code>__init__(preset)</code>","text":"<p>Initialize</p> Source code in <code>client/ayon_hiero/api/startup/Python/Startup/otioexporter/OTIOExportUI.py</code> <pre><code>def __init__(self, preset):\n    \"\"\"Initialize\"\"\"\n    hiero.ui.TaskUIBase.__init__(\n        self,\n        OTIOExportTask,\n        preset,\n        \"OTIO Exporter\"\n    )\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/api/startup/Python/StartupUI/index.html","title":"StartupUI","text":""},{"location":"autoapi/client/ayon_hiero/api/startup/Python/StartupUI/PimpMySpreadsheet.html","title":"PimpMySpreadsheet","text":""},{"location":"autoapi/client/ayon_hiero/api/startup/Python/StartupUI/PimpMySpreadsheet.html#client.ayon_hiero.api.startup.Python.StartupUI.PimpMySpreadsheet.CustomSpreadsheetColumns","title":"<code>CustomSpreadsheetColumns</code>","text":"<p>               Bases: <code>QObject</code></p> <p>A class defining custom columns for Hiero's spreadsheet view. This has a similar, but slightly simplified, interface to the QAbstractItemModel and QItemDelegate classes.</p> Source code in <code>client/ayon_hiero/api/startup/Python/StartupUI/PimpMySpreadsheet.py</code> <pre><code>class CustomSpreadsheetColumns(QObject):\n    \"\"\"\n    A class defining custom columns for Hiero's spreadsheet view. This has a similar, but\n    slightly simplified, interface to the QAbstractItemModel and QItemDelegate classes.\n  \"\"\"\n    global gStatusTags\n    global gArtistList\n\n    # Ideally, we'd set this list on a Per Item basis, but this is expensive for a large mixed selection\n    standardColourSpaces = [\n        \"linear\", \"sRGB\", \"rec709\", \"Cineon\", \"Gamma1.8\", \"Gamma2.2\",\n        \"Panalog\", \"REDLog\", \"ViperLog\"\n    ]\n    arriColourSpaces = [\n        \"Video - Rec709\", \"LogC - Camera Native\", \"Video - P3\", \"ACES\",\n        \"LogC - Film\", \"LogC - Wide Gamut\"\n    ]\n    r3dColourSpaces = [\n        \"Linear\", \"Rec709\", \"REDspace\", \"REDlog\", \"PDlog685\", \"PDlog985\",\n        \"CustomPDlog\", \"REDgamma\", \"SRGB\", \"REDlogFilm\", \"REDgamma2\",\n        \"REDgamma3\"\n    ]\n    gColourSpaces = standardColourSpaces + arriColourSpaces + r3dColourSpaces\n\n    currentView = hiero.ui.activeView()\n\n    # This is the list of Columns available\n    gCustomColumnList = [\n        {\n            \"name\": \"Tags\",\n            \"cellType\": \"readonly\"\n        },\n        {\n            \"name\": \"Colourspace\",\n            \"cellType\": \"dropdown\"\n        },\n        {\n            \"name\": \"Notes\",\n            \"cellType\": \"readonly\"\n        },\n        {\n            \"name\": \"FileType\",\n            \"cellType\": \"readonly\"\n        },\n        {\n            \"name\": \"Shot Status\",\n            \"cellType\": \"dropdown\"\n        },\n        {\n            \"name\": \"Thumbnail\",\n            \"cellType\": \"readonly\"\n        },\n        {\n            \"name\": \"MediaType\",\n            \"cellType\": \"readonly\"\n        },\n        {\n            \"name\": \"Width\",\n            \"cellType\": \"readonly\"\n        },\n        {\n            \"name\": \"Height\",\n            \"cellType\": \"readonly\"\n        },\n        {\n            \"name\": \"Pixel Aspect\",\n            \"cellType\": \"readonly\"\n        },\n        {\n            \"name\": \"Artist\",\n            \"cellType\": \"dropdown\"\n        },\n        {\n            \"name\": \"Department\",\n            \"cellType\": \"readonly\"\n        },\n    ]\n\n    def numColumns(self):\n        \"\"\"\n      Return the number of custom columns in the spreadsheet view\n    \"\"\"\n        return len(self.gCustomColumnList)\n\n    def columnName(self, column):\n        \"\"\"\n      Return the name of a custom column\n    \"\"\"\n        return self.gCustomColumnList[column][\"name\"]\n\n    def getTagsString(self, item):\n        \"\"\"\n      Convenience method for returning all the Notes in a Tag as a string\n    \"\"\"\n        tagNames = []\n        tags = item.tags()\n        for tag in tags:\n            tagNames += [tag.name()]\n        tagNameString = ','.join(tagNames)\n        return tagNameString\n\n    def getNotes(self, item):\n        \"\"\"\n      Convenience method for returning all the Notes in a Tag as a string\n    \"\"\"\n        notes = \"\"\n        tags = item.tags()\n        for tag in tags:\n            note = tag.note()\n            if len(note) &gt; 0:\n                notes += tag.note() + ', '\n        return notes[:-2]\n\n    def getData(self, row, column, item):\n        \"\"\"\n      Return the data in a cell\n    \"\"\"\n        currentColumn = self.gCustomColumnList[column]\n        if currentColumn[\"name\"] == \"Tags\":\n            return self.getTagsString(item)\n\n        if currentColumn[\"name\"] == \"Colourspace\":\n            try:\n                colTransform = item.sourceMediaColourTransform()\n            except:\n                colTransform = \"--\"\n            return colTransform\n\n        if currentColumn[\"name\"] == \"Notes\":\n            try:\n                note = self.getNotes(item)\n            except:\n                note = \"\"\n            return note\n\n        if currentColumn[\"name\"] == \"FileType\":\n            fileType = \"--\"\n            M = item.source().mediaSource().metadata()\n            if M.hasKey(\"foundry.source.type\"):\n                fileType = M.value(\"foundry.source.type\")\n            elif M.hasKey(\"media.input.filereader\"):\n                fileType = M.value(\"media.input.filereader\")\n            return fileType\n\n        if currentColumn[\"name\"] == \"Shot Status\":\n            status = item.status()\n            if not status:\n                status = \"--\"\n            return str(status)\n\n        if currentColumn[\"name\"] == \"MediaType\":\n            M = item.mediaType()\n            return str(M).split(\"MediaType\")[-1].replace(\".k\", \"\")\n\n        if currentColumn[\"name\"] == \"Thumbnail\":\n            return str(item.eventNumber())\n\n        if currentColumn[\"name\"] == \"Width\":\n            return str(item.source().format().width())\n\n        if currentColumn[\"name\"] == \"Height\":\n            return str(item.source().format().height())\n\n        if currentColumn[\"name\"] == \"Pixel Aspect\":\n            return str(item.source().format().pixelAspect())\n\n        if currentColumn[\"name\"] == \"Artist\":\n            if item.artist():\n                name = item.artist()[\"artistName\"]\n                return name\n            else:\n                return \"--\"\n\n        if currentColumn[\"name\"] == \"Department\":\n            if item.artist():\n                dep = item.artist()[\"artistDepartment\"]\n                return dep\n            else:\n                return \"--\"\n\n        return \"\"\n\n    def setData(self, row, column, item, data):\n        \"\"\"\n      Set the data in a cell - unused in this example\n    \"\"\"\n\n        return None\n\n    def getTooltip(self, row, column, item):\n        \"\"\"\n      Return the tooltip for a cell\n    \"\"\"\n        currentColumn = self.gCustomColumnList[column]\n        if currentColumn[\"name\"] == \"Tags\":\n            return str([item.name() for item in item.tags()])\n\n        if currentColumn[\"name\"] == \"Notes\":\n            return str(self.getNotes(item))\n        return \"\"\n\n    def getFont(self, row, column, item):\n        \"\"\"\n      Return the tooltip for a cell\n    \"\"\"\n        return None\n\n    def getBackground(self, row, column, item):\n        \"\"\"\n      Return the background colour for a cell\n    \"\"\"\n        if not item.source().mediaSource().isMediaPresent():\n            return QColor(80, 20, 20)\n        return None\n\n    def getForeground(self, row, column, item):\n        \"\"\"\n      Return the text colour for a cell\n    \"\"\"\n        #if column == 1:\n        #  return QColor(255, 64, 64)\n        return None\n\n    def getIcon(self, row, column, item):\n        \"\"\"\n      Return the icon for a cell\n    \"\"\"\n        currentColumn = self.gCustomColumnList[column]\n        if currentColumn[\"name\"] == \"Colourspace\":\n            return QIcon(\"icons:LUT.png\")\n\n        if currentColumn[\"name\"] == \"Shot Status\":\n            status = item.status()\n            if status:\n                return QIcon(gStatusTags[status])\n\n        if currentColumn[\"name\"] == \"MediaType\":\n            mediaType = item.mediaType()\n            if mediaType == hiero.core.TrackItem.kVideo:\n                return QIcon(\"icons:VideoOnly.png\")\n            elif mediaType == hiero.core.TrackItem.kAudio:\n                return QIcon(\"icons:AudioOnly.png\")\n\n        if currentColumn[\"name\"] == \"Artist\":\n            try:\n                return QIcon(item.artist()[\"artistIcon\"])\n            except:\n                return None\n        return None\n\n    def getSizeHint(self, row, column, item):\n        \"\"\"\n      Return the size hint for a cell\n    \"\"\"\n        currentColumnName = self.gCustomColumnList[column][\"name\"]\n\n        if currentColumnName == \"Thumbnail\":\n            return QSize(90, 50)\n\n        return QSize(50, 50)\n\n    def paintCell(self, row, column, item, painter, option):\n        \"\"\"\n      Paint a custom cell. Return True if the cell was painted, or False to continue\n      with the default cell painting.\n    \"\"\"\n        currentColumn = self.gCustomColumnList[column]\n        if currentColumn[\"name\"] == \"Tags\":\n            if option.state &amp; QStyle.State_Selected:\n                painter.fillRect(option.rect, option.palette.highlight())\n            iconSize = 20\n            r = QRect(option.rect.x(),\n                      option.rect.y() + (option.rect.height() - iconSize) / 2,\n                      iconSize, iconSize)\n            tags = item.tags()\n            if len(tags) &gt; 0:\n                painter.save()\n                painter.setClipRect(option.rect)\n                for tag in item.tags():\n                    M = tag.metadata()\n                    if not (M.hasKey(\"tag.status\")\n                            or M.hasKey(\"tag.artistID\")):\n                        QIcon(tag.icon()).paint(painter, r, Qt.AlignLeft)\n                        r.translate(r.width() + 2, 0)\n                painter.restore()\n                return True\n\n        if currentColumn[\"name\"] == \"Thumbnail\":\n            imageView = None\n            pen = QPen()\n            r = QRect(option.rect.x() + 2, (option.rect.y() +\n                                            (option.rect.height() - 46) / 2),\n                      85, 46)\n            if not item.source().mediaSource().isMediaPresent():\n                imageView = QImage(\"icons:Offline.png\")\n                pen.setColor(QColor(Qt.red))\n\n            if item.mediaType() == hiero.core.TrackItem.MediaType.kAudio:\n                imageView = QImage(\"icons:AudioOnly.png\")\n                #pen.setColor(QColor(Qt.green))\n                painter.fillRect(r, QColor(45, 59, 45))\n\n            if option.state &amp; QStyle.State_Selected:\n                painter.fillRect(option.rect, option.palette.highlight())\n\n            tags = item.tags()\n            painter.save()\n            painter.setClipRect(option.rect)\n\n            if not imageView:\n                try:\n                    imageView = item.thumbnail(item.sourceIn())\n                    pen.setColor(QColor(20, 20, 20))\n                # If we're here, we probably have a TC error, no thumbnail, so get it from the source Clip...\n                except:\n                    pen.setColor(QColor(Qt.red))\n\n            if not imageView:\n                try:\n                    imageView = item.source().thumbnail()\n                    pen.setColor(QColor(Qt.yellow))\n                except:\n                    imageView = QImage(\"icons:Offline.png\")\n                    pen.setColor(QColor(Qt.red))\n\n            QIcon(QPixmap.fromImage(imageView)).paint(painter, r,\n                                                      Qt.AlignCenter)\n            painter.setPen(pen)\n            painter.drawRoundedRect(r, 1, 1)\n            painter.restore()\n            return True\n\n        return False\n\n    def createEditor(self, row, column, item, view):\n        \"\"\"\n      Create an editing widget for a custom cell\n    \"\"\"\n        self.currentView = view\n\n        currentColumn = self.gCustomColumnList[column]\n        if currentColumn[\"cellType\"] == \"readonly\":\n            cle = QLabel()\n            cle.setEnabled(False)\n            cle.setVisible(False)\n            return cle\n\n        if currentColumn[\"name\"] == \"Colourspace\":\n            cb = QComboBox()\n            for colourspace in self.gColourSpaces:\n                cb.addItem(colourspace)\n            cb.currentIndexChanged.connect(self.colourspaceChanged)\n            return cb\n\n        if currentColumn[\"name\"] == \"Shot Status\":\n            cb = QComboBox()\n            cb.addItem(\"\")\n            for key in gStatusTags.keys():\n                cb.addItem(QIcon(gStatusTags[key]), key)\n            cb.addItem(\"--\")\n            cb.currentIndexChanged.connect(self.statusChanged)\n\n            return cb\n\n        if currentColumn[\"name\"] == \"Artist\":\n            cb = QComboBox()\n            cb.addItem(\"\")\n            for artist in gArtistList:\n                cb.addItem(artist[\"artistName\"])\n            cb.addItem(\"--\")\n            cb.currentIndexChanged.connect(self.artistNameChanged)\n            return cb\n        return None\n\n    def setModelData(self, row, column, item, editor):\n        return False\n\n    def dropMimeData(self, row, column, item, data, items):\n        \"\"\"\n      Handle a drag and drop operation - adds a Dragged Tag to the shot\n    \"\"\"\n        for thing in items:\n            if isinstance(thing, hiero.core.Tag):\n                item.addTag(thing)\n        return None\n\n    def colourspaceChanged(self, index):\n        \"\"\"\n      This method is called when Colourspace widget changes index.\n    \"\"\"\n        index = self.sender().currentIndex()\n        colourspace = self.gColourSpaces[index]\n        selection = self.currentView.selection()\n        project = selection[0].project()\n        with project.beginUndo(\"Set Colourspace\"):\n            items = [\n                item for item in selection\n                if (item.mediaType() == hiero.core.TrackItem.MediaType.kVideo)\n            ]\n            for trackItem in items:\n                trackItem.setSourceMediaColourTransform(colourspace)\n\n    def statusChanged(self, arg):\n        \"\"\"\n      This method is called when Shot Status widget changes index.\n    \"\"\"\n        view = hiero.ui.activeView()\n        selection = view.selection()\n        status = self.sender().currentText()\n        project = selection[0].project()\n        with project.beginUndo(\"Set Status\"):\n            # A string of \"--\" characters denotes clear the status\n            if status != \"--\":\n                for trackItem in selection:\n                    trackItem.setStatus(status)\n            else:\n                for trackItem in selection:\n                    tTags = trackItem.tags()\n                    for tag in tTags:\n                        if tag.metadata().hasKey(\"tag.status\"):\n                            trackItem.removeTag(tag)\n                            break\n\n    def artistNameChanged(self, arg):\n        \"\"\"\n      This method is called when Artist widget changes index.\n    \"\"\"\n        view = hiero.ui.activeView()\n        selection = view.selection()\n        name = self.sender().currentText()\n        project = selection[0].project()\n        with project.beginUndo(\"Assign Artist\"):\n            # A string of \"--\" denotes clear the assignee...\n            if name != \"--\":\n                for trackItem in selection:\n                    trackItem.setArtistByName(name)\n            else:\n                for trackItem in selection:\n                    tTags = trackItem.tags()\n                    for tag in tTags:\n                        if tag.metadata().hasKey(\"tag.artistID\"):\n                            trackItem.removeTag(tag)\n                            break\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/api/startup/Python/StartupUI/PimpMySpreadsheet.html#client.ayon_hiero.api.startup.Python.StartupUI.PimpMySpreadsheet.CustomSpreadsheetColumns.artistNameChanged","title":"<code>artistNameChanged(arg)</code>","text":"<p>This method is called when Artist widget changes index.</p> Source code in <code>client/ayon_hiero/api/startup/Python/StartupUI/PimpMySpreadsheet.py</code> <pre><code>def artistNameChanged(self, arg):\n    \"\"\"\n  This method is called when Artist widget changes index.\n\"\"\"\n    view = hiero.ui.activeView()\n    selection = view.selection()\n    name = self.sender().currentText()\n    project = selection[0].project()\n    with project.beginUndo(\"Assign Artist\"):\n        # A string of \"--\" denotes clear the assignee...\n        if name != \"--\":\n            for trackItem in selection:\n                trackItem.setArtistByName(name)\n        else:\n            for trackItem in selection:\n                tTags = trackItem.tags()\n                for tag in tTags:\n                    if tag.metadata().hasKey(\"tag.artistID\"):\n                        trackItem.removeTag(tag)\n                        break\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/api/startup/Python/StartupUI/PimpMySpreadsheet.html#client.ayon_hiero.api.startup.Python.StartupUI.PimpMySpreadsheet.CustomSpreadsheetColumns.colourspaceChanged","title":"<code>colourspaceChanged(index)</code>","text":"<p>This method is called when Colourspace widget changes index.</p> Source code in <code>client/ayon_hiero/api/startup/Python/StartupUI/PimpMySpreadsheet.py</code> <pre><code>def colourspaceChanged(self, index):\n    \"\"\"\n  This method is called when Colourspace widget changes index.\n\"\"\"\n    index = self.sender().currentIndex()\n    colourspace = self.gColourSpaces[index]\n    selection = self.currentView.selection()\n    project = selection[0].project()\n    with project.beginUndo(\"Set Colourspace\"):\n        items = [\n            item for item in selection\n            if (item.mediaType() == hiero.core.TrackItem.MediaType.kVideo)\n        ]\n        for trackItem in items:\n            trackItem.setSourceMediaColourTransform(colourspace)\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/api/startup/Python/StartupUI/PimpMySpreadsheet.html#client.ayon_hiero.api.startup.Python.StartupUI.PimpMySpreadsheet.CustomSpreadsheetColumns.columnName","title":"<code>columnName(column)</code>","text":"<p>Return the name of a custom column</p> Source code in <code>client/ayon_hiero/api/startup/Python/StartupUI/PimpMySpreadsheet.py</code> <pre><code>def columnName(self, column):\n    \"\"\"\n  Return the name of a custom column\n\"\"\"\n    return self.gCustomColumnList[column][\"name\"]\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/api/startup/Python/StartupUI/PimpMySpreadsheet.html#client.ayon_hiero.api.startup.Python.StartupUI.PimpMySpreadsheet.CustomSpreadsheetColumns.createEditor","title":"<code>createEditor(row, column, item, view)</code>","text":"<p>Create an editing widget for a custom cell</p> Source code in <code>client/ayon_hiero/api/startup/Python/StartupUI/PimpMySpreadsheet.py</code> <pre><code>def createEditor(self, row, column, item, view):\n    \"\"\"\n  Create an editing widget for a custom cell\n\"\"\"\n    self.currentView = view\n\n    currentColumn = self.gCustomColumnList[column]\n    if currentColumn[\"cellType\"] == \"readonly\":\n        cle = QLabel()\n        cle.setEnabled(False)\n        cle.setVisible(False)\n        return cle\n\n    if currentColumn[\"name\"] == \"Colourspace\":\n        cb = QComboBox()\n        for colourspace in self.gColourSpaces:\n            cb.addItem(colourspace)\n        cb.currentIndexChanged.connect(self.colourspaceChanged)\n        return cb\n\n    if currentColumn[\"name\"] == \"Shot Status\":\n        cb = QComboBox()\n        cb.addItem(\"\")\n        for key in gStatusTags.keys():\n            cb.addItem(QIcon(gStatusTags[key]), key)\n        cb.addItem(\"--\")\n        cb.currentIndexChanged.connect(self.statusChanged)\n\n        return cb\n\n    if currentColumn[\"name\"] == \"Artist\":\n        cb = QComboBox()\n        cb.addItem(\"\")\n        for artist in gArtistList:\n            cb.addItem(artist[\"artistName\"])\n        cb.addItem(\"--\")\n        cb.currentIndexChanged.connect(self.artistNameChanged)\n        return cb\n    return None\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/api/startup/Python/StartupUI/PimpMySpreadsheet.html#client.ayon_hiero.api.startup.Python.StartupUI.PimpMySpreadsheet.CustomSpreadsheetColumns.dropMimeData","title":"<code>dropMimeData(row, column, item, data, items)</code>","text":"<p>Handle a drag and drop operation - adds a Dragged Tag to the shot</p> Source code in <code>client/ayon_hiero/api/startup/Python/StartupUI/PimpMySpreadsheet.py</code> <pre><code>def dropMimeData(self, row, column, item, data, items):\n    \"\"\"\n  Handle a drag and drop operation - adds a Dragged Tag to the shot\n\"\"\"\n    for thing in items:\n        if isinstance(thing, hiero.core.Tag):\n            item.addTag(thing)\n    return None\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/api/startup/Python/StartupUI/PimpMySpreadsheet.html#client.ayon_hiero.api.startup.Python.StartupUI.PimpMySpreadsheet.CustomSpreadsheetColumns.getBackground","title":"<code>getBackground(row, column, item)</code>","text":"<p>Return the background colour for a cell</p> Source code in <code>client/ayon_hiero/api/startup/Python/StartupUI/PimpMySpreadsheet.py</code> <pre><code>def getBackground(self, row, column, item):\n    \"\"\"\n  Return the background colour for a cell\n\"\"\"\n    if not item.source().mediaSource().isMediaPresent():\n        return QColor(80, 20, 20)\n    return None\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/api/startup/Python/StartupUI/PimpMySpreadsheet.html#client.ayon_hiero.api.startup.Python.StartupUI.PimpMySpreadsheet.CustomSpreadsheetColumns.getData","title":"<code>getData(row, column, item)</code>","text":"<p>Return the data in a cell</p> Source code in <code>client/ayon_hiero/api/startup/Python/StartupUI/PimpMySpreadsheet.py</code> <pre><code>def getData(self, row, column, item):\n    \"\"\"\n  Return the data in a cell\n\"\"\"\n    currentColumn = self.gCustomColumnList[column]\n    if currentColumn[\"name\"] == \"Tags\":\n        return self.getTagsString(item)\n\n    if currentColumn[\"name\"] == \"Colourspace\":\n        try:\n            colTransform = item.sourceMediaColourTransform()\n        except:\n            colTransform = \"--\"\n        return colTransform\n\n    if currentColumn[\"name\"] == \"Notes\":\n        try:\n            note = self.getNotes(item)\n        except:\n            note = \"\"\n        return note\n\n    if currentColumn[\"name\"] == \"FileType\":\n        fileType = \"--\"\n        M = item.source().mediaSource().metadata()\n        if M.hasKey(\"foundry.source.type\"):\n            fileType = M.value(\"foundry.source.type\")\n        elif M.hasKey(\"media.input.filereader\"):\n            fileType = M.value(\"media.input.filereader\")\n        return fileType\n\n    if currentColumn[\"name\"] == \"Shot Status\":\n        status = item.status()\n        if not status:\n            status = \"--\"\n        return str(status)\n\n    if currentColumn[\"name\"] == \"MediaType\":\n        M = item.mediaType()\n        return str(M).split(\"MediaType\")[-1].replace(\".k\", \"\")\n\n    if currentColumn[\"name\"] == \"Thumbnail\":\n        return str(item.eventNumber())\n\n    if currentColumn[\"name\"] == \"Width\":\n        return str(item.source().format().width())\n\n    if currentColumn[\"name\"] == \"Height\":\n        return str(item.source().format().height())\n\n    if currentColumn[\"name\"] == \"Pixel Aspect\":\n        return str(item.source().format().pixelAspect())\n\n    if currentColumn[\"name\"] == \"Artist\":\n        if item.artist():\n            name = item.artist()[\"artistName\"]\n            return name\n        else:\n            return \"--\"\n\n    if currentColumn[\"name\"] == \"Department\":\n        if item.artist():\n            dep = item.artist()[\"artistDepartment\"]\n            return dep\n        else:\n            return \"--\"\n\n    return \"\"\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/api/startup/Python/StartupUI/PimpMySpreadsheet.html#client.ayon_hiero.api.startup.Python.StartupUI.PimpMySpreadsheet.CustomSpreadsheetColumns.getFont","title":"<code>getFont(row, column, item)</code>","text":"<p>Return the tooltip for a cell</p> Source code in <code>client/ayon_hiero/api/startup/Python/StartupUI/PimpMySpreadsheet.py</code> <pre><code>def getFont(self, row, column, item):\n    \"\"\"\n  Return the tooltip for a cell\n\"\"\"\n    return None\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/api/startup/Python/StartupUI/PimpMySpreadsheet.html#client.ayon_hiero.api.startup.Python.StartupUI.PimpMySpreadsheet.CustomSpreadsheetColumns.getForeground","title":"<code>getForeground(row, column, item)</code>","text":"<p>Return the text colour for a cell</p> Source code in <code>client/ayon_hiero/api/startup/Python/StartupUI/PimpMySpreadsheet.py</code> <pre><code>def getForeground(self, row, column, item):\n    \"\"\"\n  Return the text colour for a cell\n\"\"\"\n    #if column == 1:\n    #  return QColor(255, 64, 64)\n    return None\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/api/startup/Python/StartupUI/PimpMySpreadsheet.html#client.ayon_hiero.api.startup.Python.StartupUI.PimpMySpreadsheet.CustomSpreadsheetColumns.getIcon","title":"<code>getIcon(row, column, item)</code>","text":"<p>Return the icon for a cell</p> Source code in <code>client/ayon_hiero/api/startup/Python/StartupUI/PimpMySpreadsheet.py</code> <pre><code>def getIcon(self, row, column, item):\n    \"\"\"\n  Return the icon for a cell\n\"\"\"\n    currentColumn = self.gCustomColumnList[column]\n    if currentColumn[\"name\"] == \"Colourspace\":\n        return QIcon(\"icons:LUT.png\")\n\n    if currentColumn[\"name\"] == \"Shot Status\":\n        status = item.status()\n        if status:\n            return QIcon(gStatusTags[status])\n\n    if currentColumn[\"name\"] == \"MediaType\":\n        mediaType = item.mediaType()\n        if mediaType == hiero.core.TrackItem.kVideo:\n            return QIcon(\"icons:VideoOnly.png\")\n        elif mediaType == hiero.core.TrackItem.kAudio:\n            return QIcon(\"icons:AudioOnly.png\")\n\n    if currentColumn[\"name\"] == \"Artist\":\n        try:\n            return QIcon(item.artist()[\"artistIcon\"])\n        except:\n            return None\n    return None\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/api/startup/Python/StartupUI/PimpMySpreadsheet.html#client.ayon_hiero.api.startup.Python.StartupUI.PimpMySpreadsheet.CustomSpreadsheetColumns.getNotes","title":"<code>getNotes(item)</code>","text":"<p>Convenience method for returning all the Notes in a Tag as a string</p> Source code in <code>client/ayon_hiero/api/startup/Python/StartupUI/PimpMySpreadsheet.py</code> <pre><code>def getNotes(self, item):\n    \"\"\"\n  Convenience method for returning all the Notes in a Tag as a string\n\"\"\"\n    notes = \"\"\n    tags = item.tags()\n    for tag in tags:\n        note = tag.note()\n        if len(note) &gt; 0:\n            notes += tag.note() + ', '\n    return notes[:-2]\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/api/startup/Python/StartupUI/PimpMySpreadsheet.html#client.ayon_hiero.api.startup.Python.StartupUI.PimpMySpreadsheet.CustomSpreadsheetColumns.getSizeHint","title":"<code>getSizeHint(row, column, item)</code>","text":"<p>Return the size hint for a cell</p> Source code in <code>client/ayon_hiero/api/startup/Python/StartupUI/PimpMySpreadsheet.py</code> <pre><code>def getSizeHint(self, row, column, item):\n    \"\"\"\n  Return the size hint for a cell\n\"\"\"\n    currentColumnName = self.gCustomColumnList[column][\"name\"]\n\n    if currentColumnName == \"Thumbnail\":\n        return QSize(90, 50)\n\n    return QSize(50, 50)\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/api/startup/Python/StartupUI/PimpMySpreadsheet.html#client.ayon_hiero.api.startup.Python.StartupUI.PimpMySpreadsheet.CustomSpreadsheetColumns.getTagsString","title":"<code>getTagsString(item)</code>","text":"<p>Convenience method for returning all the Notes in a Tag as a string</p> Source code in <code>client/ayon_hiero/api/startup/Python/StartupUI/PimpMySpreadsheet.py</code> <pre><code>def getTagsString(self, item):\n    \"\"\"\n  Convenience method for returning all the Notes in a Tag as a string\n\"\"\"\n    tagNames = []\n    tags = item.tags()\n    for tag in tags:\n        tagNames += [tag.name()]\n    tagNameString = ','.join(tagNames)\n    return tagNameString\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/api/startup/Python/StartupUI/PimpMySpreadsheet.html#client.ayon_hiero.api.startup.Python.StartupUI.PimpMySpreadsheet.CustomSpreadsheetColumns.getTooltip","title":"<code>getTooltip(row, column, item)</code>","text":"<p>Return the tooltip for a cell</p> Source code in <code>client/ayon_hiero/api/startup/Python/StartupUI/PimpMySpreadsheet.py</code> <pre><code>def getTooltip(self, row, column, item):\n    \"\"\"\n  Return the tooltip for a cell\n\"\"\"\n    currentColumn = self.gCustomColumnList[column]\n    if currentColumn[\"name\"] == \"Tags\":\n        return str([item.name() for item in item.tags()])\n\n    if currentColumn[\"name\"] == \"Notes\":\n        return str(self.getNotes(item))\n    return \"\"\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/api/startup/Python/StartupUI/PimpMySpreadsheet.html#client.ayon_hiero.api.startup.Python.StartupUI.PimpMySpreadsheet.CustomSpreadsheetColumns.numColumns","title":"<code>numColumns()</code>","text":"<p>Return the number of custom columns in the spreadsheet view</p> Source code in <code>client/ayon_hiero/api/startup/Python/StartupUI/PimpMySpreadsheet.py</code> <pre><code>def numColumns(self):\n    \"\"\"\n  Return the number of custom columns in the spreadsheet view\n\"\"\"\n    return len(self.gCustomColumnList)\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/api/startup/Python/StartupUI/PimpMySpreadsheet.html#client.ayon_hiero.api.startup.Python.StartupUI.PimpMySpreadsheet.CustomSpreadsheetColumns.paintCell","title":"<code>paintCell(row, column, item, painter, option)</code>","text":"<p>Paint a custom cell. Return True if the cell was painted, or False to continue with the default cell painting.</p> Source code in <code>client/ayon_hiero/api/startup/Python/StartupUI/PimpMySpreadsheet.py</code> <pre><code>def paintCell(self, row, column, item, painter, option):\n    \"\"\"\n  Paint a custom cell. Return True if the cell was painted, or False to continue\n  with the default cell painting.\n\"\"\"\n    currentColumn = self.gCustomColumnList[column]\n    if currentColumn[\"name\"] == \"Tags\":\n        if option.state &amp; QStyle.State_Selected:\n            painter.fillRect(option.rect, option.palette.highlight())\n        iconSize = 20\n        r = QRect(option.rect.x(),\n                  option.rect.y() + (option.rect.height() - iconSize) / 2,\n                  iconSize, iconSize)\n        tags = item.tags()\n        if len(tags) &gt; 0:\n            painter.save()\n            painter.setClipRect(option.rect)\n            for tag in item.tags():\n                M = tag.metadata()\n                if not (M.hasKey(\"tag.status\")\n                        or M.hasKey(\"tag.artistID\")):\n                    QIcon(tag.icon()).paint(painter, r, Qt.AlignLeft)\n                    r.translate(r.width() + 2, 0)\n            painter.restore()\n            return True\n\n    if currentColumn[\"name\"] == \"Thumbnail\":\n        imageView = None\n        pen = QPen()\n        r = QRect(option.rect.x() + 2, (option.rect.y() +\n                                        (option.rect.height() - 46) / 2),\n                  85, 46)\n        if not item.source().mediaSource().isMediaPresent():\n            imageView = QImage(\"icons:Offline.png\")\n            pen.setColor(QColor(Qt.red))\n\n        if item.mediaType() == hiero.core.TrackItem.MediaType.kAudio:\n            imageView = QImage(\"icons:AudioOnly.png\")\n            #pen.setColor(QColor(Qt.green))\n            painter.fillRect(r, QColor(45, 59, 45))\n\n        if option.state &amp; QStyle.State_Selected:\n            painter.fillRect(option.rect, option.palette.highlight())\n\n        tags = item.tags()\n        painter.save()\n        painter.setClipRect(option.rect)\n\n        if not imageView:\n            try:\n                imageView = item.thumbnail(item.sourceIn())\n                pen.setColor(QColor(20, 20, 20))\n            # If we're here, we probably have a TC error, no thumbnail, so get it from the source Clip...\n            except:\n                pen.setColor(QColor(Qt.red))\n\n        if not imageView:\n            try:\n                imageView = item.source().thumbnail()\n                pen.setColor(QColor(Qt.yellow))\n            except:\n                imageView = QImage(\"icons:Offline.png\")\n                pen.setColor(QColor(Qt.red))\n\n        QIcon(QPixmap.fromImage(imageView)).paint(painter, r,\n                                                  Qt.AlignCenter)\n        painter.setPen(pen)\n        painter.drawRoundedRect(r, 1, 1)\n        painter.restore()\n        return True\n\n    return False\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/api/startup/Python/StartupUI/PimpMySpreadsheet.html#client.ayon_hiero.api.startup.Python.StartupUI.PimpMySpreadsheet.CustomSpreadsheetColumns.setData","title":"<code>setData(row, column, item, data)</code>","text":"<p>Set the data in a cell - unused in this example</p> Source code in <code>client/ayon_hiero/api/startup/Python/StartupUI/PimpMySpreadsheet.py</code> <pre><code>def setData(self, row, column, item, data):\n    \"\"\"\n  Set the data in a cell - unused in this example\n\"\"\"\n\n    return None\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/api/startup/Python/StartupUI/PimpMySpreadsheet.html#client.ayon_hiero.api.startup.Python.StartupUI.PimpMySpreadsheet.CustomSpreadsheetColumns.statusChanged","title":"<code>statusChanged(arg)</code>","text":"<p>This method is called when Shot Status widget changes index.</p> Source code in <code>client/ayon_hiero/api/startup/Python/StartupUI/PimpMySpreadsheet.py</code> <pre><code>def statusChanged(self, arg):\n    \"\"\"\n  This method is called when Shot Status widget changes index.\n\"\"\"\n    view = hiero.ui.activeView()\n    selection = view.selection()\n    status = self.sender().currentText()\n    project = selection[0].project()\n    with project.beginUndo(\"Set Status\"):\n        # A string of \"--\" characters denotes clear the status\n        if status != \"--\":\n            for trackItem in selection:\n                trackItem.setStatus(status)\n        else:\n            for trackItem in selection:\n                tTags = trackItem.tags()\n                for tag in tTags:\n                    if tag.metadata().hasKey(\"tag.status\"):\n                        trackItem.removeTag(tag)\n                        break\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/api/startup/Python/StartupUI/Purge.html","title":"Purge","text":""},{"location":"autoapi/client/ayon_hiero/api/startup/Python/StartupUI/nukeStyleKeyboardShortcuts.html","title":"nukeStyleKeyboardShortcuts","text":""},{"location":"autoapi/client/ayon_hiero/api/startup/Python/StartupUI/setPosterFrame.html","title":"setPosterFrame","text":""},{"location":"autoapi/client/ayon_hiero/api/startup/Python/StartupUI/setPosterFrame.html#client.ayon_hiero.api.startup.Python.StartupUI.setPosterFrame.setPosterFrame","title":"<code>setPosterFrame(posterFrame=0.5)</code>","text":"<p>Update the poster frame of the given clipItmes posterFrame = .5 uses the centre frame, a value of 0 uses the first frame, a value of 1 uses the last frame</p> Source code in <code>client/ayon_hiero/api/startup/Python/StartupUI/setPosterFrame.py</code> <pre><code>def setPosterFrame(posterFrame=.5):\n    \"\"\"\n    Update the poster frame of the given clipItmes\n    posterFrame = .5 uses the centre frame, a value of 0 uses the first frame, a value of 1 uses the last frame\n    \"\"\"\n    view = hiero.ui.activeView()\n\n    selectedBinItems = view.selection()\n    selectedClipItems = [(item.activeItem()\n                          if hasattr(item, \"activeItem\") else item)\n                         for item in selectedBinItems]\n\n    for clip in selectedClipItems:\n        centreFrame = int(clip.duration() * posterFrame)\n        clip.setPosterFrame(centreFrame)\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/api/startup/Python/StartupUI/otioimporter/index.html","title":"otioimporter","text":""},{"location":"autoapi/client/ayon_hiero/api/startup/Python/StartupUI/otioimporter/OTIOImport.html","title":"OTIOImport","text":""},{"location":"autoapi/client/ayon_hiero/plugins/index.html","title":"plugins","text":""},{"location":"autoapi/client/ayon_hiero/plugins/create/index.html","title":"create","text":""},{"location":"autoapi/client/ayon_hiero/plugins/create/create_shot_clip.html","title":"create_shot_clip","text":""},{"location":"autoapi/client/ayon_hiero/plugins/create/create_shot_clip.html#client.ayon_hiero.plugins.create.create_shot_clip.CreateShotClip","title":"<code>CreateShotClip</code>","text":"<p>               Bases: <code>HieroCreator</code></p> <p>Publishable clip</p> Source code in <code>client/ayon_hiero/plugins/create/create_shot_clip.py</code> <pre><code>class CreateShotClip(plugin.HieroCreator):\n    \"\"\"Publishable clip\"\"\"\n\n    identifier = \"io.ayon.creators.hiero.clip\"\n    label = \"Create Publishable Clip\"\n    product_type = \"editorial\"\n    icon = \"film\"\n    defaults = [\"Main\"]\n\n    detailed_description = \"\"\"\nPublishing clips/plate, audio for new shots to project\nor updating already created from Hiero. Publishing will create\nOTIO file.\n\"\"\"\n    create_allow_thumbnail = False\n\n    def get_pre_create_attr_defs(self):\n\n        def header_label(text):\n            return f\"&lt;br&gt;&lt;b&gt;{text}&lt;/b&gt;\"\n\n        tokens_help = \"\"\"\\nUsable tokens:\n    {_clip_}: name of used clip\n    {_track_}: name of parent track layer\n    {_sequence_}: name of parent sequence (timeline)\"\"\"\n\n        current_sequence = lib.get_current_sequence()\n        if current_sequence is not None:\n            gui_tracks = [\n                {\"value\": tr.name(), \"label\": f\"Track: {tr.name()}\"}\n                for tr in current_sequence.videoTracks()\n            ]\n        else:\n            gui_tracks = []\n\n        # Project settings might be applied to this creator via\n        # the inherited `Creator.apply_settings`\n        presets = self.presets\n\n        return [\n\n            BoolDef(\"use_selection\",\n                    label=\"Use only selected clip(s).\",\n                    tooltip=(\n                        \"When enabled it restricts create process \"\n                        \"to selected clips.\"\n                    ),\n                    default=True),\n\n            # renameHierarchy\n            UILabelDef(\n                label=header_label(\"Shot Hierarchy And Rename Settings\")\n            ),\n            TextDef(\n                \"hierarchy\",\n                label=\"Shot Parent Hierarchy\",\n                tooltip=\"Parents folder for shot root folder, \"\n                        \"Template filled with *Hierarchy Data* section\",\n                default=presets.get(\"hierarchy\", \"{folder}/{sequence}\"),\n            ),\n            BoolDef(\n                \"clipRename\",\n                label=\"Rename clips\",\n                tooltip=\"Renaming selected clips on fly\",\n                default=presets.get(\"clipRename\", False),\n            ),\n            TextDef(\n                \"clipName\",\n                label=\"Clip Name Template\",\n                tooltip=\"template for creating shot names, used for \"\n                        \"renaming (use rename: on)\",\n                default=presets.get(\"clipName\", \"{sequence}{shot}\"),\n            ),\n            NumberDef(\n                \"countFrom\",\n                label=\"Count sequence from\",\n                tooltip=\"Set where the sequence number starts from\",\n                default=presets.get(\"countFrom\", 10),\n            ),\n            NumberDef(\n                \"countSteps\",\n                label=\"Stepping number\",\n                tooltip=\"What number is adding every new step\",\n                default=presets.get(\"countSteps\", 10),\n            ),\n\n            # hierarchyData\n            UILabelDef(\n                label=header_label(\"Shot Template Keywords\")\n            ),\n            TextDef(\n                \"folder\",\n                label=\"{folder}\",\n                tooltip=\"Name of folder used for root of generated shots.\\n\"\n                        f\"{tokens_help}\",\n                default=presets.get(\"folder\", \"shots\"),\n            ),\n            TextDef(\n                \"episode\",\n                label=\"{episode}\",\n                tooltip=f\"Name of episode.\\n{tokens_help}\",\n                default=presets.get(\"episode\", \"ep01\"),\n            ),\n            TextDef(\n                \"sequence\",\n                label=\"{sequence}\",\n                tooltip=f\"Name of sequence of shots.\\n{tokens_help}\",\n                default=presets.get(\"sequence\", \"sq01\"),\n            ),\n            TextDef(\n                \"track\",\n                label=\"{track}\",\n                tooltip=f\"Name of timeline track.\\n{tokens_help}\",\n                default=presets.get(\"track\", \"{_track_}\"),\n            ),\n            TextDef(\n                \"shot\",\n                label=\"{shot}\",\n                tooltip=\"Name of shot. '#' is converted to padded number.\"\n                        f\"\\n{tokens_help}\",\n                default=presets.get(\"shot\", \"sh###\"),\n            ),\n\n            # verticalSync\n            UILabelDef(\n                label=header_label(\"Vertical Synchronization Of Attributes\")\n            ),\n            BoolDef(\n                \"vSyncOn\",\n                label=\"Enable Vertical Sync\",\n                tooltip=\"Switch on if you want clips above \"\n                        \"each other to share its attributes\",\n                default=presets.get(\"vSyncOn\", True),\n            ),\n            EnumDef(\n                \"vSyncTrack\",\n                label=\"Hero track\",\n                tooltip=\"Select driving track name which should \"\n                        \"be mastering all others\",\n                items=(\n                    gui_tracks or [\n                        {\"value\": None, \"label\": \"&lt; nothing to select&gt; \"}\n                        ]\n                ),\n            ),\n            # publishSettings\n            UILabelDef(\n                label=header_label(\"Publish Settings\")\n            ),\n            EnumDef(\n                \"clipVariant\",\n                label=\"Product Variant\",\n                tooltip=\"Chose variant which will be then used for \"\n                        \"product name, if &lt;track_name&gt; \"\n                        \"is selected, name of track layer will be used\",\n                items=['&lt;track_name&gt;', 'main', 'bg', 'fg', 'bg', 'animatic'],\n            ),\n            EnumDef(\n                \"productType\",\n                label=\"Product Type\",\n                tooltip=\"How the product will be used\",\n                items=['plate', 'take'],\n            ),\n            EnumDef(\n                \"reviewableSource\",\n                label=\"Reviewable Source\",\n                tooltip=\"Generate preview videos on fly, if \"\n                \"'&lt; none &gt;' is defined nothing will be generated.\",\n                items=[\n                    {\"value\": None, \"label\": \"&lt; none &gt;\"},\n                    {\"value\": \"clip_media\", \"label\": \"[ Clip's media ]\"},\n                ]\n                + gui_tracks,\n            ),\n            BoolDef(\n                \"export_audio\",\n                label=\"Include audio\",\n                tooltip=\"Process subsets with corresponding audio\",\n                default=False,\n            ),\n            BoolDef(\n                \"sourceResolution\",\n                label=\"Source resolution\",\n                tooltip=\"Is resolution taken from timeline or source?\",\n                default=False,\n            ),\n            # shotAttr\n            UILabelDef(\n                label=header_label(\"Shot Attributes\"),\n            ),\n            NumberDef(\n                \"workfileFrameStart\",\n                label=\"Workfiles Start Frame\",\n                tooltip=\"Set workfile starting frame number\",\n                default=presets.get(\"workfileFrameStart\", 1001),\n            ),\n            NumberDef(\n                \"handleStart\",\n                label=\"Handle start (head)\",\n                tooltip=\"Handle at start of clip\",\n                default=presets.get(\"handleStart\", 0),\n            ),\n            NumberDef(\n                \"handleEnd\",\n                label=\"Handle end (tail)\",\n                tooltip=\"Handle at end of clip\",\n                default=presets.get(\"handleEnd\", 0),\n            ),\n        ]\n\n    def create(self, subset_name, instance_data, pre_create_data):\n        super(CreateShotClip, self).create(subset_name,\n                                           instance_data,\n                                           pre_create_data)\n\n        if len(self.selected) &lt; 1:\n            return\n\n        self.log.info(self.selected)\n        self.log.debug(f\"Selected: {self.selected}\")\n\n        audio_clips = []\n        for audio_track in self.sequence.audioTracks():\n            audio_clips.extend(audio_track.items())\n\n        if not audio_clips and pre_create_data.get(\"export_audio\"):\n            raise CreatorError(\n                \"You must have audio in your active \"\n                \"timeline in order to export audio.\"\n            )\n\n        instance_data[\"task\"] = None\n\n        # sort selected trackItems by\n        sorted_selected_track_items = list()\n        unsorted_selected_track_items = list()\n        v_sync_track = pre_create_data.get(\"vSyncTrack\", \"\")\n        for _ti in self.selected:\n            if _ti.parent().name() in v_sync_track:\n                sorted_selected_track_items.append(_ti)\n            else:\n                unsorted_selected_track_items.append(_ti)\n\n        sorted_selected_track_items.extend(unsorted_selected_track_items)\n\n        shot_creator_id = \"io.ayon.creators.hiero.shot\"\n        audio_creator_id = \"io.ayon.creators.hiero.audio\"\n        plate_creator_id = \"io.ayon.creators.hiero.plate\"\n\n        # detect enabled creators for review, plate and audio\n        all_creators = {\n            shot_creator_id: True,\n            plate_creator_id: True,\n            audio_creator_id: True,\n        }\n\n        instances = []\n        all_shot_instances = {}\n        vertical_clip_match = {}\n        vertical_clip_used = {}\n\n        for idx, track_item in enumerate(sorted_selected_track_items):\n            _instance_data = copy.deepcopy(instance_data)\n            _instance_data[\"clip_index\"] = track_item.guid()\n\n            # convert track item to timeline media pool item\n            publish_clip = plugin.PublishClip(\n                track_item,\n                vertical_clip_match,\n                vertical_clip_used,\n                pre_create_data=pre_create_data,\n                rename_index=idx,\n                data=_instance_data,\n            )\n\n            track_item = publish_clip.convert()\n            if track_item is None:\n                # Ignore input clips that do not convert into a track item\n                # from `PublishClip.convert`\n                continue\n\n            self.log.info(\n                \"Processing track item data: {} (index: {})\".format(\n                    track_item, idx)\n            )\n            _instance_data.update(publish_clip.tag_data)\n\n            # Delete any existing instances previously generated for the clip.\n            prev_tag = lib.get_trackitem_ayon_tag(track_item)\n            if prev_tag:\n                prev_tag_data = tags.get_tag_data(prev_tag)\n                for creator_id, inst_data in prev_tag_data[_CONTENT_ID].items():\n                    creator = self.create_context.creators[creator_id]\n                    prev_instances = [\n                        inst for inst_id, inst\n                        in self.create_context.instances_by_id.items()\n                        if inst_id == inst_data[\"instance_id\"]\n                    ]\n                    creator.remove_instances(prev_instances)\n\n            # Create new product(s) instances.\n            shot_folder_path = _instance_data[\"folderPath\"]\n            shot_instances = all_shot_instances.setdefault(\n                shot_folder_path, {})\n\n            # desable shot creator if heroTrack is not enabled\n            all_creators[shot_creator_id] = _instance_data.get(\n                \"heroTrack\", False)\n            # desable audio creator if audio is not enabled\n            all_creators[audio_creator_id] = (\n                _instance_data.get(\"heroTrack\", False) and\n                pre_create_data.get(\"export_audio\", False)\n            )\n\n            enabled_creators = tuple(\n                cre for cre, enabled in all_creators.items() if enabled\n            )\n            clip_instances = {}\n            for creator_id in enabled_creators:\n                creator = self.create_context.creators[creator_id]\n                sub_instance_data = copy.deepcopy(_instance_data)\n                creator_attributes = sub_instance_data.setdefault(\n                    \"creator_attributes\", {})\n                shot_folder_path = sub_instance_data[\"folderPath\"]\n\n                # Shot creation\n                if creator_id == shot_creator_id:\n                    track_item_duration = track_item.duration()\n                    workfileFrameStart = \\\n                        sub_instance_data[\"workfileFrameStart\"]\n\n                    sub_instance_data.update(\n                        {\n                            \"variant\": \"main\",\n                            \"productType\": \"shot\",\n                            \"productName\": \"shotMain\",\n                            \"label\": (\n                                f\"{sub_instance_data['folderPath']} shotMain\"),\n                        }\n                    )\n                    creator_attributes.update(\n                        {\n                            \"workfileFrameStart\": sub_instance_data[\n                                \"workfileFrameStart\"\n                            ],\n                            \"handleStart\": sub_instance_data[\"handleStart\"],\n                            \"handleEnd\": sub_instance_data[\"handleEnd\"],\n                            \"frameStart\": workfileFrameStart,\n                            \"frameEnd\": (\n                                workfileFrameStart + track_item_duration),\n                            \"clipIn\": track_item.timelineIn(),\n                            \"clipOut\": track_item.timelineOut(),\n                            \"clipDuration\": track_item_duration,\n                            \"sourceIn\": track_item.sourceIn(),\n                            \"sourceOut\": track_item.sourceOut(),\n                        }\n                    )\n\n                # Plate, Audio\n                # insert parent instance data to allow\n                # metadata recollection as publish time.\n                elif creator_id == plate_creator_id:\n                    parenting_data = shot_instances[shot_creator_id]\n                    sub_instance_data.update({\n                        \"parent_instance_id\": parenting_data[\"instance_id\"],\n                        \"label\": (\n                            f\"{sub_instance_data['folderPath']} \"\n                            f\"{sub_instance_data['productName']}\"\n                        )\n                    })\n                    creator_attributes[\"parentInstance\"] = parenting_data[\n                        \"label\"]\n                    if sub_instance_data.get(\"reviewableSource\"):\n                        creator_attributes.update({\n                            \"review\": True,\n                            \"reviewableSource\": sub_instance_data[\n                                \"reviewableSource\"],\n                        })\n\n                elif creator_id == audio_creator_id:\n                    sub_instance_data[\"variant\"] = \"main\"\n                    sub_instance_data[\"productType\"] = \"audio\"\n                    sub_instance_data[\"productName\"] = \"audioMain\"\n\n                    parenting_data = shot_instances[shot_creator_id]\n                    sub_instance_data.update(\n                        {\n                            \"parent_instance_id\": parenting_data[\"instance_id\"],\n                            \"label\": (\n                                f\"{sub_instance_data['folderPath']} \"\n                                f\"{sub_instance_data['productName']}\"\n                            )\n                        }\n                    )\n                    creator_attributes[\"parentInstance\"] = parenting_data[\n                        \"label\"]\n\n                    if sub_instance_data.get(\"reviewableSource\"):\n                        creator_attributes[\"review\"] = True\n\n                instance = creator.create(sub_instance_data, None)\n                instance.transient_data[\"track_item\"] = track_item\n                self._add_instance_to_context(instance)\n                instance_data_to_store = instance.data_to_store()\n                shot_instances[creator_id] = instance_data_to_store\n                clip_instances[creator_id] = instance_data_to_store\n\n            lib.imprint(\n                track_item,\n                data={\n                    _CONTENT_ID: clip_instances,\n                    \"clip_index\": track_item.guid(),\n                }\n            )\n            instances.append(instance)\n\n        return instances\n\n    def _create_and_add_instance(self, data, creator_id,\n            track_item, instances):\n        \"\"\"\n        Args:\n            data (dict): The data to re-recreate the instance from.\n            creator_id (str): The creator id to use.\n            track_item (obj): The associated track item.\n            instances (list): Result instance container.\n\n        Returns:\n            CreatedInstance: The newly created instance.\n        \"\"\"\n        creator = self.create_context.creators[creator_id]\n        instance = creator.create(data, None)\n        instance.transient_data[\"track_item\"] = track_item\n        self._add_instance_to_context(instance)\n        instances.append(instance)\n        return instance\n\n    def _collect_legacy_instance(self, track_item):\n        \"\"\"Collect a legacy instance from previous creator if any.#\n\n        Args:\n            track_item (obj): The Hiero track_item to inspect.\n        \"\"\"\n        tag = lib.get_trackitem_ayon_tag(\n            track_item,\n            tag_name=constants.LEGACY_OPENPYPE_TAG_NAME,\n        )\n        if not tag:\n            return\n\n        data = tag.metadata()\n\n        clip_instances = {}\n        instance_data = {\n            \"clip_index\": track_item.guid(),\n            \"task\": None,\n            \"variant\": track_item.parentTrack().name(),\n            \"extract_audio\": False,\n        }\n        for create_attr in self.get_pre_create_attr_defs():\n            if isinstance(create_attr.key, str):\n                instance_data[create_attr.key] = create_attr.default\n\n        required_key_mapping = {\n            \"tag.audio\": (\"extract_audio\", bool),\n            \"tag.heroTrack\": (\"heroTrack\", bool),\n            \"tag.handleStart\": (\"handleStart\", int),\n            \"tag.handleEnd\": (\"handleEnd\", int),\n            \"tag.folderPath\": (\"folderPath\", str),\n            \"tag.reviewTrack\": (\"reviewableSource\", str),\n            \"tag.variant\": (\"variant\", str),\n            \"tag.workfileFrameStart\": (\"workfileFrameStart\", int),\n            \"tag.sourceResolution\": (\"sourceResolution\", bool),\n            \"tag.hierarchy\": (\"hierarchy\", str),\n            \"tag.hierarchyData\": (\"hierarchyData\", json),\n            \"tag.asset_name\": (\"folderName\", str),\n            \"tag.asset\": (\"productName\", str),\n            \"tag.active\": (\"active\", bool),\n            \"tag.productName\": (\"productName\", str),\n            \"tag.parents\": (\"parents\", json),\n        }\n\n        for key, value in required_key_mapping.items():\n            if key not in data:\n                continue\n\n            try:\n                instance_key, type_cast = value\n                if type_cast is bool:\n                    instance_data[instance_key] = data[key] == \"True\"\n                elif type_cast is json:\n                    conformed_data = data[key].replace(\"'\", \"\\\"\")\n                    conformed_data = conformed_data.replace('u\"', '\"')\n                    instance_data[instance_key] = json.loads(conformed_data)\n                else:\n                    instance_data[instance_key] = type_cast(data[key])\n\n            except Exception as error:\n                self.log.warning(\n                    \"Cannot retrieve instance from legacy \"\n                    f\"tag data: {error}.\"\n                )\n\n        if \"folderPath\" not in instance_data:\n            try:\n                instance_data[\"folderPath\"] = (\n                    \"/\" + instance_data[\"hierarchy\"] + \"/\" +\n                    instance_data[\"productName\"]\n                )\n            except KeyError:\n                instance_data[\"folderPath\"] = \"unknown\"\n                instance_data[\"active\"] = False\n\n        if \"tag.subset\" in data:\n            instance_data[\"variant\"] = data[\"tag.subset\"].replace(\"plate\", \"\")\n\n        for folder in instance_data.get(\"parents\", []):\n            if \"entity_name\" in folder:\n                folder[\"folder_name\"] = folder[\"entity_name\"]\n            if \"entity_type\" in folder:\n                folder[\"folder_type\"] = folder[\"entity_type\"]\n\n        # Create parent shot instance.\n        sub_instance_data = instance_data.copy()\n        track_item_duration = track_item.duration()\n        workfileFrameStart = \\\n            sub_instance_data[\"workfileFrameStart\"]\n        sub_instance_data.update({\n            \"label\": (\n                f\"{sub_instance_data['folderPath']} \"\n                f\"{sub_instance_data['productName']}\"),\n            \"variant\": \"main\",\n            \"creator_attributes\": {\n                \"workfileFrameStart\": workfileFrameStart,\n                \"handleStart\": sub_instance_data[\"handleStart\"],\n                \"handleEnd\": sub_instance_data[\"handleEnd\"],\n                \"frameStart\": workfileFrameStart,\n                \"frameEnd\": (workfileFrameStart +\n                    track_item_duration),\n                \"clipIn\": track_item.timelineIn(),\n                \"clipOut\": track_item.timelineOut(),\n                \"clipDuration\": track_item_duration,\n                \"sourceIn\": track_item.sourceIn(),\n                \"sourceOut\": track_item.sourceOut(),\n            }\n        })\n\n        shot_creator_id = \"io.ayon.creators.hiero.shot\"\n        creator = self.create_context.creators[shot_creator_id]\n        instance = creator.create(sub_instance_data, None)\n        instance.transient_data[\"track_item\"] = track_item\n        self._add_instance_to_context(instance)\n        clip_instances[shot_creator_id] = instance.data_to_store()\n        parenting_data = instance\n\n        # Create plate/audio instance\n        if instance_data[\"extract_audio\"]:\n            sub_creators = (\n                \"io.ayon.creators.hiero.plate\",\n                \"io.ayon.creators.hiero.audio\"\n            )\n        else:\n            sub_creators = (\"io.ayon.creators.hiero.plate\",)\n\n        for sub_creator_id in sub_creators:\n            sub_instance_data = instance_data.copy()\n            creator = self.create_context.creators[sub_creator_id]\n            sub_instance_data.update(\n                {\n                    \"parent_instance_id\": parenting_data[\"instance_id\"],\n                    \"label\": (\n                        f\"{sub_instance_data['folderPath']} \"\n                        f\"{sub_instance_data['productName']}\"\n                    ),\n                    \"creator_attributes\": {\n                        \"parentInstance\": parenting_data[\"label\"],\n                        \"reviewableSource\": sub_instance_data[\n                            \"reviewableSource\"],\n                        \"review\": False,\n                    }\n                }\n            )\n\n            instance = creator.create(sub_instance_data, None)\n            instance.transient_data[\"track_item\"] = track_item\n            self._add_instance_to_context(instance)\n            clip_instances[sub_creator_id] = instance.data_to_store()\n\n        # Adjust clip tag to match new publisher\n        track_item.removeTag(tag)\n        lib.imprint(\n            track_item,\n            data={\n                _CONTENT_ID: clip_instances,\n                \"clip_index\": track_item.guid(),\n            }\n        )\n\n    def collect_instances(self):\n        \"\"\"Collect all created instances from current timeline.\"\"\"\n        current_sequence = lib.get_current_sequence()\n        if current_sequence:\n            all_video_tracks = current_sequence.videoTracks()\n        else:\n            all_video_tracks = []\n\n        create_settings = self.project_settings[\"hiero\"][\"create\"]\n        collect_settings = create_settings.get(\"CollectShotClip\", {})\n        restrict_to_selection = collect_settings.get(\"collectSelectedInstance\", False)\n        current_selection = [\n            item for item in lib.get_timeline_selection()\n            if isinstance(item, hiero.core.TrackItem)  # get only clips\n        ]\n\n        self.log.debug(\n            \"Collect instances from timeline. \"\n            f\"restrict_to_selection setting: {restrict_to_selection} \"\n            f\"current_selection: {current_selection}\"\n        )\n\n        instances = []\n        for video_track in all_video_tracks:\n            for track_item in video_track:\n\n                # Should we restrict collection to selected item ?\n                # This might be convenient for heavy timelines and\n                # can be handled via creator settings.\n                # When nothing is selected, collect everything.\n                if (restrict_to_selection and current_selection\n                    and track_item not in current_selection):\n                    continue\n\n                # attempt to get AYON tag data\n                tag = lib.get_trackitem_ayon_tag(track_item)\n                if not tag:\n                    self._collect_legacy_instance(track_item)\n                    continue\n\n                tag_data = tags.get_tag_data(tag)\n                for creator_id, data in tag_data.get(_CONTENT_ID, {}).items():\n                    self._create_and_add_instance(\n                        data, creator_id, track_item, instances)\n\n        if restrict_to_selection:\n            # Ensure that parent shot instance are enabled.\n            # This can happen when vertical_align is enabled\n            # but hero track is not part of the collected clips.\n            all_shot_ids = [inst.id for inst in instances if inst.data[\"productType\"] == \"shot\"]\n\n            for inst in instances:\n                if inst.id in all_shot_ids:\n                    continue\n\n                elif inst.data[\"active\"] and inst.data[\"parent_instance_id\"] not in all_shot_ids:\n                    raise CreatorError(\n                        \"Incomplete selection: please select hero track\"\n                        f' for {inst.data[\"label\"]} instance.'\n                    )\n\n        return instances\n\n    def update_instances(self, update_list):\n        \"\"\"Never called, update is handled via _HieroInstanceCreator.\"\"\"\n        pass\n\n    def remove_instances(self, instances):\n        \"\"\"Never called, update is handled via _HieroInstanceCreator.\"\"\"\n        pass\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/plugins/create/create_shot_clip.html#client.ayon_hiero.plugins.create.create_shot_clip.CreateShotClip.collect_instances","title":"<code>collect_instances()</code>","text":"<p>Collect all created instances from current timeline.</p> Source code in <code>client/ayon_hiero/plugins/create/create_shot_clip.py</code> <pre><code>def collect_instances(self):\n    \"\"\"Collect all created instances from current timeline.\"\"\"\n    current_sequence = lib.get_current_sequence()\n    if current_sequence:\n        all_video_tracks = current_sequence.videoTracks()\n    else:\n        all_video_tracks = []\n\n    create_settings = self.project_settings[\"hiero\"][\"create\"]\n    collect_settings = create_settings.get(\"CollectShotClip\", {})\n    restrict_to_selection = collect_settings.get(\"collectSelectedInstance\", False)\n    current_selection = [\n        item for item in lib.get_timeline_selection()\n        if isinstance(item, hiero.core.TrackItem)  # get only clips\n    ]\n\n    self.log.debug(\n        \"Collect instances from timeline. \"\n        f\"restrict_to_selection setting: {restrict_to_selection} \"\n        f\"current_selection: {current_selection}\"\n    )\n\n    instances = []\n    for video_track in all_video_tracks:\n        for track_item in video_track:\n\n            # Should we restrict collection to selected item ?\n            # This might be convenient for heavy timelines and\n            # can be handled via creator settings.\n            # When nothing is selected, collect everything.\n            if (restrict_to_selection and current_selection\n                and track_item not in current_selection):\n                continue\n\n            # attempt to get AYON tag data\n            tag = lib.get_trackitem_ayon_tag(track_item)\n            if not tag:\n                self._collect_legacy_instance(track_item)\n                continue\n\n            tag_data = tags.get_tag_data(tag)\n            for creator_id, data in tag_data.get(_CONTENT_ID, {}).items():\n                self._create_and_add_instance(\n                    data, creator_id, track_item, instances)\n\n    if restrict_to_selection:\n        # Ensure that parent shot instance are enabled.\n        # This can happen when vertical_align is enabled\n        # but hero track is not part of the collected clips.\n        all_shot_ids = [inst.id for inst in instances if inst.data[\"productType\"] == \"shot\"]\n\n        for inst in instances:\n            if inst.id in all_shot_ids:\n                continue\n\n            elif inst.data[\"active\"] and inst.data[\"parent_instance_id\"] not in all_shot_ids:\n                raise CreatorError(\n                    \"Incomplete selection: please select hero track\"\n                    f' for {inst.data[\"label\"]} instance.'\n                )\n\n    return instances\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/plugins/create/create_shot_clip.html#client.ayon_hiero.plugins.create.create_shot_clip.CreateShotClip.remove_instances","title":"<code>remove_instances(instances)</code>","text":"<p>Never called, update is handled via _HieroInstanceCreator.</p> Source code in <code>client/ayon_hiero/plugins/create/create_shot_clip.py</code> <pre><code>def remove_instances(self, instances):\n    \"\"\"Never called, update is handled via _HieroInstanceCreator.\"\"\"\n    pass\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/plugins/create/create_shot_clip.html#client.ayon_hiero.plugins.create.create_shot_clip.CreateShotClip.update_instances","title":"<code>update_instances(update_list)</code>","text":"<p>Never called, update is handled via _HieroInstanceCreator.</p> Source code in <code>client/ayon_hiero/plugins/create/create_shot_clip.py</code> <pre><code>def update_instances(self, update_list):\n    \"\"\"Never called, update is handled via _HieroInstanceCreator.\"\"\"\n    pass\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/plugins/create/create_shot_clip.html#client.ayon_hiero.plugins.create.create_shot_clip.EditorialAudioInstanceCreator","title":"<code>EditorialAudioInstanceCreator</code>","text":"<p>               Bases: <code>_HieroInstanceClipCreatorBase</code></p> <p>Audio product type creator class</p> Source code in <code>client/ayon_hiero/plugins/create/create_shot_clip.py</code> <pre><code>class EditorialAudioInstanceCreator(_HieroInstanceClipCreatorBase):\n    \"\"\"Audio product type creator class\"\"\"\n    identifier = \"io.ayon.creators.hiero.audio\"\n    product_type = \"audio\"\n    label = \"Editorial Audio\"\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/plugins/create/create_shot_clip.html#client.ayon_hiero.plugins.create.create_shot_clip.EditorialPlateInstanceCreator","title":"<code>EditorialPlateInstanceCreator</code>","text":"<p>               Bases: <code>_HieroInstanceClipCreatorBase</code></p> <p>Plate product type creator class</p> Source code in <code>client/ayon_hiero/plugins/create/create_shot_clip.py</code> <pre><code>class EditorialPlateInstanceCreator(_HieroInstanceClipCreatorBase):\n    \"\"\"Plate product type creator class\"\"\"\n    identifier = \"io.ayon.creators.hiero.plate\"\n    product_type = \"plate\"\n    label = \"Editorial Plate\"\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/plugins/create/create_shot_clip.html#client.ayon_hiero.plugins.create.create_shot_clip.HieroShotInstanceCreator","title":"<code>HieroShotInstanceCreator</code>","text":"<p>               Bases: <code>_HieroInstanceCreator</code></p> <p>Shot product type creator class</p> Source code in <code>client/ayon_hiero/plugins/create/create_shot_clip.py</code> <pre><code>class HieroShotInstanceCreator(_HieroInstanceCreator):\n    \"\"\"Shot product type creator class\"\"\"\n    identifier = \"io.ayon.creators.hiero.shot\"\n    product_type = \"shot\"\n    label = \"Editorial Shot\"\n\n    def get_instance_attr_defs(self):\n        instance_attributes = CLIP_ATTR_DEFS\n        return instance_attributes\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/plugins/create/create_workfile.html","title":"create_workfile","text":"<p>Creator plugin for creating workfiles.</p>"},{"location":"autoapi/client/ayon_hiero/plugins/create/create_workfile.html#client.ayon_hiero.plugins.create.create_workfile.CreateWorkfile","title":"<code>CreateWorkfile</code>","text":"<p>               Bases: <code>AutoCreator</code></p> <p>Workfile auto-creator.</p> Source code in <code>client/ayon_hiero/plugins/create/create_workfile.py</code> <pre><code>class CreateWorkfile(AutoCreator):\n    \"\"\"Workfile auto-creator.\"\"\"\n    settings_category = \"hiero\"\n\n    identifier = \"io.ayon.creators.hiero.workfile\"\n    label = \"Workfile\"\n    product_type = \"workfile\"\n    icon = \"fa5.file\"\n\n    default_variant = \"Main\"\n\n    @classmethod\n    def dump_instance_data(cls, data):\n        \"\"\" Dump instance data into AyonData project tag.\n\n        Args:\n            data (dict): The data to push to the project tag.\n        \"\"\"\n        project_tag = tags.get_or_create_workfile_tag(create=True)\n\n        tag_data = {\n            \"metadata\": data,\n            \"note\": \"AYON workfile data\"\n        }\n        tags.update_tag(project_tag, tag_data)\n\n    def load_instance_data(cls):\n        \"\"\" Returns the data stored in AyonData project tag if any.\n\n        Returns:\n            dict. The project data.\n        \"\"\"\n        project_tag = tags.get_or_create_workfile_tag()\n        if project_tag is None:\n            return {}\n\n        instance_data = tags.get_tag_data(project_tag)\n        return instance_data\n\n    def _create_new_instance(self):\n        \"\"\"Create a new workfile instance.\n\n        Returns:\n            dict. The data of the instance to be created.\n        \"\"\"\n        project_name = self.create_context.get_current_project_name()\n        folder_path = self.create_context.get_current_folder_path()\n        task_name = self.create_context.get_current_task_name()\n        host_name = self.create_context.host_name\n        variant = self.default_variant\n\n        folder_entity = self.create_context.get_current_folder_entity()\n        task_entity = self.create_context.get_current_task_entity()\n\n        product_name = self.get_product_name(\n            project_name,\n            folder_entity,\n            task_entity,\n            variant,\n            host_name,\n        )\n\n        instance_data = {\n            \"folderPath\": folder_path,\n            \"task\": task_name,\n            \"variant\": variant,\n            \"productName\": product_name,\n        }\n        instance_data.update(self.get_dynamic_data(\n            variant,\n            task_name,\n            folder_entity,\n            project_name,\n            host_name,\n            False,\n        ))\n\n        return instance_data\n\n    def create(self, options=None):\n        \"\"\"Auto-create an instance by default.\"\"\"\n        instance_data = self.load_instance_data()\n        if instance_data:\n            return\n\n        self.log.info(\"Auto-creating workfile instance...\")\n        data = self._create_new_instance()\n        current_instance = CreatedInstance(\n            self.product_type, data[\"productName\"], data, self)\n        self._add_instance_to_context(current_instance)\n\n    def collect_instances(self):\n        \"\"\"Collect from timeline marker or create a new one.\"\"\"\n        data = self.load_instance_data()\n        if not data:\n            return\n\n        instance = CreatedInstance(\n            self.product_type, data[\"productName\"], data, self\n        )\n        self._add_instance_to_context(instance)\n\n    def update_instances(self, update_list):\n        \"\"\"Store changes in project metadata so they can be recollected.\n\n        Args:\n            update_list(List[UpdateData]): Gets list of tuples. Each item\n                contain changed instance and its changes.\n        \"\"\"\n        for created_inst, _ in update_list:\n            data = created_inst.data_to_store()\n            self.dump_instance_data(data)\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/plugins/create/create_workfile.html#client.ayon_hiero.plugins.create.create_workfile.CreateWorkfile.collect_instances","title":"<code>collect_instances()</code>","text":"<p>Collect from timeline marker or create a new one.</p> Source code in <code>client/ayon_hiero/plugins/create/create_workfile.py</code> <pre><code>def collect_instances(self):\n    \"\"\"Collect from timeline marker or create a new one.\"\"\"\n    data = self.load_instance_data()\n    if not data:\n        return\n\n    instance = CreatedInstance(\n        self.product_type, data[\"productName\"], data, self\n    )\n    self._add_instance_to_context(instance)\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/plugins/create/create_workfile.html#client.ayon_hiero.plugins.create.create_workfile.CreateWorkfile.create","title":"<code>create(options=None)</code>","text":"<p>Auto-create an instance by default.</p> Source code in <code>client/ayon_hiero/plugins/create/create_workfile.py</code> <pre><code>def create(self, options=None):\n    \"\"\"Auto-create an instance by default.\"\"\"\n    instance_data = self.load_instance_data()\n    if instance_data:\n        return\n\n    self.log.info(\"Auto-creating workfile instance...\")\n    data = self._create_new_instance()\n    current_instance = CreatedInstance(\n        self.product_type, data[\"productName\"], data, self)\n    self._add_instance_to_context(current_instance)\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/plugins/create/create_workfile.html#client.ayon_hiero.plugins.create.create_workfile.CreateWorkfile.dump_instance_data","title":"<code>dump_instance_data(data)</code>  <code>classmethod</code>","text":"<p>Dump instance data into AyonData project tag.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>The data to push to the project tag.</p> required Source code in <code>client/ayon_hiero/plugins/create/create_workfile.py</code> <pre><code>@classmethod\ndef dump_instance_data(cls, data):\n    \"\"\" Dump instance data into AyonData project tag.\n\n    Args:\n        data (dict): The data to push to the project tag.\n    \"\"\"\n    project_tag = tags.get_or_create_workfile_tag(create=True)\n\n    tag_data = {\n        \"metadata\": data,\n        \"note\": \"AYON workfile data\"\n    }\n    tags.update_tag(project_tag, tag_data)\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/plugins/create/create_workfile.html#client.ayon_hiero.plugins.create.create_workfile.CreateWorkfile.load_instance_data","title":"<code>load_instance_data()</code>","text":"<p>Returns the data stored in AyonData project tag if any.</p> <p>Returns:</p> Type Description <p>dict. The project data.</p> Source code in <code>client/ayon_hiero/plugins/create/create_workfile.py</code> <pre><code>def load_instance_data(cls):\n    \"\"\" Returns the data stored in AyonData project tag if any.\n\n    Returns:\n        dict. The project data.\n    \"\"\"\n    project_tag = tags.get_or_create_workfile_tag()\n    if project_tag is None:\n        return {}\n\n    instance_data = tags.get_tag_data(project_tag)\n    return instance_data\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/plugins/create/create_workfile.html#client.ayon_hiero.plugins.create.create_workfile.CreateWorkfile.update_instances","title":"<code>update_instances(update_list)</code>","text":"<p>Store changes in project metadata so they can be recollected.</p> <p>Parameters:</p> Name Type Description Default <code>update_list(List[UpdateData])</code> <p>Gets list of tuples. Each item contain changed instance and its changes.</p> required Source code in <code>client/ayon_hiero/plugins/create/create_workfile.py</code> <pre><code>def update_instances(self, update_list):\n    \"\"\"Store changes in project metadata so they can be recollected.\n\n    Args:\n        update_list(List[UpdateData]): Gets list of tuples. Each item\n            contain changed instance and its changes.\n    \"\"\"\n    for created_inst, _ in update_list:\n        data = created_inst.data_to_store()\n        self.dump_instance_data(data)\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/plugins/load/index.html","title":"load","text":""},{"location":"autoapi/client/ayon_hiero/plugins/load/load_clip.html","title":"load_clip","text":""},{"location":"autoapi/client/ayon_hiero/plugins/load/load_clip.html#client.ayon_hiero.plugins.load.load_clip.LoadClip","title":"<code>LoadClip</code>","text":"<p>               Bases: <code>SequenceLoader</code></p> <p>Load a product to timeline as clip</p> <p>Place clip to timeline on its asset origin timings collected during conforming to project</p> Source code in <code>client/ayon_hiero/plugins/load/load_clip.py</code> <pre><code>class LoadClip(phiero.SequenceLoader):\n    \"\"\"Load a product to timeline as clip\n\n    Place clip to timeline on its asset origin timings collected\n    during conforming to project\n    \"\"\"\n\n    product_types = {\"render2d\", \"source\", \"plate\", \"render\", \"review\"}\n    representations = {\"*\"}\n    extensions = set(\n        ext.lstrip(\".\") for ext in IMAGE_EXTENSIONS.union(VIDEO_EXTENSIONS)\n    )\n\n    label = \"Load as clip\"\n    order = -10\n    icon = \"code-fork\"\n    color = \"orange\"\n\n    # for loader multiselection\n    sequence = None\n    track = None\n\n    # presets\n    clip_color_last = \"green\"\n    clip_color = \"red\"\n\n    clip_name_template = \"{asset}_{subset}_{representation}\"\n\n    @classmethod\n    def apply_settings(cls, project_settings):\n        plugin_type_settings = (\n            project_settings\n            .get(\"hiero\", {})\n            .get(\"load\", {})\n        )\n\n        if not plugin_type_settings:\n            return\n\n        plugin_name = cls.__name__\n\n        # Look for plugin settings in host specific settings\n        plugin_settings = plugin_type_settings.get(plugin_name)\n        if not plugin_settings:\n            return\n\n        print(\"&gt;&gt;&gt; We have preset for {}\".format(plugin_name))\n        for option, value in plugin_settings.items():\n            if option == \"representations\":\n                continue\n\n            if option == \"clip_name_template\":\n                # TODO remove the formatting replacement\n                value = (\n                    value\n                    .replace(\"{folder[name]}\", \"{asset}\")\n                    .replace(\"{product[name]}\", \"{subset}\")\n                )\n\n            if option == \"enabled\" and value is False:\n                print(\"  - is disabled by preset\")\n            else:\n                print(\"  - setting `{}`: `{}`\".format(option, value))\n            setattr(cls, option, value)\n\n    def load(self, context, name, namespace, options):\n        # add clip name template to options\n        options.update({\n            \"clipNameTemplate\": self.clip_name_template\n        })\n        # in case loader uses multiselection\n        if self.track and self.sequence:\n            options.update({\n                \"sequence\": self.sequence,\n                \"track\": self.track,\n                \"clipNameTemplate\": self.clip_name_template\n            })\n\n        # load clip to timeline and get main variables\n        path = self.filepath_from_context(context)\n        track_item = phiero.ClipLoader(self, context, path, **options).load()\n        namespace = namespace or track_item.name()\n        version_entity = context[\"version\"]\n        version_attributes = version_entity[\"attrib\"]\n        version_name = version_entity[\"version\"]\n        colorspace = version_attributes.get(\"colorSpace\")\n        object_name = self.clip_name_template.format(\n            **context[\"representation\"][\"context\"])\n\n        # set colorspace\n        if colorspace:\n            track_item.source().setSourceMediaColourTransform(colorspace)\n\n        # add additional metadata from the version to imprint Avalon knob\n        add_keys = [\n            \"frameStart\", \"frameEnd\", \"source\", \"author\",\n            \"fps\", \"handleStart\", \"handleEnd\"\n        ]\n\n        # move all version data keys to tag data\n        data_imprint = {\n            key: version_attributes.get(key, str(None))\n            for key in add_keys\n\n        }\n\n        # add variables related to version context\n        data_imprint.update({\n            \"version\": version_name,\n            \"colorspace\": colorspace,\n            \"objectName\": object_name\n        })\n\n        # update color of clip regarding the version order\n        self.set_item_color(\n            context[\"project\"][\"name\"], track_item, version_entity\n        )\n\n        # deal with multiselection\n        self.multiselection(track_item)\n\n        self.log.info(\"Loader done: `{}`\".format(name))\n\n        return phiero.containerise(\n            track_item,\n            name, namespace, context,\n            self.__class__.__name__,\n            data_imprint)\n\n    def switch(self, container, context):\n        self.update(container, context)\n\n    def update(self, container, context):\n        \"\"\" Updating previously loaded clips\n        \"\"\"\n        version_entity = context[\"version\"]\n        repre_entity = context[\"representation\"]\n\n        # load clip to timeline and get main variables\n        name = container[\"name\"]\n        namespace = container[\"namespace\"]\n        track_item = phiero.get_track_items(\n            track_item_name=namespace).pop()\n\n        version_attributes = version_entity[\"attrib\"]\n        version_name = version_entity[\"version\"]\n        colorspace = version_attributes.get(\"colorSpace\")\n        object_name = \"{}_{}\".format(name, namespace)\n\n        file = get_representation_path(repre_entity).replace(\"\\\\\", \"/\")\n        clip = track_item.source()\n\n        # reconnect media to new path\n        clip.reconnectMedia(file)\n\n        # set colorspace\n        if colorspace:\n            clip.setSourceMediaColourTransform(colorspace)\n\n        # add additional metadata from the version to imprint metadata knob\n\n        # move all version data keys to tag data\n        data_imprint = {}\n        for key in [\n            \"frameStart\",\n            \"frameEnd\",\n            \"source\",\n            \"author\",\n            \"fps\",\n            \"handleStart\",\n            \"handleEnd\",\n        ]:\n            data_imprint.update({\n                key: version_attributes.get(key, str(None))\n            })\n\n        # add variables related to version context\n        data_imprint.update({\n            \"representation\": repre_entity[\"id\"],\n            \"version\": version_name,\n            \"colorspace\": colorspace,\n            \"objectName\": object_name\n        })\n\n        # update color of clip regarding the version order\n        self.set_item_color(\n            context[\"project\"][\"name\"], track_item, version_entity\n        )\n\n        return phiero.update_container(track_item, data_imprint)\n\n    def remove(self, container):\n        \"\"\" Removing previously loaded clips\n        \"\"\"\n        # load clip to timeline and get main variables\n        namespace = container['namespace']\n        track_item = phiero.get_track_items(\n            track_item_name=namespace).pop()\n        track = track_item.parent()\n\n        # remove track item from track\n        track.removeItem(track_item)\n\n    @classmethod\n    def multiselection(cls, track_item):\n        if not cls.track:\n            cls.track = track_item.parent()\n            cls.sequence = cls.track.parent()\n\n    @classmethod\n    def set_item_color(cls, project_name, track_item, version_entity):\n        last_version_entity = ayon_api.get_last_version_by_product_id(\n            project_name, version_entity[\"productId\"], fields={\"id\"}\n        )\n        clip = track_item.source()\n        # set clip colour\n        if version_entity[\"id\"] == last_version_entity[\"id\"]:\n            clip.binItem().setColor(cls.clip_color_last)\n        else:\n            clip.binItem().setColor(cls.clip_color)\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/plugins/load/load_clip.html#client.ayon_hiero.plugins.load.load_clip.LoadClip.remove","title":"<code>remove(container)</code>","text":"<p>Removing previously loaded clips</p> Source code in <code>client/ayon_hiero/plugins/load/load_clip.py</code> <pre><code>def remove(self, container):\n    \"\"\" Removing previously loaded clips\n    \"\"\"\n    # load clip to timeline and get main variables\n    namespace = container['namespace']\n    track_item = phiero.get_track_items(\n        track_item_name=namespace).pop()\n    track = track_item.parent()\n\n    # remove track item from track\n    track.removeItem(track_item)\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/plugins/load/load_clip.html#client.ayon_hiero.plugins.load.load_clip.LoadClip.update","title":"<code>update(container, context)</code>","text":"<p>Updating previously loaded clips</p> Source code in <code>client/ayon_hiero/plugins/load/load_clip.py</code> <pre><code>def update(self, container, context):\n    \"\"\" Updating previously loaded clips\n    \"\"\"\n    version_entity = context[\"version\"]\n    repre_entity = context[\"representation\"]\n\n    # load clip to timeline and get main variables\n    name = container[\"name\"]\n    namespace = container[\"namespace\"]\n    track_item = phiero.get_track_items(\n        track_item_name=namespace).pop()\n\n    version_attributes = version_entity[\"attrib\"]\n    version_name = version_entity[\"version\"]\n    colorspace = version_attributes.get(\"colorSpace\")\n    object_name = \"{}_{}\".format(name, namespace)\n\n    file = get_representation_path(repre_entity).replace(\"\\\\\", \"/\")\n    clip = track_item.source()\n\n    # reconnect media to new path\n    clip.reconnectMedia(file)\n\n    # set colorspace\n    if colorspace:\n        clip.setSourceMediaColourTransform(colorspace)\n\n    # add additional metadata from the version to imprint metadata knob\n\n    # move all version data keys to tag data\n    data_imprint = {}\n    for key in [\n        \"frameStart\",\n        \"frameEnd\",\n        \"source\",\n        \"author\",\n        \"fps\",\n        \"handleStart\",\n        \"handleEnd\",\n    ]:\n        data_imprint.update({\n            key: version_attributes.get(key, str(None))\n        })\n\n    # add variables related to version context\n    data_imprint.update({\n        \"representation\": repre_entity[\"id\"],\n        \"version\": version_name,\n        \"colorspace\": colorspace,\n        \"objectName\": object_name\n    })\n\n    # update color of clip regarding the version order\n    self.set_item_color(\n        context[\"project\"][\"name\"], track_item, version_entity\n    )\n\n    return phiero.update_container(track_item, data_imprint)\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/plugins/load/load_effects.html","title":"load_effects","text":""},{"location":"autoapi/client/ayon_hiero/plugins/load/load_effects.html#client.ayon_hiero.plugins.load.load_effects.LoadEffects","title":"<code>LoadEffects</code>","text":"<p>               Bases: <code>LoaderPlugin</code></p> <p>Loading colorspace soft effect exported from nukestudio</p> Source code in <code>client/ayon_hiero/plugins/load/load_effects.py</code> <pre><code>class LoadEffects(load.LoaderPlugin):\n    \"\"\"Loading colorspace soft effect exported from nukestudio\"\"\"\n\n    product_types = {\"effect\"}\n    representations = {\"*\"}\n    extension = {\"json\"}\n\n    label = \"Load Effects\"\n    order = 0\n    icon = \"cc\"\n    color = \"white\"\n\n    log = Logger.get_logger(__name__)\n\n    def load(self, context, name, namespace, data):\n        \"\"\"\n        Loading function to get the soft effects to particular read node\n\n        Arguments:\n            context (dict): context of version\n            name (str): name of the version\n            namespace (str): Folder name.\n            data (dict): compulsory attribute &gt; not used\n\n        Returns:\n            nuke node: containerised nuke node object\n        \"\"\"\n        active_sequence = phiero.get_current_sequence()\n        active_track = phiero.get_current_track(\n            active_sequence, \"Loaded_{}\".format(name))\n\n        # get main variables\n        namespace = namespace or context[\"folder\"][\"name\"]\n        object_name = \"{}_{}\".format(name, namespace)\n        clip_in = context[\"folder\"][\"attrib\"][\"clipIn\"]\n        clip_out = context[\"folder\"][\"attrib\"][\"clipOut\"]\n\n        data_imprint = {\n            \"objectName\": object_name,\n            \"children_names\": []\n        }\n\n        # getting file path\n        file = self.filepath_from_context(context)\n        file = file.replace(\"\\\\\", \"/\")\n\n        if self._shared_loading(\n            file,\n            active_track,\n            clip_in,\n            clip_out,\n            data_imprint\n        ):\n            self.containerise(\n                active_track,\n                name=name,\n                namespace=namespace,\n                object_name=object_name,\n                context=context,\n                loader=self.__class__.__name__,\n                data=data_imprint)\n\n    def _shared_loading(\n        self,\n        file,\n        active_track,\n        clip_in,\n        clip_out,\n        data_imprint,\n        update=False\n    ):\n        # getting data from json file with unicode conversion\n        with open(file, \"r\") as f:\n            json_f = {self.byteify(key): self.byteify(value)\n                      for key, value in json.load(f).items()}\n\n        # get correct order of nodes by positions on track and subtrack\n        nodes_order = self.reorder_nodes(json_f)\n\n        used_subtracks = {\n            stitem.name(): stitem\n            for stitem in phiero.flatten(active_track.subTrackItems())\n        }\n\n        loaded = False\n        for index_order, (ef_name, ef_val) in enumerate(nodes_order.items()):\n            new_name = \"{}_loaded\".format(ef_name)\n            if new_name not in used_subtracks:\n                effect_track_item = active_track.createEffect(\n                    effectType=ef_val[\"class\"],\n                    timelineIn=clip_in,\n                    timelineOut=clip_out,\n                    subTrackIndex=index_order\n\n                )\n                effect_track_item.setName(new_name)\n            else:\n                effect_track_item = used_subtracks[new_name]\n\n            node = effect_track_item.node()\n            for knob_name, knob_value in ef_val[\"node\"].items():\n                if (\n                    not knob_value\n                    or knob_name == \"name\"\n                ):\n                    continue\n\n                try:\n                    # assume list means animation\n                    # except 4 values could be RGBA or vector\n                    if isinstance(knob_value, list) and len(knob_value) &gt; 4:\n                        node[knob_name].setAnimated()\n                        for i, value in enumerate(knob_value):\n                            if isinstance(value, list):\n                                # list can have vector animation\n                                for ci, cv in enumerate(value):\n                                    node[knob_name].setValueAt(\n                                        cv,\n                                        (clip_in + i),\n                                        ci\n                                    )\n                            else:\n                                # list is single values\n                                node[knob_name].setValueAt(\n                                    value,\n                                    (clip_in + i)\n                                )\n                    else:\n                        node[knob_name].setValue(knob_value)\n                except NameError:\n                    self.log.warning(\"Knob: {} cannot be set\".format(\n                        knob_name))\n\n            # register all loaded children\n            data_imprint[\"children_names\"].append(new_name)\n\n            # make sure containerisation will happen\n            loaded = True\n\n        return loaded\n\n    def update(self, container, context):\n        \"\"\" Updating previously loaded effects\n        \"\"\"\n        version_entity = context[\"version\"]\n        repre_entity = context[\"representation\"]\n        active_track = container[\"_item\"]\n        file = get_representation_path(repre_entity).replace(\"\\\\\", \"/\")\n\n        # get main variables\n        name = container['name']\n        namespace = container['namespace']\n\n        # get timeline in out data\n        version_attributes = version_entity[\"attrib\"]\n        clip_in = version_attributes[\"clipIn\"]\n        clip_out = version_attributes[\"clipOut\"]\n\n        object_name = \"{}_{}\".format(name, namespace)\n\n        # Disable previously created nodes\n        used_subtracks = {\n            stitem.name(): stitem\n            for stitem in phiero.flatten(active_track.subTrackItems())\n        }\n        container = phiero.get_track_ayon_data(\n            active_track, object_name\n        )\n\n        loaded_subtrack_items = container[\"children_names\"]\n        for loaded_stitem in loaded_subtrack_items:\n            if loaded_stitem not in used_subtracks:\n                continue\n            item_to_remove = used_subtracks.pop(loaded_stitem)\n            # TODO: find a way to erase nodes\n            self.log.debug(\n                \"This node needs to be removed: {}\".format(item_to_remove))\n\n        data_imprint = {\n            \"objectName\": object_name,\n            \"name\": name,\n            \"representation\": repre_entity[\"id\"],\n            \"children_names\": []\n        }\n\n        if self._shared_loading(\n            file,\n            active_track,\n            clip_in,\n            clip_out,\n            data_imprint,\n            update=True\n        ):\n            return phiero.update_container(active_track, data_imprint)\n\n    def reorder_nodes(self, data):\n        new_order = OrderedDict()\n        trackNums = [v[\"trackIndex\"] for k, v in data.items()\n                     if isinstance(v, dict)]\n        subTrackNums = [v[\"subTrackIndex\"] for k, v in data.items()\n                        if isinstance(v, dict)]\n\n        for trackIndex in range(\n                min(trackNums), max(trackNums) + 1):\n            for subTrackIndex in range(\n                    min(subTrackNums), max(subTrackNums) + 1):\n                item = self.get_item(data, trackIndex, subTrackIndex)\n                if item:\n                    new_order.update(item)\n        return new_order\n\n    def get_item(self, data, trackIndex, subTrackIndex):\n        return {key: val for key, val in data.items()\n                if isinstance(val, dict)\n                if subTrackIndex == val[\"subTrackIndex\"]\n                if trackIndex == val[\"trackIndex\"]}\n\n    def byteify(self, input):\n        \"\"\"\n        Converts unicode strings to strings\n        It goes through all dictionary\n\n        Arguments:\n            input (dict/str): input\n\n        Returns:\n            dict: with fixed values and keys\n\n        \"\"\"\n\n        if isinstance(input, dict):\n            return {self.byteify(key): self.byteify(value)\n                    for key, value in input.items()}\n        elif isinstance(input, list):\n            return [self.byteify(element) for element in input]\n        elif isinstance(input, str):\n            return str(input)\n        else:\n            return input\n\n    def switch(self, container, context):\n        self.update(container, context)\n\n    def remove(self, container):\n        pass\n\n    def containerise(\n        self,\n        track,\n        name,\n        namespace,\n        object_name,\n        context,\n        loader=None,\n        data=None\n    ):\n        \"\"\"Bundle Hiero's object into an assembly and imprint it with metadata\n\n        Containerisation enables a tracking of version, author and origin\n        for loaded assets.\n\n        Arguments:\n            track (hiero.core.VideoTrack): object to imprint as container\n            name (str): Name of resulting assembly\n            namespace (str): Namespace under which to host container\n            object_name (str): name of container\n            context (dict): Asset information\n            loader (str, optional): Name of node used to produce this\n                                    container.\n\n        Returns:\n            track_item (hiero.core.TrackItem): containerised object\n\n        \"\"\"\n\n        data_imprint = {\n            object_name: {\n                \"schema\": \"ayon:container-2.0\",\n                \"id\": AVALON_CONTAINER_ID,\n                \"name\": str(name),\n                \"namespace\": str(namespace),\n                \"loader\": str(loader),\n                \"representation\": context[\"representation\"][\"id\"],\n            }\n        }\n\n        if data:\n            for k, v in data.items():\n                data_imprint[object_name].update({k: v})\n\n        self.log.debug(\"_ data_imprint: {}\".format(data_imprint))\n        phiero.set_track_ayon_tag(track, data_imprint)\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/plugins/load/load_effects.html#client.ayon_hiero.plugins.load.load_effects.LoadEffects.byteify","title":"<code>byteify(input)</code>","text":"<p>Converts unicode strings to strings It goes through all dictionary</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>dict / str</code> <p>input</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>with fixed values and keys</p> Source code in <code>client/ayon_hiero/plugins/load/load_effects.py</code> <pre><code>def byteify(self, input):\n    \"\"\"\n    Converts unicode strings to strings\n    It goes through all dictionary\n\n    Arguments:\n        input (dict/str): input\n\n    Returns:\n        dict: with fixed values and keys\n\n    \"\"\"\n\n    if isinstance(input, dict):\n        return {self.byteify(key): self.byteify(value)\n                for key, value in input.items()}\n    elif isinstance(input, list):\n        return [self.byteify(element) for element in input]\n    elif isinstance(input, str):\n        return str(input)\n    else:\n        return input\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/plugins/load/load_effects.html#client.ayon_hiero.plugins.load.load_effects.LoadEffects.containerise","title":"<code>containerise(track, name, namespace, object_name, context, loader=None, data=None)</code>","text":"<p>Bundle Hiero's object into an assembly and imprint it with metadata</p> <p>Containerisation enables a tracking of version, author and origin for loaded assets.</p> <p>Parameters:</p> Name Type Description Default <code>track</code> <code>VideoTrack</code> <p>object to imprint as container</p> required <code>name</code> <code>str</code> <p>Name of resulting assembly</p> required <code>namespace</code> <code>str</code> <p>Namespace under which to host container</p> required <code>object_name</code> <code>str</code> <p>name of container</p> required <code>context</code> <code>dict</code> <p>Asset information</p> required <code>loader</code> <code>str</code> <p>Name of node used to produce this                     container.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>track_item</code> <code>TrackItem</code> <p>containerised object</p> Source code in <code>client/ayon_hiero/plugins/load/load_effects.py</code> <pre><code>def containerise(\n    self,\n    track,\n    name,\n    namespace,\n    object_name,\n    context,\n    loader=None,\n    data=None\n):\n    \"\"\"Bundle Hiero's object into an assembly and imprint it with metadata\n\n    Containerisation enables a tracking of version, author and origin\n    for loaded assets.\n\n    Arguments:\n        track (hiero.core.VideoTrack): object to imprint as container\n        name (str): Name of resulting assembly\n        namespace (str): Namespace under which to host container\n        object_name (str): name of container\n        context (dict): Asset information\n        loader (str, optional): Name of node used to produce this\n                                container.\n\n    Returns:\n        track_item (hiero.core.TrackItem): containerised object\n\n    \"\"\"\n\n    data_imprint = {\n        object_name: {\n            \"schema\": \"ayon:container-2.0\",\n            \"id\": AVALON_CONTAINER_ID,\n            \"name\": str(name),\n            \"namespace\": str(namespace),\n            \"loader\": str(loader),\n            \"representation\": context[\"representation\"][\"id\"],\n        }\n    }\n\n    if data:\n        for k, v in data.items():\n            data_imprint[object_name].update({k: v})\n\n    self.log.debug(\"_ data_imprint: {}\".format(data_imprint))\n    phiero.set_track_ayon_tag(track, data_imprint)\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/plugins/load/load_effects.html#client.ayon_hiero.plugins.load.load_effects.LoadEffects.load","title":"<code>load(context, name, namespace, data)</code>","text":"<p>Loading function to get the soft effects to particular read node</p> <p>Parameters:</p> Name Type Description Default <code>context</code> <code>dict</code> <p>context of version</p> required <code>name</code> <code>str</code> <p>name of the version</p> required <code>namespace</code> <code>str</code> <p>Folder name.</p> required <code>data</code> <code>dict</code> <p>compulsory attribute &gt; not used</p> required <p>Returns:</p> Type Description <p>nuke node: containerised nuke node object</p> Source code in <code>client/ayon_hiero/plugins/load/load_effects.py</code> <pre><code>def load(self, context, name, namespace, data):\n    \"\"\"\n    Loading function to get the soft effects to particular read node\n\n    Arguments:\n        context (dict): context of version\n        name (str): name of the version\n        namespace (str): Folder name.\n        data (dict): compulsory attribute &gt; not used\n\n    Returns:\n        nuke node: containerised nuke node object\n    \"\"\"\n    active_sequence = phiero.get_current_sequence()\n    active_track = phiero.get_current_track(\n        active_sequence, \"Loaded_{}\".format(name))\n\n    # get main variables\n    namespace = namespace or context[\"folder\"][\"name\"]\n    object_name = \"{}_{}\".format(name, namespace)\n    clip_in = context[\"folder\"][\"attrib\"][\"clipIn\"]\n    clip_out = context[\"folder\"][\"attrib\"][\"clipOut\"]\n\n    data_imprint = {\n        \"objectName\": object_name,\n        \"children_names\": []\n    }\n\n    # getting file path\n    file = self.filepath_from_context(context)\n    file = file.replace(\"\\\\\", \"/\")\n\n    if self._shared_loading(\n        file,\n        active_track,\n        clip_in,\n        clip_out,\n        data_imprint\n    ):\n        self.containerise(\n            active_track,\n            name=name,\n            namespace=namespace,\n            object_name=object_name,\n            context=context,\n            loader=self.__class__.__name__,\n            data=data_imprint)\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/plugins/load/load_effects.html#client.ayon_hiero.plugins.load.load_effects.LoadEffects.update","title":"<code>update(container, context)</code>","text":"<p>Updating previously loaded effects</p> Source code in <code>client/ayon_hiero/plugins/load/load_effects.py</code> <pre><code>def update(self, container, context):\n    \"\"\" Updating previously loaded effects\n    \"\"\"\n    version_entity = context[\"version\"]\n    repre_entity = context[\"representation\"]\n    active_track = container[\"_item\"]\n    file = get_representation_path(repre_entity).replace(\"\\\\\", \"/\")\n\n    # get main variables\n    name = container['name']\n    namespace = container['namespace']\n\n    # get timeline in out data\n    version_attributes = version_entity[\"attrib\"]\n    clip_in = version_attributes[\"clipIn\"]\n    clip_out = version_attributes[\"clipOut\"]\n\n    object_name = \"{}_{}\".format(name, namespace)\n\n    # Disable previously created nodes\n    used_subtracks = {\n        stitem.name(): stitem\n        for stitem in phiero.flatten(active_track.subTrackItems())\n    }\n    container = phiero.get_track_ayon_data(\n        active_track, object_name\n    )\n\n    loaded_subtrack_items = container[\"children_names\"]\n    for loaded_stitem in loaded_subtrack_items:\n        if loaded_stitem not in used_subtracks:\n            continue\n        item_to_remove = used_subtracks.pop(loaded_stitem)\n        # TODO: find a way to erase nodes\n        self.log.debug(\n            \"This node needs to be removed: {}\".format(item_to_remove))\n\n    data_imprint = {\n        \"objectName\": object_name,\n        \"name\": name,\n        \"representation\": repre_entity[\"id\"],\n        \"children_names\": []\n    }\n\n    if self._shared_loading(\n        file,\n        active_track,\n        clip_in,\n        clip_out,\n        data_imprint,\n        update=True\n    ):\n        return phiero.update_container(active_track, data_imprint)\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/plugins/publish/index.html","title":"publish","text":""},{"location":"autoapi/client/ayon_hiero/plugins/publish/collect_audio.html","title":"collect_audio","text":""},{"location":"autoapi/client/ayon_hiero/plugins/publish/collect_audio.html#client.ayon_hiero.plugins.publish.collect_audio.CollectAudio","title":"<code>CollectAudio</code>","text":"<p>               Bases: <code>InstancePlugin</code></p> <p>Collect new audio.</p> Source code in <code>client/ayon_hiero/plugins/publish/collect_audio.py</code> <pre><code>class CollectAudio(pyblish.api.InstancePlugin):\n    \"\"\"Collect new audio.\"\"\"\n\n    order = pyblish.api.CollectorOrder - 0.48\n    label = \"Collect Audio\"\n    hosts = [\"hiero\"]\n    families = [\"audio\"]\n\n    def process(self, instance):\n        \"\"\"\n        Args:\n            instance (pyblish.Instance): The shot instance to update.\n        \"\"\"\n        # Retrieve instance data from parent instance shot instance.\n        parent_instance_id = instance.data[\"parent_instance_id\"]\n\n        try:\n            edit_shared_data = instance.context.data[\"editorialSharedData\"]\n            shot_instance_data = edit_shared_data[parent_instance_id]\n\n        # Ensure shot instance related to the audio instance exists.\n        except KeyError:\n            raise PublishError(\n                f'Could not find shot instance for {instance.data[\"label\"]}.'\n                \" Please ensure it is set and enabled.\"\n            )\n\n        instance.data.update(shot_instance_data)\n\n        # Adjust instance data from parent otio timeline.\n        otio_timeline = instance.context.data[\"otioTimeline\"]\n        # Clip index has to be taken form hero shot data\n        # audio could be shorter but we need to get full length\n        otio_clip, _ = utils.get_marker_from_clip_index(\n            otio_timeline, shot_instance_data[\"shot_clip_index\"]\n        )\n        if not otio_clip:\n            raise PublishError(\n                f\"Could not retrieve otioClip for shot {instance}\")\n\n        instance.data[\"otioClip\"] = otio_clip\n\n        # Adjust info from track_item on timeline\n        active_timeline = instance.context.data[\"activeTimeline\"]\n        track_item = None\n        for video_track in active_timeline.videoTracks():\n            for item in video_track.items():\n                if item.guid() == instance.data[\"clip_index\"]:\n                    track_item = item\n                    break\n\n        if not track_item:\n            raise PublishError(\n                'Could not retrieve item from '\n                f'clip guid: {instance.data[\"clip_index\"]}'\n            )\n\n        instance.data[\"trackItem\"] = track_item\n\n        # solve reviewable options\n        review_switch = instance.data[\"creator_attributes\"].get(\"review\")\n\n        if review_switch is True:\n            instance.data[\"reviewAudio\"] = True\n            instance.data.pop(\"review\", None)\n\n        clip_src = otio_clip.source_range\n        clip_src_in = clip_src.start_time.to_frames()\n        clip_src_out = clip_src_in + clip_src.duration.to_frames()\n        instance.data.update({\n            \"clipInH\": clip_src_in,\n            \"clipOutH\": clip_src_out\n        })\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/plugins/publish/collect_audio.html#client.ayon_hiero.plugins.publish.collect_audio.CollectAudio.process","title":"<code>process(instance)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>instance</code> <code>Instance</code> <p>The shot instance to update.</p> required Source code in <code>client/ayon_hiero/plugins/publish/collect_audio.py</code> <pre><code>def process(self, instance):\n    \"\"\"\n    Args:\n        instance (pyblish.Instance): The shot instance to update.\n    \"\"\"\n    # Retrieve instance data from parent instance shot instance.\n    parent_instance_id = instance.data[\"parent_instance_id\"]\n\n    try:\n        edit_shared_data = instance.context.data[\"editorialSharedData\"]\n        shot_instance_data = edit_shared_data[parent_instance_id]\n\n    # Ensure shot instance related to the audio instance exists.\n    except KeyError:\n        raise PublishError(\n            f'Could not find shot instance for {instance.data[\"label\"]}.'\n            \" Please ensure it is set and enabled.\"\n        )\n\n    instance.data.update(shot_instance_data)\n\n    # Adjust instance data from parent otio timeline.\n    otio_timeline = instance.context.data[\"otioTimeline\"]\n    # Clip index has to be taken form hero shot data\n    # audio could be shorter but we need to get full length\n    otio_clip, _ = utils.get_marker_from_clip_index(\n        otio_timeline, shot_instance_data[\"shot_clip_index\"]\n    )\n    if not otio_clip:\n        raise PublishError(\n            f\"Could not retrieve otioClip for shot {instance}\")\n\n    instance.data[\"otioClip\"] = otio_clip\n\n    # Adjust info from track_item on timeline\n    active_timeline = instance.context.data[\"activeTimeline\"]\n    track_item = None\n    for video_track in active_timeline.videoTracks():\n        for item in video_track.items():\n            if item.guid() == instance.data[\"clip_index\"]:\n                track_item = item\n                break\n\n    if not track_item:\n        raise PublishError(\n            'Could not retrieve item from '\n            f'clip guid: {instance.data[\"clip_index\"]}'\n        )\n\n    instance.data[\"trackItem\"] = track_item\n\n    # solve reviewable options\n    review_switch = instance.data[\"creator_attributes\"].get(\"review\")\n\n    if review_switch is True:\n        instance.data[\"reviewAudio\"] = True\n        instance.data.pop(\"review\", None)\n\n    clip_src = otio_clip.source_range\n    clip_src_in = clip_src.start_time.to_frames()\n    clip_src_out = clip_src_in + clip_src.duration.to_frames()\n    instance.data.update({\n        \"clipInH\": clip_src_in,\n        \"clipOutH\": clip_src_out\n    })\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/plugins/publish/collect_clip_effects.html","title":"collect_clip_effects","text":""},{"location":"autoapi/client/ayon_hiero/plugins/publish/collect_clip_effects.html#client.ayon_hiero.plugins.publish.collect_clip_effects.CollectClipEffects","title":"<code>CollectClipEffects</code>","text":"<p>               Bases: <code>InstancePlugin</code></p> <p>Collect soft effects instances.</p> Source code in <code>client/ayon_hiero/plugins/publish/collect_clip_effects.py</code> <pre><code>class CollectClipEffects(pyblish.api.InstancePlugin):\n    \"\"\"Collect soft effects instances.\"\"\"\n\n    order = pyblish.api.CollectorOrder - 0.078\n    label = \"Collect Clip Effects Instances\"\n    families = [\"clip\"]\n    settings_category = \"hiero\"\n\n    effect_categories = []\n    effect_tracks = []\n\n    def process(self, instance):\n        product_type = \"effect\"\n        effects = {}\n        review = instance.data.get(\"review\")\n        review_track_index = instance.context.data.get(\"reviewTrackIndex\")\n        track_item = instance.data[\"trackItem\"]\n        product_name = instance.data.get(\"productName\")\n\n        if not instance.data[\"creator_attributes\"][\"publish_effects\"]:\n            self.log.debug(\n                \"Effects collection/publish is disabled for %s\",\n                product_name,\n            )\n            return\n\n        if \"audio\" in instance.data[\"productType\"]:\n            return\n\n        # frame range\n        self.handle_start = instance.data[\"handleStart\"]\n        self.handle_end = instance.data[\"handleEnd\"]\n        self.clip_in = int(track_item.timelineIn())\n        self.clip_out = int(track_item.timelineOut())\n        self.clip_in_h = self.clip_in - self.handle_start\n        self.clip_out_h = self.clip_out + self.handle_end\n\n        track = track_item.parent()\n        track_index = track.trackIndex()\n        tracks_effect_items = instance.context.data.get(\"tracksEffectItems\")\n        clip_effect_items = instance.data.get(\"clipEffectItems\")\n\n        # add clips effects to track's:\n        if clip_effect_items:\n            tracks_effect_items[track_index] = clip_effect_items\n\n        # process all effects and divide them to instance\n        for _track_index, sub_track_items in tracks_effect_items.items():\n            # skip if track index is the same as review track index\n            if review and review_track_index == _track_index:\n                continue\n            for sitem in sub_track_items:\n                # make sure this subtrack item is relative of track item\n                if ((track_item not in sitem.linkedItems())\n                        and (len(sitem.linkedItems()) &gt; 0)):\n                    continue\n\n                if not (track_index &lt;= _track_index):\n                    continue\n\n                effect = self.add_effect(_track_index, sitem)\n                if effect:\n                    effects.update(effect)\n\n        # skip any without effects\n        if not effects:\n            return\n\n        effects.update({\"assignTo\": product_name})\n\n        product_name_split = re.findall(r'[A-Z][^A-Z]*', product_name)\n\n        if len(product_name_split) &gt; 0:\n            root_name = product_name.replace(product_name_split[0], \"\")\n            product_name_split.insert(0, root_name.capitalize())\n\n        product_name_split.insert(0, \"effect\")\n\n        # Categorize effects by class.\n        effect_categories = {\n            x[\"name\"]: x[\"effect_classes\"] for x in self.effect_categories\n        }\n\n        category_by_effect = {\"\": \"\"}\n        for key, values in effect_categories.items():\n            for cls in values:\n                category_by_effect[cls] = key\n\n        effects_categorized = {k: {} for k in effect_categories.keys()}\n        for key, value in effects.items():\n            if key == \"assignTo\":\n                continue\n\n            # Some classes can have a number in them. Like Text2.\n            found_cls = \"\"\n            for cls in category_by_effect.keys():\n                if cls in value[\"class\"]:\n                    found_cls = cls\n\n            if not found_cls:\n                continue\n\n            effects_categorized[category_by_effect[found_cls]][key] = value\n\n        # Categorize effects by track name.\n        track_names_by_category = {\n            x[\"name\"]: x[\"track_names\"] for x in self.effect_tracks\n        }\n        for category, track_names in track_names_by_category.items():\n            for key, value in effects.items():\n                if key == \"assignTo\":\n                    continue\n\n                if value[\"track\"] not in track_names:\n                    continue\n\n                if category in effects_categorized:\n                    effects_categorized[category][key] = value\n                else:\n                    effects_categorized[category] = {key: value}\n\n        # Ensure required `assignTo` data member exists.\n        categories = list(effects_categorized.keys())\n        for category in categories:\n            if not effects_categorized[category]:\n                effects_categorized.pop(category)\n                continue\n\n            effects_categorized[category][\"assignTo\"] = effects[\"assignTo\"]\n\n        # If no effects have been categorized, publish all effects together.\n        if not effects_categorized:\n            effects_categorized[\"\"] = effects\n\n        for category, effects in effects_categorized.items():\n            product_name = \"\".join(product_name_split)\n            product_name += category.capitalize()\n\n            # create new instance and inherit data\n            data = {}\n            for key, value in instance.data.items():\n                if \"clipEffectItems\" in key:\n                    continue\n                data[key] = value\n\n            data.update({\n                \"productName\": product_name,\n                \"productType\": product_type,\n                \"family\": product_type,\n                \"families\": [product_type],\n                \"name\": product_name + \"_\" + data[\"folderPath\"],\n                \"label\": \"{} - {}\".format(\n                    data[\"folderPath\"], product_name\n                ),\n                \"effects\": effects,\n            })\n\n            # create new instance\n            _instance = instance.context.create_instance(**data)\n            self.log.info(\"Created instance `{}`\".format(_instance))\n            self.log.debug(\"instance.data `{}`\".format(_instance.data))\n\n    def test_overlap(self, effect_t_in, effect_t_out):\n        covering_exp = bool(\n            (effect_t_in &lt;= self.clip_in)\n            and (effect_t_out &gt;= self.clip_out)\n        )\n        overlaying_right_exp = bool(\n            (effect_t_in &lt; self.clip_out)\n            and (effect_t_out &gt;= self.clip_out)\n        )\n        overlaying_left_exp = bool(\n            (effect_t_out &gt; self.clip_in)\n            and (effect_t_in &lt;= self.clip_in)\n        )\n\n        return any((\n            covering_exp,\n            overlaying_right_exp,\n            overlaying_left_exp\n        ))\n\n    def add_effect(self, track_index, sitem):\n        track = sitem.parentTrack().name()\n        # node serialization\n        node = sitem.node()\n        node_serialized = self.node_serialization(node)\n        node_name = sitem.name()\n        node_class = node.Class()\n\n        # collect timelineIn/Out\n        effect_t_in = int(sitem.timelineIn())\n        effect_t_out = int(sitem.timelineOut())\n\n        if not self.test_overlap(effect_t_in, effect_t_out):\n            return\n\n        self.log.debug(\"node_name: `{}`\".format(node_name))\n        self.log.debug(\"node_class: `{}`\".format(node_class))\n\n        return {node_name: {\n            \"class\": node_class,\n            \"timelineIn\": effect_t_in,\n            \"timelineOut\": effect_t_out,\n            \"subTrackIndex\": sitem.subTrackIndex(),\n            \"trackIndex\": track_index,\n            \"track\": track,\n            \"node\": node_serialized\n        }}\n\n    def node_serialization(self, node):\n        node_serialized = {}\n\n        # adding ignoring knob keys\n        _ignoring_keys = ['invert_mask', 'help', 'mask',\n                          'xpos', 'ypos', 'layer', 'process_mask', 'channel',\n                          'channels', 'maskChannelMask', 'maskChannelInput',\n                          'note_font', 'note_font_size', 'unpremult',\n                          'postage_stamp_frame', 'maskChannel', 'export_cc',\n                          'select_cccid', 'mix', 'version', 'matrix']\n\n        # loop through all knobs and collect not ignored\n        # and any with any value\n        for knob in node.knobs().keys():\n            # skip nodes in ignore keys\n            if knob in _ignoring_keys:\n                continue\n\n            # Hiero 15.1v3\n            # This seems to be a bug. The \"file\" knob\n            # is always returned as animated by the API.\n            # (even tho it's not even possible\n            # to set this knob as animated from the UI).\n            is_file_knob = knob == \"file\"\n\n            # get animation if node is animated\n            if not is_file_knob and node[knob].isAnimated():\n                # grab animation including handles\n                knob_anim = [node[knob].getValueAt(i)\n                             for i in range(\n                             self.clip_in_h, self.clip_out_h + 1)]\n\n                node_serialized[knob] = knob_anim\n            else:\n                node_serialized[knob] = node[knob].value()\n\n        return node_serialized\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/plugins/publish/collect_frame_tag_instances.html","title":"collect_frame_tag_instances","text":""},{"location":"autoapi/client/ayon_hiero/plugins/publish/collect_frame_tag_instances.html#client.ayon_hiero.plugins.publish.collect_frame_tag_instances.CollectFrameTagInstances","title":"<code>CollectFrameTagInstances</code>","text":"<p>               Bases: <code>ContextPlugin</code></p> <p>Collect frames from tags.</p> <p>Tag is expected to have metadata: {     \"productType\": \"frame\"     \"productName\": \"main\" }</p> Source code in <code>client/ayon_hiero/plugins/publish/collect_frame_tag_instances.py</code> <pre><code>class CollectFrameTagInstances(pyblish.api.ContextPlugin):\n    \"\"\"Collect frames from tags.\n\n    Tag is expected to have metadata:\n    {\n        \"productType\": \"frame\"\n        \"productName\": \"main\"\n    }\n    \"\"\"\n\n    order = pyblish.api.CollectorOrder\n    label = \"Collect Frames\"\n    hosts = [\"hiero\"]\n    families = [\"clip\"]\n\n    def process(self, context):\n        self._context = context\n\n        # collect all sequence tags\n        product_data = self._create_frame_product_data_sequence(context)\n\n        self.log.debug(\"__ product_data: {}\".format(\n            pformat(product_data)\n        ))\n\n        # create instances\n        self._create_instances(product_data)\n\n    def _get_tag_data(self, tag):\n        data = {}\n\n        # get tag metadata attribute\n        tag_data = dict(tag.metadata())\n\n        if tag_data.get(\"tag.json_metadata\"):\n            return json.loads(tag_data.get(\"tag.json_metadata\"))\n\n        # convert tag metadata to normal keys names and values to correct types\n        # legacy\n        for k, v in tag_data.items():\n            key = k.replace(\"tag.\", \"\")\n\n            try:\n                # capture exceptions which are related to strings only\n                if re.match(r\"^[\\d]+$\", v):\n                    value = int(v)\n                elif re.match(r\"^True$\", v):\n                    value = True\n                elif re.match(r\"^False$\", v):\n                    value = False\n                elif re.match(r\"^None$\", v):\n                    value = None\n                elif re.match(r\"^[\\w\\d_]+$\", v):\n                    value = v\n                else:\n                    value = ast.literal_eval(v)\n            except (ValueError, SyntaxError):\n                value = v\n\n            data[key] = value\n\n        return data\n\n    def _create_frame_product_data_sequence(self, context):\n\n        sequence_tags = []\n        sequence = context.data[\"activeTimeline\"]\n\n        # get all publishable sequence frames\n        publish_frames = range(int(sequence.duration() + 1))\n\n        self.log.debug(\"__ publish_frames: {}\".format(\n            pformat(publish_frames)\n        ))\n\n        # get all sequence tags\n        for tag in sequence.tags():\n            tag_data = self._get_tag_data(tag)\n            self.log.debug(\"__ tag_data: {}\".format(\n                pformat(tag_data)\n            ))\n            if not tag_data:\n                continue\n\n            product_type = tag_data.get(\"productType\")\n            if product_type is None:\n                product_type = tag_data.get(\"family\")\n            if not product_type:\n                continue\n\n            if product_type != \"frame\":\n                continue\n\n            sequence_tags.append(tag_data)\n\n        self.log.debug(\"__ sequence_tags: {}\".format(\n            pformat(sequence_tags)\n        ))\n\n        # first collect all available product tag frames\n        product_data = {}\n        context_folder_path = context.data[\"folderEntity\"][\"path\"]\n\n        for tag_data in sequence_tags:\n            frame = int(tag_data[\"start\"])\n\n            if frame not in publish_frames:\n                continue\n\n            product_name = tag_data.get(\"productName\")\n            if product_name is None:\n                product_name = tag_data[\"subset\"]\n\n            if product_name in product_data:\n                # update existing product key\n                product_data[product_name][\"frames\"].append(frame)\n            else:\n                # create new product key\n                product_data[product_name] = {\n                    \"frames\": [frame],\n                    \"format\": tag_data[\"format\"],\n                    \"folderPath\": context_folder_path\n                }\n        return product_data\n\n    def _create_instances(self, product_data):\n        # create instance per product\n        product_type = \"image\"\n        for product_name, product_data in product_data.items():\n            name = \"frame\" + product_name.title()\n            data = {\n                \"name\": name,\n                \"label\": \"{} {}\".format(name, product_data[\"frames\"]),\n                \"productType\": product_type,\n                \"family\": product_type,\n                \"families\": [product_type, \"frame\"],\n                \"folderPath\": product_data[\"folderPath\"],\n                \"productName\": name,\n                \"format\": product_data[\"format\"],\n                \"frames\": product_data[\"frames\"]\n            }\n            self._context.create_instance(**data)\n\n            self.log.info(\n                \"Created instance: {}\".format(\n                    json.dumps(data, sort_keys=True, indent=4)\n                )\n            )\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/plugins/publish/collect_otio_timeline.html","title":"collect_otio_timeline","text":""},{"location":"autoapi/client/ayon_hiero/plugins/publish/collect_otio_timeline.html#client.ayon_hiero.plugins.publish.collect_otio_timeline.CollectOTIOTimeline","title":"<code>CollectOTIOTimeline</code>","text":"<p>               Bases: <code>ContextPlugin</code></p> <p>Inject the otio timeline</p> Source code in <code>client/ayon_hiero/plugins/publish/collect_otio_timeline.py</code> <pre><code>class CollectOTIOTimeline(pyblish.api.ContextPlugin):\n    \"\"\"Inject the otio timeline\"\"\"\n\n    label = \"Collect OTIO Timeline\"\n    hosts = [\"hiero\"]\n    order = pyblish.api.CollectorOrder - 0.491\n\n    def process(self, context):\n        host = registered_host()\n        current_file = host.get_current_workfile()\n\n        otio_timeline = hiero_export.create_otio_timeline()\n\n        active_timeline = hiero.ui.activeSequence()\n        project = active_timeline.project()\n        fps = active_timeline.framerate().toFloat()\n\n        all_tracks = active_timeline.videoTracks()\n        tracks_effect_items = self.collect_sub_track_items(all_tracks)\n\n        context_data = {\n            \"activeProject\": project,\n            \"activeTimeline\": active_timeline,\n            \"currentFile\": current_file,\n            \"otioTimeline\": otio_timeline,\n            \"colorspace\": self.get_colorspace(project),\n            \"fps\": fps,\n            \"tracksEffectItems\": tracks_effect_items,\n        }\n        context.data.update(context_data)\n\n    def get_colorspace(self, project):\n        # get workfile's colorspace properties\n        return {\n            \"useOCIOEnvironmentOverride\": project.useOCIOEnvironmentOverride(),\n            \"lutSetting16Bit\": project.lutSetting16Bit(),\n            \"lutSetting8Bit\": project.lutSetting8Bit(),\n            \"lutSettingFloat\": project.lutSettingFloat(),\n            \"lutSettingLog\": project.lutSettingLog(),\n            \"lutSettingViewer\": project.lutSettingViewer(),\n            \"lutSettingWorkingSpace\": project.lutSettingWorkingSpace(),\n            \"lutUseOCIOForExport\": project.lutUseOCIOForExport(),\n            \"ocioConfigName\": project.ocioConfigName(),\n            \"ocioConfigPath\": project.ocioConfigPath()\n        }\n\n    @staticmethod\n    def collect_sub_track_items(tracks):\n        \"\"\"\n        Args:\n            tracks (list): All of the video tracks.\n\n        Returns:\n            dict. Track index as key and list of subtracks\n        \"\"\"\n        # collect all subtrack items\n        sub_track_items = {}\n        for track in tracks:\n            effect_items = track.subTrackItems()\n\n            # skip if no clips on track &gt; need track with effect only\n            if not effect_items:\n                continue\n\n            # skip all disabled tracks\n            if not track.isEnabled():\n                continue\n\n            track_index = track.trackIndex()\n            _sub_track_items = lib.flatten(effect_items)\n\n            _sub_track_items = list(_sub_track_items)\n            # continue only if any subtrack items are collected\n            if not _sub_track_items:\n                continue\n\n            enabled_sti = []\n            # loop all found subtrack items and check if they are enabled\n            for _sti in _sub_track_items:\n                # checking if not enabled\n                if not _sti.isEnabled():\n                    continue\n                if isinstance(_sti, hiero.core.Annotation):\n                    continue\n                # collect the subtrack item\n                enabled_sti.append(_sti)\n\n            # continue only if any subtrack items are collected\n            if not enabled_sti:\n                continue\n\n            # add collection of subtrackitems to dict\n            sub_track_items[track_index] = enabled_sti\n\n        return sub_track_items\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/plugins/publish/collect_otio_timeline.html#client.ayon_hiero.plugins.publish.collect_otio_timeline.CollectOTIOTimeline.collect_sub_track_items","title":"<code>collect_sub_track_items(tracks)</code>  <code>staticmethod</code>","text":"<p>Parameters:</p> Name Type Description Default <code>tracks</code> <code>list</code> <p>All of the video tracks.</p> required <p>Returns:</p> Type Description <p>dict. Track index as key and list of subtracks</p> Source code in <code>client/ayon_hiero/plugins/publish/collect_otio_timeline.py</code> <pre><code>@staticmethod\ndef collect_sub_track_items(tracks):\n    \"\"\"\n    Args:\n        tracks (list): All of the video tracks.\n\n    Returns:\n        dict. Track index as key and list of subtracks\n    \"\"\"\n    # collect all subtrack items\n    sub_track_items = {}\n    for track in tracks:\n        effect_items = track.subTrackItems()\n\n        # skip if no clips on track &gt; need track with effect only\n        if not effect_items:\n            continue\n\n        # skip all disabled tracks\n        if not track.isEnabled():\n            continue\n\n        track_index = track.trackIndex()\n        _sub_track_items = lib.flatten(effect_items)\n\n        _sub_track_items = list(_sub_track_items)\n        # continue only if any subtrack items are collected\n        if not _sub_track_items:\n            continue\n\n        enabled_sti = []\n        # loop all found subtrack items and check if they are enabled\n        for _sti in _sub_track_items:\n            # checking if not enabled\n            if not _sti.isEnabled():\n                continue\n            if isinstance(_sti, hiero.core.Annotation):\n                continue\n            # collect the subtrack item\n            enabled_sti.append(_sti)\n\n        # continue only if any subtrack items are collected\n        if not enabled_sti:\n            continue\n\n        # add collection of subtrackitems to dict\n        sub_track_items[track_index] = enabled_sti\n\n    return sub_track_items\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/plugins/publish/collect_plates.html","title":"collect_plates","text":""},{"location":"autoapi/client/ayon_hiero/plugins/publish/collect_plates.html#client.ayon_hiero.plugins.publish.collect_plates.CollectPlate","title":"<code>CollectPlate</code>","text":"<p>               Bases: <code>InstancePlugin</code></p> <p>Collect new plates.</p> Source code in <code>client/ayon_hiero/plugins/publish/collect_plates.py</code> <pre><code>class CollectPlate(pyblish.api.InstancePlugin):\n    \"\"\"Collect new plates.\"\"\"\n\n    order = pyblish.api.CollectorOrder - 0.48\n    label = \"Collect Plate\"\n    hosts = [\"hiero\"]\n    families = [\"plate\"]\n\n    def process(self, instance):\n        \"\"\"\n        Args:\n            instance (pyblish.Instance): The shot instance to update.\n        \"\"\"\n        instance.data[\"families\"].append(\"clip\")\n\n        # Adjust instance data from parent otio timeline.\n        otio_timeline = instance.context.data[\"otioTimeline\"]\n        otio_clip, _ = utils.get_marker_from_clip_index(\n            otio_timeline, instance.data[\"clip_index\"]\n        )\n        if not otio_clip:\n            raise PublishError(\n                f\"Could not retrieve otioClip for shot {instance}\")\n\n        instance.data[\"otioClip\"] = otio_clip\n\n        # Adjust info from track_item on timeline\n        active_timeline = instance.context.data[\"activeTimeline\"]\n        track_item = None\n        for video_track in active_timeline.videoTracks():\n            for item in video_track.items():\n                if item.guid() == instance.data[\"clip_index\"]:\n                    track_item = item\n                    break\n\n        if not track_item:\n            raise PublishError(\n                'Could not retrieve item from '\n                f'clip guid: {instance.data[\"clip_index\"]}'\n            )\n\n        instance.data[\"trackItem\"] = track_item\n\n        # solve reviewable options\n        review_switch = instance.data[\"creator_attributes\"].get(\n            \"review\")\n        reviewable_source = instance.data[\"creator_attributes\"].get(\n            \"reviewableSource\")\n\n        if review_switch is True:\n            if reviewable_source == \"clip_media\":\n                instance.data[\"families\"].append(\"review\")\n                instance.data.pop(\"reviewTrack\", None)\n            else:\n                instance.data[\"reviewTrack\"] = reviewable_source\n\n        # remove creator-specific review keys from instance data\n        instance.data.pop(\"reviewableSource\", None)\n        instance.data.pop(\"review\", None)\n\n        # Retrieve instance data from parent instance shot instance.\n        parent_instance_id = instance.data[\"parent_instance_id\"]\n\n        try:\n            edit_shared_data = instance.context.data[\"editorialSharedData\"]\n            instance.data.update(\n                edit_shared_data[parent_instance_id]\n            )\n\n        # Ensure shot instance related to the audio instance exists.\n        except KeyError:\n            raise PublishError(\n                f'Could not find shot instance for {instance.data[\"label\"]}.'\n                \" Please ensure it is set and enabled.\"\n            )\n\n        clip_colorspace = track_item.sourceMediaColourTransform()\n\n        # add colorspace data to versionData\n        version_data = instance.data.setdefault(\"versionData\", {})\n        version_data[\"colorSpace\"] = clip_colorspace\n\n        # add colorspace data to instance\n        instance.data[\"colorspace\"] = clip_colorspace\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/plugins/publish/collect_plates.html#client.ayon_hiero.plugins.publish.collect_plates.CollectPlate.process","title":"<code>process(instance)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>instance</code> <code>Instance</code> <p>The shot instance to update.</p> required Source code in <code>client/ayon_hiero/plugins/publish/collect_plates.py</code> <pre><code>def process(self, instance):\n    \"\"\"\n    Args:\n        instance (pyblish.Instance): The shot instance to update.\n    \"\"\"\n    instance.data[\"families\"].append(\"clip\")\n\n    # Adjust instance data from parent otio timeline.\n    otio_timeline = instance.context.data[\"otioTimeline\"]\n    otio_clip, _ = utils.get_marker_from_clip_index(\n        otio_timeline, instance.data[\"clip_index\"]\n    )\n    if not otio_clip:\n        raise PublishError(\n            f\"Could not retrieve otioClip for shot {instance}\")\n\n    instance.data[\"otioClip\"] = otio_clip\n\n    # Adjust info from track_item on timeline\n    active_timeline = instance.context.data[\"activeTimeline\"]\n    track_item = None\n    for video_track in active_timeline.videoTracks():\n        for item in video_track.items():\n            if item.guid() == instance.data[\"clip_index\"]:\n                track_item = item\n                break\n\n    if not track_item:\n        raise PublishError(\n            'Could not retrieve item from '\n            f'clip guid: {instance.data[\"clip_index\"]}'\n        )\n\n    instance.data[\"trackItem\"] = track_item\n\n    # solve reviewable options\n    review_switch = instance.data[\"creator_attributes\"].get(\n        \"review\")\n    reviewable_source = instance.data[\"creator_attributes\"].get(\n        \"reviewableSource\")\n\n    if review_switch is True:\n        if reviewable_source == \"clip_media\":\n            instance.data[\"families\"].append(\"review\")\n            instance.data.pop(\"reviewTrack\", None)\n        else:\n            instance.data[\"reviewTrack\"] = reviewable_source\n\n    # remove creator-specific review keys from instance data\n    instance.data.pop(\"reviewableSource\", None)\n    instance.data.pop(\"review\", None)\n\n    # Retrieve instance data from parent instance shot instance.\n    parent_instance_id = instance.data[\"parent_instance_id\"]\n\n    try:\n        edit_shared_data = instance.context.data[\"editorialSharedData\"]\n        instance.data.update(\n            edit_shared_data[parent_instance_id]\n        )\n\n    # Ensure shot instance related to the audio instance exists.\n    except KeyError:\n        raise PublishError(\n            f'Could not find shot instance for {instance.data[\"label\"]}.'\n            \" Please ensure it is set and enabled.\"\n        )\n\n    clip_colorspace = track_item.sourceMediaColourTransform()\n\n    # add colorspace data to versionData\n    version_data = instance.data.setdefault(\"versionData\", {})\n    version_data[\"colorSpace\"] = clip_colorspace\n\n    # add colorspace data to instance\n    instance.data[\"colorspace\"] = clip_colorspace\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/plugins/publish/collect_shots.html","title":"collect_shots","text":""},{"location":"autoapi/client/ayon_hiero/plugins/publish/collect_shots.html#client.ayon_hiero.plugins.publish.collect_shots.CollectShot","title":"<code>CollectShot</code>","text":"<p>               Bases: <code>InstancePlugin</code></p> <p>Collect new shots.</p> Source code in <code>client/ayon_hiero/plugins/publish/collect_shots.py</code> <pre><code>class CollectShot(pyblish.api.InstancePlugin):\n    \"\"\"Collect new shots.\"\"\"\n\n    order = pyblish.api.CollectorOrder - 0.49\n    label = \"Collect Shots\"\n    hosts = [\"hiero\"]\n    families = [\"shot\"]\n\n    SHARED_KEYS = (\n        \"annotations\",\n        \"folderPath\",\n        \"fps\",\n        \"handleStart\",\n        \"handleEnd\",\n        \"resolutionWidth\",\n        \"resolutionHeight\",\n        \"pixelAspect\",\n        \"subtracks\",\n        \"tags\",\n    )\n\n    @classmethod\n    def _inject_editorial_shared_data(cls, instance):\n        \"\"\"\n        Args:\n            instance (obj): The publishing instance.\n        \"\"\"\n        context = instance.context\n        instance_id = instance.data[\"instance_id\"]\n\n        # Inject folderPath and other creator_attributes to ensure\n        # new shots/hierarchy are properly handled.\n        creator_attributes = instance.data['creator_attributes']\n        instance.data.update(creator_attributes)\n\n        # Adjust handles:\n        # Explain\n        track_item = instance.data[\"trackItem\"]\n        instance.data.update({\n            \"handleStart\": min(\n                instance.data[\"handleStart\"], int(track_item.handleInLength())),\n            \"handleEnd\": min(\n                instance.data[\"handleEnd\"], int(track_item.handleOutLength())),\n        })\n\n        # Inject/Distribute instance shot data as editorialSharedData\n        # to make it available for clip/plate/audio products\n        # in sub-collectors.\n        if not context.data.get(\"editorialSharedData\"):\n            context.data[\"editorialSharedData\"] = {}\n\n        edit_shared_data = context.data[\"editorialSharedData\"].setdefault(\n            instance_id, {}\n        )\n        edit_shared_data.update({\n            key: value for key, value in instance.data.items()\n            if key in cls.SHARED_KEYS\n        })\n        # also add `shot_clip_index` to shared data for audio instance\n        edit_shared_data[\"shot_clip_index\"] = instance.data[\"clip_index\"]\n\n    def process(self, instance):\n        \"\"\"\n        Args:\n            instance (pyblish.Instance): The shot instance to update.\n        \"\"\"\n        instance.data[\"integrate\"] = False  # no representation for shot\n\n        # Adjust instance data from parent otio timeline.\n        otio_timeline = instance.context.data[\"otioTimeline\"]\n        otio_clip, marker = utils.get_marker_from_clip_index(\n            otio_timeline, instance.data[\"clip_index\"]\n        )\n        if not otio_clip:\n            raise PublishError(\n                f\"Could not retrieve otioClip for shot {instance}\")\n\n        # Compute fps from creator attribute.\n        if instance.data['creator_attributes'][\"fps\"] == \"from_selection\":\n            instance.data['creator_attributes'][\"fps\"] = instance.context.data[\"fps\"]\n\n        # Retrieve AyonData marker for associated clip.\n        instance.data[\"otioClip\"] = otio_clip\n        creator_id = instance.data[\"creator_identifier\"]\n\n        marker_metadata = json.loads(marker.metadata[\"json_metadata\"])\n        inst_data = marker_metadata[\"hiero_sub_products\"].get(creator_id, {})\n\n        # Overwrite settings with clip metadata is \"sourceResolution\"\n        overwrite_clip_metadata = inst_data.get(\"sourceResolution\", False)\n        active_timeline = instance.context.data[\"activeTimeline\"]\n\n        # Adjust info from track_item on timeline\n        track_item = None\n        for video_track in active_timeline.videoTracks():\n            for item in video_track.items():\n                if item.guid() == instance.data[\"clip_index\"]:\n                    track_item = item\n                    break\n\n        if not track_item:\n            raise PublishError(\n                'Could not retrieve item from '\n                f'clip guid: {instance.data[\"clip_index\"]}'\n            )\n\n        instance.data.update({\n            \"annotations\": self.clip_annotations(track_item.source()),\n            \"trackItem\": track_item,\n            \"subtracks\": self.clip_subtrack(track_item),\n            \"tags\": lib.get_track_item_tags(track_item),\n        })\n\n        # Retrieve clip from active_timeline\n        if overwrite_clip_metadata:\n            source_clip = track_item.source()\n            item_format = source_clip.format()\n\n        # Get resolution from active timeline\n        else:\n            item_format = active_timeline.format()\n\n        instance.data.update(\n            {\n                \"resolutionWidth\": item_format.width(),\n                \"resolutionHeight\": item_format.height(),\n                \"pixelAspect\": item_format.pixelAspect()\n            }\n        )\n        self._inject_editorial_shared_data(instance)\n\n    @staticmethod\n    def clip_annotations(clip):\n        \"\"\"\n        Args:\n            clip (hiero.core.TrackItem): The clip to inspect.\n\n        Returns:\n            list[hiero.core.Annotation]: Associated clips annotations.\n        \"\"\"\n        annotations = []\n        subTrackItems = lib.flatten(clip.subTrackItems())\n        annotations += [item for item in subTrackItems if isinstance(\n            item, hiero.core.Annotation)]\n        return annotations\n\n    @staticmethod\n    def clip_subtrack(clip):\n        \"\"\"\n        Args:\n            clip (hiero.core.TrackItem): The clip to inspect.\n\n        Returns:\n            list[hiero.core.SubTrackItem]: Associated clips SubTrackItem.\n        \"\"\"\n        subtracks = []\n        subTrackItems = lib.flatten(clip.parent().subTrackItems())\n        for item in subTrackItems:\n            if \"TimeWarp\" in item.name():\n                continue\n            # avoid all annotation\n            if isinstance(item, hiero.core.Annotation):\n                continue\n            # avoid all disabled\n            if not item.isEnabled():\n                continue\n            subtracks.append(item)\n        return subtracks\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/plugins/publish/collect_shots.html#client.ayon_hiero.plugins.publish.collect_shots.CollectShot.clip_annotations","title":"<code>clip_annotations(clip)</code>  <code>staticmethod</code>","text":"<p>Parameters:</p> Name Type Description Default <code>clip</code> <code>TrackItem</code> <p>The clip to inspect.</p> required <p>Returns:</p> Type Description <p>list[hiero.core.Annotation]: Associated clips annotations.</p> Source code in <code>client/ayon_hiero/plugins/publish/collect_shots.py</code> <pre><code>@staticmethod\ndef clip_annotations(clip):\n    \"\"\"\n    Args:\n        clip (hiero.core.TrackItem): The clip to inspect.\n\n    Returns:\n        list[hiero.core.Annotation]: Associated clips annotations.\n    \"\"\"\n    annotations = []\n    subTrackItems = lib.flatten(clip.subTrackItems())\n    annotations += [item for item in subTrackItems if isinstance(\n        item, hiero.core.Annotation)]\n    return annotations\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/plugins/publish/collect_shots.html#client.ayon_hiero.plugins.publish.collect_shots.CollectShot.clip_subtrack","title":"<code>clip_subtrack(clip)</code>  <code>staticmethod</code>","text":"<p>Parameters:</p> Name Type Description Default <code>clip</code> <code>TrackItem</code> <p>The clip to inspect.</p> required <p>Returns:</p> Type Description <p>list[hiero.core.SubTrackItem]: Associated clips SubTrackItem.</p> Source code in <code>client/ayon_hiero/plugins/publish/collect_shots.py</code> <pre><code>@staticmethod\ndef clip_subtrack(clip):\n    \"\"\"\n    Args:\n        clip (hiero.core.TrackItem): The clip to inspect.\n\n    Returns:\n        list[hiero.core.SubTrackItem]: Associated clips SubTrackItem.\n    \"\"\"\n    subtracks = []\n    subTrackItems = lib.flatten(clip.parent().subTrackItems())\n    for item in subTrackItems:\n        if \"TimeWarp\" in item.name():\n            continue\n        # avoid all annotation\n        if isinstance(item, hiero.core.Annotation):\n            continue\n        # avoid all disabled\n        if not item.isEnabled():\n            continue\n        subtracks.append(item)\n    return subtracks\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/plugins/publish/collect_shots.html#client.ayon_hiero.plugins.publish.collect_shots.CollectShot.process","title":"<code>process(instance)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>instance</code> <code>Instance</code> <p>The shot instance to update.</p> required Source code in <code>client/ayon_hiero/plugins/publish/collect_shots.py</code> <pre><code>def process(self, instance):\n    \"\"\"\n    Args:\n        instance (pyblish.Instance): The shot instance to update.\n    \"\"\"\n    instance.data[\"integrate\"] = False  # no representation for shot\n\n    # Adjust instance data from parent otio timeline.\n    otio_timeline = instance.context.data[\"otioTimeline\"]\n    otio_clip, marker = utils.get_marker_from_clip_index(\n        otio_timeline, instance.data[\"clip_index\"]\n    )\n    if not otio_clip:\n        raise PublishError(\n            f\"Could not retrieve otioClip for shot {instance}\")\n\n    # Compute fps from creator attribute.\n    if instance.data['creator_attributes'][\"fps\"] == \"from_selection\":\n        instance.data['creator_attributes'][\"fps\"] = instance.context.data[\"fps\"]\n\n    # Retrieve AyonData marker for associated clip.\n    instance.data[\"otioClip\"] = otio_clip\n    creator_id = instance.data[\"creator_identifier\"]\n\n    marker_metadata = json.loads(marker.metadata[\"json_metadata\"])\n    inst_data = marker_metadata[\"hiero_sub_products\"].get(creator_id, {})\n\n    # Overwrite settings with clip metadata is \"sourceResolution\"\n    overwrite_clip_metadata = inst_data.get(\"sourceResolution\", False)\n    active_timeline = instance.context.data[\"activeTimeline\"]\n\n    # Adjust info from track_item on timeline\n    track_item = None\n    for video_track in active_timeline.videoTracks():\n        for item in video_track.items():\n            if item.guid() == instance.data[\"clip_index\"]:\n                track_item = item\n                break\n\n    if not track_item:\n        raise PublishError(\n            'Could not retrieve item from '\n            f'clip guid: {instance.data[\"clip_index\"]}'\n        )\n\n    instance.data.update({\n        \"annotations\": self.clip_annotations(track_item.source()),\n        \"trackItem\": track_item,\n        \"subtracks\": self.clip_subtrack(track_item),\n        \"tags\": lib.get_track_item_tags(track_item),\n    })\n\n    # Retrieve clip from active_timeline\n    if overwrite_clip_metadata:\n        source_clip = track_item.source()\n        item_format = source_clip.format()\n\n    # Get resolution from active timeline\n    else:\n        item_format = active_timeline.format()\n\n    instance.data.update(\n        {\n            \"resolutionWidth\": item_format.width(),\n            \"resolutionHeight\": item_format.height(),\n            \"pixelAspect\": item_format.pixelAspect()\n        }\n    )\n    self._inject_editorial_shared_data(instance)\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/plugins/publish/collect_tag_tasks.html","title":"collect_tag_tasks","text":""},{"location":"autoapi/client/ayon_hiero/plugins/publish/collect_tag_tasks.html#client.ayon_hiero.plugins.publish.collect_tag_tasks.CollectClipTagTasks","title":"<code>CollectClipTagTasks</code>","text":"<p>               Bases: <code>InstancePlugin</code></p> <p>Collect Tags from selected track items.</p> Source code in <code>client/ayon_hiero/plugins/publish/collect_tag_tasks.py</code> <pre><code>class CollectClipTagTasks(api.InstancePlugin):\n    \"\"\"Collect Tags from selected track items.\"\"\"\n\n    order = api.CollectorOrder - 0.077\n    label = \"Collect Tag Tasks\"\n    hosts = [\"hiero\"]\n    families = [\"shot\"]\n\n    def process(self, instance):\n        # gets tags\n        tags = instance.data[\"tags\"]\n\n        tasks = {}\n        for tag in tags:\n            t_metadata = dict(tag.metadata())\n            t_product_type = t_metadata.get(\"tag.productType\")\n            if t_product_type is None:\n                t_product_type = t_metadata.get(\"tag.family\", \"\")\n\n            # gets only task product type tags and collect labels\n            if \"task\" in t_product_type:\n                t_task_name = t_metadata.get(\"tag.label\", \"\")\n                t_task_type = t_metadata.get(\"tag.type\", \"\")\n                tasks[t_task_name] = {\"type\": t_task_type}\n\n        instance.data[\"tasks\"] = tasks\n\n        self.log.info(\"Collected Tasks from Tags: `{}`\".format(\n            instance.data[\"tasks\"]))\n        return\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/plugins/publish/collect_workfile.html","title":"collect_workfile","text":""},{"location":"autoapi/client/ayon_hiero/plugins/publish/collect_workfile.html#client.ayon_hiero.plugins.publish.collect_workfile.CollectWorkfile","title":"<code>CollectWorkfile</code>","text":"<p>               Bases: <code>ContextPlugin</code></p> <p>Collect the current working file into context</p> Source code in <code>client/ayon_hiero/plugins/publish/collect_workfile.py</code> <pre><code>class CollectWorkfile(pyblish.api.ContextPlugin):\n    \"\"\"Collect the current working file into context\"\"\"\n\n    label = \"Collect Workfile\"\n    hosts = [\"hiero\"]\n    order = pyblish.api.CollectorOrder - 0.49\n\n    def process(self, instance):\n\n        active_timeline = hiero.ui.activeSequence()\n        project = active_timeline.project()\n\n        current_file = project.path()\n\n        instance.data[\"currentFile\"] = current_file\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/plugins/publish/extract_clip_effects.html","title":"extract_clip_effects","text":""},{"location":"autoapi/client/ayon_hiero/plugins/publish/extract_clip_effects.html#client.ayon_hiero.plugins.publish.extract_clip_effects.ExtractClipEffects","title":"<code>ExtractClipEffects</code>","text":"<p>               Bases: <code>Extractor</code></p> <p>Extract clip effects instances.</p> Source code in <code>client/ayon_hiero/plugins/publish/extract_clip_effects.py</code> <pre><code>class ExtractClipEffects(publish.Extractor):\n    \"\"\"Extract clip effects instances.\"\"\"\n\n    order = pyblish.api.ExtractorOrder\n    label = \"Export Clip Effects\"\n    families = [\"effect\"]\n\n    def process(self, instance):\n        item = instance.data[\"trackItem\"]\n        effects = instance.data.get(\"effects\")\n\n        # skip any without effects\n        if not effects:\n            return\n\n        product_name = instance.data.get(\"productName\")\n        product_type = instance.data[\"productType\"]\n\n        self.log.debug(\"creating staging dir\")\n        staging_dir = self.staging_dir(instance)\n\n        transfers = list()\n        if \"transfers\" not in instance.data:\n            instance.data[\"transfers\"] = list()\n\n        ext = \"json\"\n        file = product_name + \".\" + ext\n\n        # when instance is created during collection part\n        resources_dir = instance.data[\"resourcesDir\"]\n\n        # change paths in effects to files\n        for k, effect in effects.items():\n            if \"assignTo\" in k:\n                continue\n            trn = self.copy_linked_files(effect, resources_dir)\n            if trn:\n                transfers.append((trn[0], trn[1]))\n\n        instance.data[\"transfers\"].extend(transfers)\n        self.log.debug(\"_ transfers: `{}`\".format(\n            instance.data[\"transfers\"]))\n\n        # create representations\n        instance.data[\"representations\"] = list()\n\n        transfer_data = [\n            \"handleStart\", \"handleEnd\",\n            \"sourceStart\", \"sourceStartH\", \"sourceEnd\", \"sourceEndH\",\n            \"frameStart\", \"frameEnd\",\n            \"clipIn\", \"clipOut\", \"clipInH\", \"clipOutH\",\n            \"folderPath\", \"version\"\n        ]\n\n        # pass data to version\n        version_data = dict()\n        version_data.update({k: instance.data[k] for k in transfer_data})\n\n        # add to data of representation\n        version_data.update({\n            \"colorSpace\": item.sourceMediaColourTransform(),\n            \"colorspaceScript\": instance.context.data[\"colorspace\"],\n            \"families\": [product_type, \"plate\"],\n            # TODO find out if 'subset' is needed (and 'productName')\n            \"subset\": product_name,\n            \"productName\": product_name,\n            \"fps\": instance.context.data[\"fps\"]\n        })\n        instance.data[\"versionData\"] = version_data\n\n        representation = {\n            'files': file,\n            'stagingDir': staging_dir,\n            'name': product_type + ext.title(),\n            'ext': ext\n        }\n        instance.data[\"representations\"].append(representation)\n\n        self.log.debug(\"_ representations: `{}`\".format(\n            instance.data[\"representations\"]))\n\n        self.log.debug(\"_ version_data: `{}`\".format(\n            instance.data[\"versionData\"]))\n\n        with open(os.path.join(staging_dir, file), \"w\") as outfile:\n            outfile.write(json.dumps(effects, indent=4, sort_keys=True))\n\n    def copy_linked_files(self, effect, dst_dir):\n        for k, v in effect[\"node\"].items():\n            if k in \"file\" and isinstance(v, str) and v != '':\n                base_name = os.path.basename(v)\n                dst = os.path.join(dst_dir, base_name).replace(\"\\\\\", \"/\")\n\n                # add it to the json\n                effect[\"node\"][k] = dst\n                return (v, dst)\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/plugins/publish/extract_frames.html","title":"extract_frames","text":""},{"location":"autoapi/client/ayon_hiero/plugins/publish/extract_frames.html#client.ayon_hiero.plugins.publish.extract_frames.ExtractFrames","title":"<code>ExtractFrames</code>","text":"<p>               Bases: <code>Extractor</code></p> <p>Extracts frames</p> Source code in <code>client/ayon_hiero/plugins/publish/extract_frames.py</code> <pre><code>class ExtractFrames(publish.Extractor):\n    \"\"\"Extracts frames\"\"\"\n\n    order = pyblish.api.ExtractorOrder\n    label = \"Extract Frames\"\n    hosts = [\"hiero\"]\n    families = [\"frame\"]\n    movie_extensions = [\"mov\", \"mp4\"]\n\n    def process(self, instance):\n        oiio_tool_args = get_oiio_tool_args(\"oiiotool\")\n        staging_dir = self.staging_dir(instance)\n        output_template = os.path.join(staging_dir, instance.data[\"name\"])\n        sequence = instance.context.data[\"activeTimeline\"]\n\n        files = []\n        for frame in instance.data[\"frames\"]:\n            track_item = sequence.trackItemAt(frame)\n            media_source = track_item.source().mediaSource()\n            input_path = media_source.fileinfos()[0].filename()\n            input_frame = (\n                track_item.mapTimelineToSource(frame) +\n                track_item.source().mediaSource().startTime()\n            )\n            output_ext = instance.data[\"format\"]\n            output_path = output_template\n            output_path += \".{:04d}.{}\".format(int(frame), output_ext)\n\n            args = list(oiio_tool_args)\n\n            ext = os.path.splitext(input_path)[1][1:]\n            if ext in self.movie_extensions:\n                args.extend([\"--subimage\", str(int(input_frame))])\n            else:\n                args.extend([\"--frames\", str(int(input_frame))])\n\n            if ext == \"exr\":\n                args.extend([\"--powc\", \"0.45,0.45,0.45,1.0\"])\n\n            args.extend([input_path, \"-o\", output_path])\n            output = run_subprocess(args)\n\n            failed_output = \"oiiotool produced no output.\"\n            if failed_output in output:\n                raise ValueError(\n                    \"oiiotool processing failed. Args: {}\".format(args)\n                )\n\n            files.append(output_path)\n\n            # Feedback to user because \"oiiotool\" can make the publishing\n            # appear unresponsive.\n            self.log.info(\n                \"Processed {} of {} frames\".format(\n                    instance.data[\"frames\"].index(frame) + 1,\n                    len(instance.data[\"frames\"])\n                )\n            )\n\n        if len(files) == 1:\n            instance.data[\"representations\"] = [\n                {\n                    \"name\": output_ext,\n                    \"ext\": output_ext,\n                    \"files\": os.path.basename(files[0]),\n                    \"stagingDir\": staging_dir\n                }\n            ]\n        else:\n            instance.data[\"representations\"] = [\n                {\n                    \"name\": output_ext,\n                    \"ext\": output_ext,\n                    \"files\": [os.path.basename(x) for x in files],\n                    \"stagingDir\": staging_dir\n                }\n            ]\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/plugins/publish/extract_thumbnail.html","title":"extract_thumbnail","text":""},{"location":"autoapi/client/ayon_hiero/plugins/publish/extract_thumbnail.html#client.ayon_hiero.plugins.publish.extract_thumbnail.ExtractThumbnail","title":"<code>ExtractThumbnail</code>","text":"<p>               Bases: <code>Extractor</code></p> <p>Extractor for track item's tumbnails</p> Source code in <code>client/ayon_hiero/plugins/publish/extract_thumbnail.py</code> <pre><code>class ExtractThumbnail(publish.Extractor):\n    \"\"\"\n    Extractor for track item's tumbnails\n    \"\"\"\n\n    label = \"Extract Thumbnail\"\n    order = pyblish.api.ExtractorOrder\n    families = [\"plate\", \"take\"]\n    hosts = [\"hiero\"]\n\n    def process(self, instance):\n        # create representation data\n        if \"representations\" not in instance.data:\n            instance.data[\"representations\"] = []\n\n        staging_dir = self.staging_dir(instance)\n\n        self.create_thumbnail(staging_dir, instance)\n\n    def create_thumbnail(self, staging_dir, instance):\n        track_item = instance.data[\"trackItem\"]\n        track_item_name = track_item.name()\n\n        # frames\n        duration = track_item.sourceDuration()\n        frame_start = track_item.sourceIn()\n        self.log.debug(\n            \"__ frame_start: `{}`, duration: `{}`\".format(\n                frame_start, duration))\n\n        # get thumbnail frame from the middle\n        thumb_frame = int(frame_start + (duration / 2))\n\n        thumb_file = \"{}thumbnail{}{}\".format(\n            track_item_name, thumb_frame, \".png\")\n        thumb_path = os.path.join(staging_dir, thumb_file)\n\n        thumbnail = track_item.thumbnail(thumb_frame, \"colour\").save(\n            thumb_path,\n            format='png'\n        )\n        self.log.debug(\n            \"__ thumb_path: `{}`, frame: `{}`\".format(thumbnail, thumb_frame))\n\n        self.log.info(\"Thumbnail was generated to: {}\".format(thumb_path))\n        thumb_representation = {\n            'files': thumb_file,\n            'stagingDir': staging_dir,\n            'name': \"thumbnail\",\n            'thumbnail': True,\n            'ext': \"png\"\n        }\n        instance.data[\"representations\"].append(\n            thumb_representation)\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/plugins/publish/extract_workfile.html","title":"extract_workfile","text":""},{"location":"autoapi/client/ayon_hiero/plugins/publish/extract_workfile.html#client.ayon_hiero.plugins.publish.extract_workfile.ExtractWorkfile","title":"<code>ExtractWorkfile</code>","text":"<p>               Bases: <code>Extractor</code></p> <p>Extractor export Hiero workfile representation</p> Source code in <code>client/ayon_hiero/plugins/publish/extract_workfile.py</code> <pre><code>class ExtractWorkfile(publish.Extractor):\n    \"\"\"\n    Extractor export Hiero workfile representation\n    \"\"\"\n\n    label = \"Extract Workfile\"\n    order = pyblish.api.ExtractorOrder\n    families = [\"workfile\"]\n    hosts = [\"hiero\"]\n\n    def process(self, instance):\n        # create representation data\n        if \"representations\" not in instance.data:\n            instance.data[\"representations\"] = []\n\n        # asset = instance.context.data[\"folderPath\"]\n        # asset_name = asset.split(\"/\")[-1]\n\n        active_timeline = hiero.ui.activeSequence()\n        # project = active_timeline.project()\n\n        # adding otio timeline to context\n        # otio_timeline = hiero_export.create_otio_timeline()\n        # otio_timeline = instance.data[\"otioTimeline\"]\n\n        # get workfile thumbnail paths\n        tmp_staging = tempfile.mkdtemp(prefix=\"pyblish_tmp_\")\n        thumbnail_name = \"workfile_thumbnail.png\"\n        thumbnail_path = os.path.join(tmp_staging, thumbnail_name)\n\n        # search for all windows with name of actual sequence\n        _windows = [w for w in hiero.ui.windowManager().windows()\n                    if active_timeline.name() in w.windowTitle()]\n\n        # export window to thumb path\n        QPixmap.grabWidget(_windows[-1]).save(thumbnail_path, 'png')\n\n        # thumbnail\n        thumb_representation = {\n            'files': thumbnail_name,\n            'stagingDir': tmp_staging,\n            'name': \"thumbnail\",\n            'thumbnail': True,\n            'ext': \"png\"\n        }\n\n        name = instance.data[\"name\"]\n        project = hiero.ui.activeProject()\n        staging_dir = self.staging_dir(instance)\n\n        ext = \".hrox\"\n        filename = name + ext\n        filepath = os.path.normpath(\n            os.path.join(staging_dir, filename))\n\n        # write out the workfile\n        path_previous = project.path()\n        project.saveAs(filepath)\n        project.setPath(path_previous)\n\n        # create workfile representation\n        representation = {\n            'name': ext.lstrip(\".\"),\n            'ext': ext.lstrip(\".\"),\n            'files': filename,\n            \"stagingDir\": staging_dir,\n        }\n        representations = instance.data.setdefault(\"representations\", [])\n        representations.append(representation)\n        representations.append(thumb_representation)\n\n        self.log.debug(\n            \"Added hiero file representation: {}\".format(representation)\n        )\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/plugins/publish/integrate_version_up_workfile.html","title":"integrate_version_up_workfile","text":""},{"location":"autoapi/client/ayon_hiero/plugins/publish/integrate_version_up_workfile.html#client.ayon_hiero.plugins.publish.integrate_version_up_workfile.IntegrateVersionUpWorkfile","title":"<code>IntegrateVersionUpWorkfile</code>","text":"<p>               Bases: <code>ContextPlugin</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Save as new workfile version</p> Source code in <code>client/ayon_hiero/plugins/publish/integrate_version_up_workfile.py</code> <pre><code>class IntegrateVersionUpWorkfile(api.ContextPlugin,\n                                 OptionalPyblishPluginMixin):\n    \"\"\"Save as new workfile version\"\"\"\n\n    order = api.IntegratorOrder + 10.1\n    label = \"Version-up Workfile\"\n    hosts = [\"hiero\"]\n\n    optional = True\n    active = True\n\n    def process(self, context):\n        if not self.is_active(context.data):\n            self.log.debug(\"Project workfile version up was skipped\")\n            return\n\n        project = context.data[\"activeProject\"]\n        path = context.data.get(\"currentFile\")\n        new_path = version_up(path)\n\n        if project:\n            project.saveAs(new_path)\n\n        self.log.info(\"Project workfile was versioned up\")\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/plugins/publish_old_workflow/index.html","title":"publish_old_workflow","text":""},{"location":"autoapi/client/ayon_hiero/plugins/publish_old_workflow/collect_tag_comments.html","title":"collect_tag_comments","text":""},{"location":"autoapi/client/ayon_hiero/plugins/publish_old_workflow/collect_tag_comments.html#client.ayon_hiero.plugins.publish_old_workflow.collect_tag_comments.CollectClipTagComments","title":"<code>CollectClipTagComments</code>","text":"<p>               Bases: <code>InstancePlugin</code></p> <p>Collect comments from tags on selected track items and their sources.</p> Source code in <code>client/ayon_hiero/plugins/publish_old_workflow/collect_tag_comments.py</code> <pre><code>class CollectClipTagComments(api.InstancePlugin):\n    \"\"\"Collect comments from tags on selected track items and their sources.\"\"\"\n\n    order = api.CollectorOrder + 0.013\n    label = \"Collect Comments\"\n    hosts = [\"hiero\"]\n    families = [\"clip\"]\n\n    def process(self, instance):\n        # Collect comments.\n        instance.data[\"comments\"] = []\n\n        # Exclude non-tagged instances.\n        for tag in instance.data[\"tags\"]:\n            if tag[\"name\"].lower() == \"comment\":\n                instance.data[\"comments\"].append(\n                    tag[\"metadata\"][\"tag.note\"]\n                )\n\n        # Find tags on the source clip.\n        tags = instance.data[\"item\"].source().tags()\n        for tag in tags:\n            if tag.name().lower() == \"comment\":\n                instance.data[\"comments\"].append(\n                    tag.metadata().dict()[\"tag.note\"]\n                )\n\n        # Update label with comments counter.\n        instance.data[\"label\"] = \"{} - comments:{}\".format(\n            instance.data[\"label\"],\n            len(instance.data[\"comments\"])\n        )\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/plugins/publish_old_workflow/precollect_retime.html","title":"precollect_retime","text":""},{"location":"autoapi/client/ayon_hiero/plugins/publish_old_workflow/precollect_retime.html#client.ayon_hiero.plugins.publish_old_workflow.precollect_retime.PrecollectRetime","title":"<code>PrecollectRetime</code>","text":"<p>               Bases: <code>InstancePlugin</code></p> <p>Calculate Retiming of selected track items.</p> Source code in <code>client/ayon_hiero/plugins/publish_old_workflow/precollect_retime.py</code> <pre><code>class PrecollectRetime(api.InstancePlugin):\n    \"\"\"Calculate Retiming of selected track items.\"\"\"\n\n    order = api.CollectorOrder - 0.578\n    label = \"Precollect Retime\"\n    hosts = [\"hiero\"]\n    families = ['retime_']\n\n    def process(self, instance):\n        if not instance.data.get(\"versionData\"):\n            instance.data[\"versionData\"] = {}\n\n        # get basic variables\n        otio_clip = instance.data[\"otioClip\"]\n\n        source_range = otio_clip.source_range\n        oc_source_fps = source_range.start_time.rate\n        oc_source_in = source_range.start_time.value\n\n        handle_start = instance.data[\"handleStart\"]\n        handle_end = instance.data[\"handleEnd\"]\n        frame_start = instance.data[\"frameStart\"]\n\n        track_item = instance.data[\"item\"]\n\n        # define basic clip frame range variables\n        timeline_in = int(track_item.timelineIn())\n        timeline_out = int(track_item.timelineOut())\n        source_in = int(track_item.sourceIn())\n        source_out = int(track_item.sourceOut())\n        speed = track_item.playbackSpeed()\n\n        self.log.debug((\n            \"_BEFORE: \\n timeline_in: `{0}`,\\n timeline_out: `{1}`, \\n \"\n            \"source_in: `{2}`,\\n source_out: `{3}`,\\n speed: `{4}`,\\n \"\n            \"handle_start: `{5}`,\\n handle_end: `{6}`\").format(\n                timeline_in,\n                timeline_out,\n                source_in,\n                source_out,\n                speed,\n                handle_start,\n                handle_end\n        ))\n\n        # loop within subtrack items\n        time_warp_nodes = []\n        source_in_change = 0\n        source_out_change = 0\n        for s_track_item in track_item.linkedItems():\n            if isinstance(s_track_item, hiero.core.EffectTrackItem) \\\n                    and \"TimeWarp\" in s_track_item.node().Class():\n\n                # adding timewarp attribute to instance\n                time_warp_nodes = []\n\n                # ignore item if not enabled\n                if s_track_item.isEnabled():\n                    node = s_track_item.node()\n                    name = node[\"name\"].value()\n                    look_up = node[\"lookup\"].value()\n                    animated = node[\"lookup\"].isAnimated()\n                    if animated:\n                        look_up = [\n                            ((node[\"lookup\"].getValueAt(i)) - i)\n                            for i in range(\n                                (timeline_in - handle_start),\n                                (timeline_out + handle_end) + 1)\n                        ]\n                        # calculate difference\n                        diff_in = (node[\"lookup\"].getValueAt(\n                            timeline_in)) - timeline_in\n                        diff_out = (node[\"lookup\"].getValueAt(\n                            timeline_out)) - timeline_out\n\n                        # calculate source\n                        source_in_change += diff_in\n                        source_out_change += diff_out\n\n                        # calculate speed\n                        speed_in = (node[\"lookup\"].getValueAt(timeline_in) / (\n                            float(timeline_in) * .01)) * .01\n                        speed_out = (node[\"lookup\"].getValueAt(timeline_out) / (\n                            float(timeline_out) * .01)) * .01\n\n                        # calculate handles\n                        handle_start = int(\n                            math.ceil(\n                                (handle_start * speed_in * 1000) / 1000.0)\n                        )\n\n                        handle_end = int(\n                            math.ceil(\n                                (handle_end * speed_out * 1000) / 1000.0)\n                        )\n                        self.log.debug(\n                            (\"diff_in, diff_out\", diff_in, diff_out))\n                        self.log.debug(\n                            (\"source_in_change, source_out_change\",\n                             source_in_change, source_out_change))\n\n                    time_warp_nodes.append({\n                        \"Class\": \"TimeWarp\",\n                        \"name\": name,\n                        \"lookup\": look_up\n                    })\n\n        self.log.debug(\n            \"timewarp source in changes: in {}, out {}\".format(\n                source_in_change, source_out_change))\n\n        # recalculate handles by the speed\n        handle_start *= speed\n        handle_end *= speed\n        self.log.debug(\"speed: handle_start: '{0}', handle_end: '{1}'\".format(\n            handle_start, handle_end))\n\n        # recalculate source with timewarp and by the speed\n        source_in += int(source_in_change)\n        source_out += int(source_out_change * speed)\n\n        source_in_h = int(source_in - math.ceil(\n            (handle_start * 1000) / 1000.0))\n        source_out_h = int(source_out + math.ceil(\n            (handle_end * 1000) / 1000.0))\n\n        self.log.debug(\n            \"retimed: source_in_h: '{0}', source_out_h: '{1}'\".format(\n                source_in_h, source_out_h))\n\n        # add all data to Instance\n        instance.data[\"handleStart\"] = handle_start\n        instance.data[\"handleEnd\"] = handle_end\n        instance.data[\"sourceIn\"] = source_in\n        instance.data[\"sourceOut\"] = source_out\n        instance.data[\"sourceInH\"] = source_in_h\n        instance.data[\"sourceOutH\"] = source_out_h\n        instance.data[\"speed\"] = speed\n\n        source_handle_start = source_in_h - source_in\n        # frame_start = instance.data[\"frameStart\"] + source_handle_start\n        duration = source_out_h - source_in_h\n        frame_end = int(frame_start + duration - (handle_start + handle_end))\n\n        instance.data[\"versionData\"].update({\n            \"retime\": True,\n            \"speed\": speed,\n            \"timewarps\": time_warp_nodes,\n            \"frameStart\": frame_start,\n            \"frameEnd\": frame_end,\n            \"handleStart\": abs(source_handle_start),\n            \"handleEnd\": source_out_h - source_out\n        })\n        self.log.debug(\"versionData: {}\".format(instance.data[\"versionData\"]))\n        self.log.debug(\"sourceIn: {}\".format(instance.data[\"sourceIn\"]))\n        self.log.debug(\"sourceOut: {}\".format(instance.data[\"sourceOut\"]))\n        self.log.debug(\"speed: {}\".format(instance.data[\"speed\"]))\n\n        # change otio clip data\n        instance.data[\"otioClip\"].source_range = create_otio_time_range(\n            oc_source_in, (source_out - source_in + 1), oc_source_fps)\n        self.log.debug(\"otioClip: {}\".format(instance.data[\"otioClip\"]))\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/index.html","title":"vendor","text":""},{"location":"autoapi/client/ayon_hiero/vendor/google/index.html","title":"google","text":""},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/index.html","title":"protobuf","text":""},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/any_pb2.html","title":"any_pb2","text":"<p>Generated protocol buffer code.</p>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/api_pb2.html","title":"api_pb2","text":"<p>Generated protocol buffer code.</p>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/descriptor.html","title":"descriptor","text":"<p>Descriptors essentially contain exactly the information found in a .proto file, in types that make this information accessible in Python.</p>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/descriptor.html#client.ayon_hiero.vendor.google.protobuf.descriptor.Descriptor","title":"<code>Descriptor</code>","text":"<p>               Bases: <code>_NestedDescriptorBase</code></p> <p>Descriptor for a protocol message type.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Name of this protocol message type.</p> <code>full_name</code> <code>str</code> <p>Fully-qualified name of this protocol message type, which will include protocol \"package\" name and the name of any enclosing types.</p> <code>containing_type</code> <code>Descriptor</code> <p>Reference to the descriptor of the type containing us, or None if this is top-level.</p> <code>fields</code> <code>list[FieldDescriptor]</code> <p>Field descriptors for all fields in this type.</p> <code>fields_by_number</code> <code>dict(int, FieldDescriptor</code> <p>Same :class:<code>FieldDescriptor</code> objects as in :attr:<code>fields</code>, but indexed by \"number\" attribute in each FieldDescriptor.</p> <code>fields_by_name</code> <code>dict(str, FieldDescriptor</code> <p>Same :class:<code>FieldDescriptor</code> objects as in :attr:<code>fields</code>, but indexed by \"name\" attribute in each :class:<code>FieldDescriptor</code>.</p> <code>nested_types</code> <code>list[Descriptor]</code> <p>Descriptor references for all protocol message types nested within this one.</p> <code>nested_types_by_name</code> <code>dict(str, Descriptor</code> <p>Same Descriptor objects as in :attr:<code>nested_types</code>, but indexed by \"name\" attribute in each Descriptor.</p> <code>enum_types</code> <code>list[EnumDescriptor]</code> <p>:class:<code>EnumDescriptor</code> references for all enums contained within this type.</p> <code>enum_types_by_name</code> <code>dict(str, EnumDescriptor</code> <p>Same :class:<code>EnumDescriptor</code> objects as in :attr:<code>enum_types</code>, but indexed by \"name\" attribute in each EnumDescriptor.</p> <code>enum_values_by_name</code> <code>dict(str, EnumValueDescriptor</code> <p>Dict mapping from enum value name to :class:<code>EnumValueDescriptor</code> for that value.</p> <code>extensions</code> <code>list[FieldDescriptor]</code> <p>All extensions defined directly within this message type (NOT within a nested type).</p> <code>extensions_by_name</code> <code>dict(str, FieldDescriptor</code> <p>Same FieldDescriptor objects as :attr:<code>extensions</code>, but indexed by \"name\" attribute of each FieldDescriptor.</p> <code>is_extendable</code> <code>bool</code> <p>Does this type define any extension ranges?</p> <code>oneofs</code> <code>list[OneofDescriptor]</code> <p>The list of descriptors for oneof fields in this message.</p> <code>oneofs_by_name</code> <code>dict(str, OneofDescriptor</code> <p>Same objects as in :attr:<code>oneofs</code>, but indexed by \"name\" attribute.</p> <code>file</code> <code>FileDescriptor</code> <p>Reference to file descriptor.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/descriptor.py</code> <pre><code>class Descriptor(_NestedDescriptorBase):\n\n  \"\"\"Descriptor for a protocol message type.\n\n  Attributes:\n      name (str): Name of this protocol message type.\n      full_name (str): Fully-qualified name of this protocol message type,\n          which will include protocol \"package\" name and the name of any\n          enclosing types.\n      containing_type (Descriptor): Reference to the descriptor of the type\n          containing us, or None if this is top-level.\n      fields (list[FieldDescriptor]): Field descriptors for all fields in\n          this type.\n      fields_by_number (dict(int, FieldDescriptor)): Same\n          :class:`FieldDescriptor` objects as in :attr:`fields`, but indexed\n          by \"number\" attribute in each FieldDescriptor.\n      fields_by_name (dict(str, FieldDescriptor)): Same\n          :class:`FieldDescriptor` objects as in :attr:`fields`, but indexed by\n          \"name\" attribute in each :class:`FieldDescriptor`.\n      nested_types (list[Descriptor]): Descriptor references\n          for all protocol message types nested within this one.\n      nested_types_by_name (dict(str, Descriptor)): Same Descriptor\n          objects as in :attr:`nested_types`, but indexed by \"name\" attribute\n          in each Descriptor.\n      enum_types (list[EnumDescriptor]): :class:`EnumDescriptor` references\n          for all enums contained within this type.\n      enum_types_by_name (dict(str, EnumDescriptor)): Same\n          :class:`EnumDescriptor` objects as in :attr:`enum_types`, but\n          indexed by \"name\" attribute in each EnumDescriptor.\n      enum_values_by_name (dict(str, EnumValueDescriptor)): Dict mapping\n          from enum value name to :class:`EnumValueDescriptor` for that value.\n      extensions (list[FieldDescriptor]): All extensions defined directly\n          within this message type (NOT within a nested type).\n      extensions_by_name (dict(str, FieldDescriptor)): Same FieldDescriptor\n          objects as :attr:`extensions`, but indexed by \"name\" attribute of each\n          FieldDescriptor.\n      is_extendable (bool):  Does this type define any extension ranges?\n      oneofs (list[OneofDescriptor]): The list of descriptors for oneof fields\n          in this message.\n      oneofs_by_name (dict(str, OneofDescriptor)): Same objects as in\n          :attr:`oneofs`, but indexed by \"name\" attribute.\n      file (FileDescriptor): Reference to file descriptor.\n\n  \"\"\"\n\n  if _USE_C_DESCRIPTORS:\n    _C_DESCRIPTOR_CLASS = _message.Descriptor\n\n    def __new__(\n        cls,\n        name=None,\n        full_name=None,\n        filename=None,\n        containing_type=None,\n        fields=None,\n        nested_types=None,\n        enum_types=None,\n        extensions=None,\n        options=None,\n        serialized_options=None,\n        is_extendable=True,\n        extension_ranges=None,\n        oneofs=None,\n        file=None,  # pylint: disable=redefined-builtin\n        serialized_start=None,\n        serialized_end=None,\n        syntax=None,\n        create_key=None):\n      _message.Message._CheckCalledFromGeneratedFile()\n      return _message.default_pool.FindMessageTypeByName(full_name)\n\n  # NOTE(tmarek): The file argument redefining a builtin is nothing we can\n  # fix right now since we don't know how many clients already rely on the\n  # name of the argument.\n  def __init__(self, name, full_name, filename, containing_type, fields,\n               nested_types, enum_types, extensions, options=None,\n               serialized_options=None,\n               is_extendable=True, extension_ranges=None, oneofs=None,\n               file=None, serialized_start=None, serialized_end=None,  # pylint: disable=redefined-builtin\n               syntax=None, create_key=None):\n    \"\"\"Arguments to __init__() are as described in the description\n    of Descriptor fields above.\n\n    Note that filename is an obsolete argument, that is not used anymore.\n    Please use file.name to access this as an attribute.\n    \"\"\"\n    if create_key is not _internal_create_key:\n      _Deprecated('Descriptor')\n\n    super(Descriptor, self).__init__(\n        options, 'MessageOptions', name, full_name, file,\n        containing_type, serialized_start=serialized_start,\n        serialized_end=serialized_end, serialized_options=serialized_options)\n\n    # We have fields in addition to fields_by_name and fields_by_number,\n    # so that:\n    #   1. Clients can index fields by \"order in which they're listed.\"\n    #   2. Clients can easily iterate over all fields with the terse\n    #      syntax: for f in descriptor.fields: ...\n    self.fields = fields\n    for field in self.fields:\n      field.containing_type = self\n    self.fields_by_number = dict((f.number, f) for f in fields)\n    self.fields_by_name = dict((f.name, f) for f in fields)\n    self._fields_by_camelcase_name = None\n\n    self.nested_types = nested_types\n    for nested_type in nested_types:\n      nested_type.containing_type = self\n    self.nested_types_by_name = dict((t.name, t) for t in nested_types)\n\n    self.enum_types = enum_types\n    for enum_type in self.enum_types:\n      enum_type.containing_type = self\n    self.enum_types_by_name = dict((t.name, t) for t in enum_types)\n    self.enum_values_by_name = dict(\n        (v.name, v) for t in enum_types for v in t.values)\n\n    self.extensions = extensions\n    for extension in self.extensions:\n      extension.extension_scope = self\n    self.extensions_by_name = dict((f.name, f) for f in extensions)\n    self.is_extendable = is_extendable\n    self.extension_ranges = extension_ranges\n    self.oneofs = oneofs if oneofs is not None else []\n    self.oneofs_by_name = dict((o.name, o) for o in self.oneofs)\n    for oneof in self.oneofs:\n      oneof.containing_type = self\n    self.syntax = syntax or \"proto2\"\n\n  @property\n  def fields_by_camelcase_name(self):\n    \"\"\"Same FieldDescriptor objects as in :attr:`fields`, but indexed by\n    :attr:`FieldDescriptor.camelcase_name`.\n    \"\"\"\n    if self._fields_by_camelcase_name is None:\n      self._fields_by_camelcase_name = dict(\n          (f.camelcase_name, f) for f in self.fields)\n    return self._fields_by_camelcase_name\n\n  def EnumValueName(self, enum, value):\n    \"\"\"Returns the string name of an enum value.\n\n    This is just a small helper method to simplify a common operation.\n\n    Args:\n      enum: string name of the Enum.\n      value: int, value of the enum.\n\n    Returns:\n      string name of the enum value.\n\n    Raises:\n      KeyError if either the Enum doesn't exist or the value is not a valid\n        value for the enum.\n    \"\"\"\n    return self.enum_types_by_name[enum].values_by_number[value].name\n\n  def CopyToProto(self, proto):\n    \"\"\"Copies this to a descriptor_pb2.DescriptorProto.\n\n    Args:\n      proto: An empty descriptor_pb2.DescriptorProto.\n    \"\"\"\n    # This function is overridden to give a better doc comment.\n    super(Descriptor, self).CopyToProto(proto)\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/descriptor.html#client.ayon_hiero.vendor.google.protobuf.descriptor.Descriptor.fields_by_camelcase_name","title":"<code>fields_by_camelcase_name</code>  <code>property</code>","text":"<p>Same FieldDescriptor objects as in :attr:<code>fields</code>, but indexed by :attr:<code>FieldDescriptor.camelcase_name</code>.</p>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/descriptor.html#client.ayon_hiero.vendor.google.protobuf.descriptor.Descriptor.CopyToProto","title":"<code>CopyToProto(proto)</code>","text":"<p>Copies this to a descriptor_pb2.DescriptorProto.</p> <p>Parameters:</p> Name Type Description Default <code>proto</code> <p>An empty descriptor_pb2.DescriptorProto.</p> required Source code in <code>client/ayon_hiero/vendor/google/protobuf/descriptor.py</code> <pre><code>def CopyToProto(self, proto):\n  \"\"\"Copies this to a descriptor_pb2.DescriptorProto.\n\n  Args:\n    proto: An empty descriptor_pb2.DescriptorProto.\n  \"\"\"\n  # This function is overridden to give a better doc comment.\n  super(Descriptor, self).CopyToProto(proto)\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/descriptor.html#client.ayon_hiero.vendor.google.protobuf.descriptor.Descriptor.EnumValueName","title":"<code>EnumValueName(enum, value)</code>","text":"<p>Returns the string name of an enum value.</p> <p>This is just a small helper method to simplify a common operation.</p> <p>Parameters:</p> Name Type Description Default <code>enum</code> <p>string name of the Enum.</p> required <code>value</code> <p>int, value of the enum.</p> required <p>Returns:</p> Type Description <p>string name of the enum value.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/descriptor.py</code> <pre><code>def EnumValueName(self, enum, value):\n  \"\"\"Returns the string name of an enum value.\n\n  This is just a small helper method to simplify a common operation.\n\n  Args:\n    enum: string name of the Enum.\n    value: int, value of the enum.\n\n  Returns:\n    string name of the enum value.\n\n  Raises:\n    KeyError if either the Enum doesn't exist or the value is not a valid\n      value for the enum.\n  \"\"\"\n  return self.enum_types_by_name[enum].values_by_number[value].name\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/descriptor.html#client.ayon_hiero.vendor.google.protobuf.descriptor.Descriptor.__init__","title":"<code>__init__(name, full_name, filename, containing_type, fields, nested_types, enum_types, extensions, options=None, serialized_options=None, is_extendable=True, extension_ranges=None, oneofs=None, file=None, serialized_start=None, serialized_end=None, syntax=None, create_key=None)</code>","text":"<p>Arguments to init() are as described in the description of Descriptor fields above.</p> <p>Note that filename is an obsolete argument, that is not used anymore. Please use file.name to access this as an attribute.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/descriptor.py</code> <pre><code>def __init__(self, name, full_name, filename, containing_type, fields,\n             nested_types, enum_types, extensions, options=None,\n             serialized_options=None,\n             is_extendable=True, extension_ranges=None, oneofs=None,\n             file=None, serialized_start=None, serialized_end=None,  # pylint: disable=redefined-builtin\n             syntax=None, create_key=None):\n  \"\"\"Arguments to __init__() are as described in the description\n  of Descriptor fields above.\n\n  Note that filename is an obsolete argument, that is not used anymore.\n  Please use file.name to access this as an attribute.\n  \"\"\"\n  if create_key is not _internal_create_key:\n    _Deprecated('Descriptor')\n\n  super(Descriptor, self).__init__(\n      options, 'MessageOptions', name, full_name, file,\n      containing_type, serialized_start=serialized_start,\n      serialized_end=serialized_end, serialized_options=serialized_options)\n\n  # We have fields in addition to fields_by_name and fields_by_number,\n  # so that:\n  #   1. Clients can index fields by \"order in which they're listed.\"\n  #   2. Clients can easily iterate over all fields with the terse\n  #      syntax: for f in descriptor.fields: ...\n  self.fields = fields\n  for field in self.fields:\n    field.containing_type = self\n  self.fields_by_number = dict((f.number, f) for f in fields)\n  self.fields_by_name = dict((f.name, f) for f in fields)\n  self._fields_by_camelcase_name = None\n\n  self.nested_types = nested_types\n  for nested_type in nested_types:\n    nested_type.containing_type = self\n  self.nested_types_by_name = dict((t.name, t) for t in nested_types)\n\n  self.enum_types = enum_types\n  for enum_type in self.enum_types:\n    enum_type.containing_type = self\n  self.enum_types_by_name = dict((t.name, t) for t in enum_types)\n  self.enum_values_by_name = dict(\n      (v.name, v) for t in enum_types for v in t.values)\n\n  self.extensions = extensions\n  for extension in self.extensions:\n    extension.extension_scope = self\n  self.extensions_by_name = dict((f.name, f) for f in extensions)\n  self.is_extendable = is_extendable\n  self.extension_ranges = extension_ranges\n  self.oneofs = oneofs if oneofs is not None else []\n  self.oneofs_by_name = dict((o.name, o) for o in self.oneofs)\n  for oneof in self.oneofs:\n    oneof.containing_type = self\n  self.syntax = syntax or \"proto2\"\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/descriptor.html#client.ayon_hiero.vendor.google.protobuf.descriptor.DescriptorBase","title":"<code>DescriptorBase</code>","text":"<p>Descriptors base class.</p> <p>This class is the base of all descriptor classes. It provides common options related functionality.</p> <p>Attributes:</p> Name Type Description <code>has_options</code> <p>True if the descriptor has non-default options.  Usually it   is not necessary to read this -- just call GetOptions() which will   happily return the default instance.  However, it's sometimes useful   for efficiency, and also useful inside the protobuf implementation to   avoid some bootstrapping issues.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/descriptor.py</code> <pre><code>class DescriptorBase(metaclass=DescriptorMetaclass):\n\n  \"\"\"Descriptors base class.\n\n  This class is the base of all descriptor classes. It provides common options\n  related functionality.\n\n  Attributes:\n    has_options:  True if the descriptor has non-default options.  Usually it\n        is not necessary to read this -- just call GetOptions() which will\n        happily return the default instance.  However, it's sometimes useful\n        for efficiency, and also useful inside the protobuf implementation to\n        avoid some bootstrapping issues.\n  \"\"\"\n\n  if _USE_C_DESCRIPTORS:\n    # The class, or tuple of classes, that are considered as \"virtual\n    # subclasses\" of this descriptor class.\n    _C_DESCRIPTOR_CLASS = ()\n\n  def __init__(self, options, serialized_options, options_class_name):\n    \"\"\"Initialize the descriptor given its options message and the name of the\n    class of the options message. The name of the class is required in case\n    the options message is None and has to be created.\n    \"\"\"\n    self._options = options\n    self._options_class_name = options_class_name\n    self._serialized_options = serialized_options\n\n    # Does this descriptor have non-default options?\n    self.has_options = (options is not None) or (serialized_options is not None)\n\n  def _SetOptions(self, options, options_class_name):\n    \"\"\"Sets the descriptor's options\n\n    This function is used in generated proto2 files to update descriptor\n    options. It must not be used outside proto2.\n    \"\"\"\n    self._options = options\n    self._options_class_name = options_class_name\n\n    # Does this descriptor have non-default options?\n    self.has_options = options is not None\n\n  def GetOptions(self):\n    \"\"\"Retrieves descriptor options.\n\n    This method returns the options set or creates the default options for the\n    descriptor.\n    \"\"\"\n    if self._options:\n      return self._options\n\n    from google.protobuf import descriptor_pb2\n    try:\n      options_class = getattr(descriptor_pb2,\n                              self._options_class_name)\n    except AttributeError:\n      raise RuntimeError('Unknown options class name %s!' %\n                         (self._options_class_name))\n\n    with _lock:\n      if self._serialized_options is None:\n        self._options = options_class()\n      else:\n        self._options = _ParseOptions(options_class(),\n                                      self._serialized_options)\n\n      return self._options\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/descriptor.html#client.ayon_hiero.vendor.google.protobuf.descriptor.DescriptorBase.GetOptions","title":"<code>GetOptions()</code>","text":"<p>Retrieves descriptor options.</p> <p>This method returns the options set or creates the default options for the descriptor.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/descriptor.py</code> <pre><code>def GetOptions(self):\n  \"\"\"Retrieves descriptor options.\n\n  This method returns the options set or creates the default options for the\n  descriptor.\n  \"\"\"\n  if self._options:\n    return self._options\n\n  from google.protobuf import descriptor_pb2\n  try:\n    options_class = getattr(descriptor_pb2,\n                            self._options_class_name)\n  except AttributeError:\n    raise RuntimeError('Unknown options class name %s!' %\n                       (self._options_class_name))\n\n  with _lock:\n    if self._serialized_options is None:\n      self._options = options_class()\n    else:\n      self._options = _ParseOptions(options_class(),\n                                    self._serialized_options)\n\n    return self._options\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/descriptor.html#client.ayon_hiero.vendor.google.protobuf.descriptor.DescriptorBase.__init__","title":"<code>__init__(options, serialized_options, options_class_name)</code>","text":"<p>Initialize the descriptor given its options message and the name of the class of the options message. The name of the class is required in case the options message is None and has to be created.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/descriptor.py</code> <pre><code>def __init__(self, options, serialized_options, options_class_name):\n  \"\"\"Initialize the descriptor given its options message and the name of the\n  class of the options message. The name of the class is required in case\n  the options message is None and has to be created.\n  \"\"\"\n  self._options = options\n  self._options_class_name = options_class_name\n  self._serialized_options = serialized_options\n\n  # Does this descriptor have non-default options?\n  self.has_options = (options is not None) or (serialized_options is not None)\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/descriptor.html#client.ayon_hiero.vendor.google.protobuf.descriptor.EnumDescriptor","title":"<code>EnumDescriptor</code>","text":"<p>               Bases: <code>_NestedDescriptorBase</code></p> <p>Descriptor for an enum defined in a .proto file.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Name of the enum type.</p> <code>full_name</code> <code>str</code> <p>Full name of the type, including package name and any enclosing type(s).</p> <code>values</code> <code>list[EnumValueDescriptor]</code> <p>List of the values in this enum.</p> <code>values_by_name</code> <code>dict(str, EnumValueDescriptor</code> <p>Same as :attr:<code>values</code>, but indexed by the \"name\" field of each EnumValueDescriptor.</p> <code>values_by_number</code> <code>dict(int, EnumValueDescriptor</code> <p>Same as :attr:<code>values</code>, but indexed by the \"number\" field of each EnumValueDescriptor.</p> <code>containing_type</code> <code>Descriptor</code> <p>Descriptor of the immediate containing type of this enum, or None if this is an enum defined at the top level in a .proto file.  Set by Descriptor's constructor if we're passed into one.</p> <code>file</code> <code>FileDescriptor</code> <p>Reference to file descriptor.</p> <code>options</code> <code>EnumOptions</code> <p>Enum options message or None to use default enum options.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/descriptor.py</code> <pre><code>class EnumDescriptor(_NestedDescriptorBase):\n\n  \"\"\"Descriptor for an enum defined in a .proto file.\n\n  Attributes:\n    name (str): Name of the enum type.\n    full_name (str): Full name of the type, including package name\n      and any enclosing type(s).\n\n    values (list[EnumValueDescriptor]): List of the values\n      in this enum.\n    values_by_name (dict(str, EnumValueDescriptor)): Same as :attr:`values`,\n      but indexed by the \"name\" field of each EnumValueDescriptor.\n    values_by_number (dict(int, EnumValueDescriptor)): Same as :attr:`values`,\n      but indexed by the \"number\" field of each EnumValueDescriptor.\n    containing_type (Descriptor): Descriptor of the immediate containing\n      type of this enum, or None if this is an enum defined at the\n      top level in a .proto file.  Set by Descriptor's constructor\n      if we're passed into one.\n    file (FileDescriptor): Reference to file descriptor.\n    options (descriptor_pb2.EnumOptions): Enum options message or\n      None to use default enum options.\n  \"\"\"\n\n  if _USE_C_DESCRIPTORS:\n    _C_DESCRIPTOR_CLASS = _message.EnumDescriptor\n\n    def __new__(cls, name, full_name, filename, values,\n                containing_type=None, options=None,\n                serialized_options=None, file=None,  # pylint: disable=redefined-builtin\n                serialized_start=None, serialized_end=None, create_key=None):\n      _message.Message._CheckCalledFromGeneratedFile()\n      return _message.default_pool.FindEnumTypeByName(full_name)\n\n  def __init__(self, name, full_name, filename, values,\n               containing_type=None, options=None,\n               serialized_options=None, file=None,  # pylint: disable=redefined-builtin\n               serialized_start=None, serialized_end=None, create_key=None):\n    \"\"\"Arguments are as described in the attribute description above.\n\n    Note that filename is an obsolete argument, that is not used anymore.\n    Please use file.name to access this as an attribute.\n    \"\"\"\n    if create_key is not _internal_create_key:\n      _Deprecated('EnumDescriptor')\n\n    super(EnumDescriptor, self).__init__(\n        options, 'EnumOptions', name, full_name, file,\n        containing_type, serialized_start=serialized_start,\n        serialized_end=serialized_end, serialized_options=serialized_options)\n\n    self.values = values\n    for value in self.values:\n      value.type = self\n    self.values_by_name = dict((v.name, v) for v in values)\n    # Values are reversed to ensure that the first alias is retained.\n    self.values_by_number = dict((v.number, v) for v in reversed(values))\n\n  def CopyToProto(self, proto):\n    \"\"\"Copies this to a descriptor_pb2.EnumDescriptorProto.\n\n    Args:\n      proto (descriptor_pb2.EnumDescriptorProto): An empty descriptor proto.\n    \"\"\"\n    # This function is overridden to give a better doc comment.\n    super(EnumDescriptor, self).CopyToProto(proto)\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/descriptor.html#client.ayon_hiero.vendor.google.protobuf.descriptor.EnumDescriptor.CopyToProto","title":"<code>CopyToProto(proto)</code>","text":"<p>Copies this to a descriptor_pb2.EnumDescriptorProto.</p> <p>Parameters:</p> Name Type Description Default <code>proto</code> <code>EnumDescriptorProto</code> <p>An empty descriptor proto.</p> required Source code in <code>client/ayon_hiero/vendor/google/protobuf/descriptor.py</code> <pre><code>def CopyToProto(self, proto):\n  \"\"\"Copies this to a descriptor_pb2.EnumDescriptorProto.\n\n  Args:\n    proto (descriptor_pb2.EnumDescriptorProto): An empty descriptor proto.\n  \"\"\"\n  # This function is overridden to give a better doc comment.\n  super(EnumDescriptor, self).CopyToProto(proto)\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/descriptor.html#client.ayon_hiero.vendor.google.protobuf.descriptor.EnumDescriptor.__init__","title":"<code>__init__(name, full_name, filename, values, containing_type=None, options=None, serialized_options=None, file=None, serialized_start=None, serialized_end=None, create_key=None)</code>","text":"<p>Arguments are as described in the attribute description above.</p> <p>Note that filename is an obsolete argument, that is not used anymore. Please use file.name to access this as an attribute.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/descriptor.py</code> <pre><code>def __init__(self, name, full_name, filename, values,\n             containing_type=None, options=None,\n             serialized_options=None, file=None,  # pylint: disable=redefined-builtin\n             serialized_start=None, serialized_end=None, create_key=None):\n  \"\"\"Arguments are as described in the attribute description above.\n\n  Note that filename is an obsolete argument, that is not used anymore.\n  Please use file.name to access this as an attribute.\n  \"\"\"\n  if create_key is not _internal_create_key:\n    _Deprecated('EnumDescriptor')\n\n  super(EnumDescriptor, self).__init__(\n      options, 'EnumOptions', name, full_name, file,\n      containing_type, serialized_start=serialized_start,\n      serialized_end=serialized_end, serialized_options=serialized_options)\n\n  self.values = values\n  for value in self.values:\n    value.type = self\n  self.values_by_name = dict((v.name, v) for v in values)\n  # Values are reversed to ensure that the first alias is retained.\n  self.values_by_number = dict((v.number, v) for v in reversed(values))\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/descriptor.html#client.ayon_hiero.vendor.google.protobuf.descriptor.EnumValueDescriptor","title":"<code>EnumValueDescriptor</code>","text":"<p>               Bases: <code>DescriptorBase</code></p> <p>Descriptor for a single value within an enum.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Name of this value.</p> <code>index</code> <code>int</code> <p>Dense, 0-indexed index giving the order that this value appears textually within its enum in the .proto file.</p> <code>number</code> <code>int</code> <p>Actual number assigned to this enum value.</p> <code>type</code> <code>EnumDescriptor</code> <p>:class:<code>EnumDescriptor</code> to which this value belongs.  Set by :class:<code>EnumDescriptor</code>'s constructor if we're passed into one.</p> <code>options</code> <code>EnumValueOptions</code> <p>Enum value options message or None to use default enum value options options.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/descriptor.py</code> <pre><code>class EnumValueDescriptor(DescriptorBase):\n\n  \"\"\"Descriptor for a single value within an enum.\n\n  Attributes:\n    name (str): Name of this value.\n    index (int): Dense, 0-indexed index giving the order that this\n      value appears textually within its enum in the .proto file.\n    number (int): Actual number assigned to this enum value.\n    type (EnumDescriptor): :class:`EnumDescriptor` to which this value\n      belongs.  Set by :class:`EnumDescriptor`'s constructor if we're\n      passed into one.\n    options (descriptor_pb2.EnumValueOptions): Enum value options message or\n      None to use default enum value options options.\n  \"\"\"\n\n  if _USE_C_DESCRIPTORS:\n    _C_DESCRIPTOR_CLASS = _message.EnumValueDescriptor\n\n    def __new__(cls, name, index, number,\n                type=None,  # pylint: disable=redefined-builtin\n                options=None, serialized_options=None, create_key=None):\n      _message.Message._CheckCalledFromGeneratedFile()\n      # There is no way we can build a complete EnumValueDescriptor with the\n      # given parameters (the name of the Enum is not known, for example).\n      # Fortunately generated files just pass it to the EnumDescriptor()\n      # constructor, which will ignore it, so returning None is good enough.\n      return None\n\n  def __init__(self, name, index, number,\n               type=None,  # pylint: disable=redefined-builtin\n               options=None, serialized_options=None, create_key=None):\n    \"\"\"Arguments are as described in the attribute description above.\"\"\"\n    if create_key is not _internal_create_key:\n      _Deprecated('EnumValueDescriptor')\n\n    super(EnumValueDescriptor, self).__init__(\n        options, serialized_options, 'EnumValueOptions')\n    self.name = name\n    self.index = index\n    self.number = number\n    self.type = type\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/descriptor.html#client.ayon_hiero.vendor.google.protobuf.descriptor.EnumValueDescriptor.__init__","title":"<code>__init__(name, index, number, type=None, options=None, serialized_options=None, create_key=None)</code>","text":"<p>Arguments are as described in the attribute description above.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/descriptor.py</code> <pre><code>def __init__(self, name, index, number,\n             type=None,  # pylint: disable=redefined-builtin\n             options=None, serialized_options=None, create_key=None):\n  \"\"\"Arguments are as described in the attribute description above.\"\"\"\n  if create_key is not _internal_create_key:\n    _Deprecated('EnumValueDescriptor')\n\n  super(EnumValueDescriptor, self).__init__(\n      options, serialized_options, 'EnumValueOptions')\n  self.name = name\n  self.index = index\n  self.number = number\n  self.type = type\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/descriptor.html#client.ayon_hiero.vendor.google.protobuf.descriptor.Error","title":"<code>Error</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Base error for this module.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/descriptor.py</code> <pre><code>class Error(Exception):\n  \"\"\"Base error for this module.\"\"\"\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/descriptor.html#client.ayon_hiero.vendor.google.protobuf.descriptor.FieldDescriptor","title":"<code>FieldDescriptor</code>","text":"<p>               Bases: <code>DescriptorBase</code></p> <p>Descriptor for a single field in a .proto file.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Name of this field, exactly as it appears in .proto.</p> <code>full_name</code> <code>str</code> <p>Name of this field, including containing scope.  This is particularly relevant for extensions.</p> <code>index</code> <code>int</code> <p>Dense, 0-indexed index giving the order that this field textually appears within its message in the .proto file.</p> <code>number</code> <code>int</code> <p>Tag number declared for this field in the .proto file.</p> <code>type</code> <code>int</code> <p>(One of the TYPE_* constants below) Declared type.</p> <code>cpp_type</code> <code>int</code> <p>(One of the CPPTYPE_* constants below) C++ type used to represent this field.</p> <code>label</code> <code>int</code> <p>(One of the LABEL_* constants below) Tells whether this field is optional, required, or repeated.</p> <code>has_default_value</code> <code>bool</code> <p>True if this field has a default value defined, otherwise false.</p> <code>default_value</code> <code>Varies</code> <p>Default value of this field.  Only meaningful for non-repeated scalar fields.  Repeated fields should always set this to [], and non-repeated composite fields should always set this to None.</p> <code>containing_type</code> <code>Descriptor</code> <p>Descriptor of the protocol message type that contains this field.  Set by the Descriptor constructor if we're passed into one. Somewhat confusingly, for extension fields, this is the descriptor of the EXTENDED message, not the descriptor of the message containing this field.  (See is_extension and extension_scope below).</p> <code>message_type</code> <code>Descriptor</code> <p>If a composite field, a descriptor of the message type contained in this field.  Otherwise, this is None.</p> <code>enum_type</code> <code>EnumDescriptor</code> <p>If this field contains an enum, a descriptor of that enum.  Otherwise, this is None.</p> <code>is_extension</code> <p>True iff this describes an extension field.</p> <code>extension_scope</code> <code>Descriptor</code> <p>Only meaningful if is_extension is True. Gives the message that immediately contains this extension field. Will be None iff we're a top-level (file-level) extension field.</p> <code>options</code> <code>FieldOptions</code> <p>Protocol message field options or None to use default field options.</p> <code>containing_oneof</code> <code>OneofDescriptor</code> <p>If the field is a member of a oneof union, contains its descriptor. Otherwise, None.</p> <code>file</code> <code>FileDescriptor</code> <p>Reference to file descriptor.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/descriptor.py</code> <pre><code>class FieldDescriptor(DescriptorBase):\n\n  \"\"\"Descriptor for a single field in a .proto file.\n\n  Attributes:\n    name (str): Name of this field, exactly as it appears in .proto.\n    full_name (str): Name of this field, including containing scope.  This is\n      particularly relevant for extensions.\n    index (int): Dense, 0-indexed index giving the order that this\n      field textually appears within its message in the .proto file.\n    number (int): Tag number declared for this field in the .proto file.\n\n    type (int): (One of the TYPE_* constants below) Declared type.\n    cpp_type (int): (One of the CPPTYPE_* constants below) C++ type used to\n      represent this field.\n\n    label (int): (One of the LABEL_* constants below) Tells whether this\n      field is optional, required, or repeated.\n    has_default_value (bool): True if this field has a default value defined,\n      otherwise false.\n    default_value (Varies): Default value of this field.  Only\n      meaningful for non-repeated scalar fields.  Repeated fields\n      should always set this to [], and non-repeated composite\n      fields should always set this to None.\n\n    containing_type (Descriptor): Descriptor of the protocol message\n      type that contains this field.  Set by the Descriptor constructor\n      if we're passed into one.\n      Somewhat confusingly, for extension fields, this is the\n      descriptor of the EXTENDED message, not the descriptor\n      of the message containing this field.  (See is_extension and\n      extension_scope below).\n    message_type (Descriptor): If a composite field, a descriptor\n      of the message type contained in this field.  Otherwise, this is None.\n    enum_type (EnumDescriptor): If this field contains an enum, a\n      descriptor of that enum.  Otherwise, this is None.\n\n    is_extension: True iff this describes an extension field.\n    extension_scope (Descriptor): Only meaningful if is_extension is True.\n      Gives the message that immediately contains this extension field.\n      Will be None iff we're a top-level (file-level) extension field.\n\n    options (descriptor_pb2.FieldOptions): Protocol message field options or\n      None to use default field options.\n\n    containing_oneof (OneofDescriptor): If the field is a member of a oneof\n      union, contains its descriptor. Otherwise, None.\n\n    file (FileDescriptor): Reference to file descriptor.\n  \"\"\"\n\n  # Must be consistent with C++ FieldDescriptor::Type enum in\n  # descriptor.h.\n  #\n  # TODO(robinson): Find a way to eliminate this repetition.\n  TYPE_DOUBLE         = 1\n  TYPE_FLOAT          = 2\n  TYPE_INT64          = 3\n  TYPE_UINT64         = 4\n  TYPE_INT32          = 5\n  TYPE_FIXED64        = 6\n  TYPE_FIXED32        = 7\n  TYPE_BOOL           = 8\n  TYPE_STRING         = 9\n  TYPE_GROUP          = 10\n  TYPE_MESSAGE        = 11\n  TYPE_BYTES          = 12\n  TYPE_UINT32         = 13\n  TYPE_ENUM           = 14\n  TYPE_SFIXED32       = 15\n  TYPE_SFIXED64       = 16\n  TYPE_SINT32         = 17\n  TYPE_SINT64         = 18\n  MAX_TYPE            = 18\n\n  # Must be consistent with C++ FieldDescriptor::CppType enum in\n  # descriptor.h.\n  #\n  # TODO(robinson): Find a way to eliminate this repetition.\n  CPPTYPE_INT32       = 1\n  CPPTYPE_INT64       = 2\n  CPPTYPE_UINT32      = 3\n  CPPTYPE_UINT64      = 4\n  CPPTYPE_DOUBLE      = 5\n  CPPTYPE_FLOAT       = 6\n  CPPTYPE_BOOL        = 7\n  CPPTYPE_ENUM        = 8\n  CPPTYPE_STRING      = 9\n  CPPTYPE_MESSAGE     = 10\n  MAX_CPPTYPE         = 10\n\n  _PYTHON_TO_CPP_PROTO_TYPE_MAP = {\n      TYPE_DOUBLE: CPPTYPE_DOUBLE,\n      TYPE_FLOAT: CPPTYPE_FLOAT,\n      TYPE_ENUM: CPPTYPE_ENUM,\n      TYPE_INT64: CPPTYPE_INT64,\n      TYPE_SINT64: CPPTYPE_INT64,\n      TYPE_SFIXED64: CPPTYPE_INT64,\n      TYPE_UINT64: CPPTYPE_UINT64,\n      TYPE_FIXED64: CPPTYPE_UINT64,\n      TYPE_INT32: CPPTYPE_INT32,\n      TYPE_SFIXED32: CPPTYPE_INT32,\n      TYPE_SINT32: CPPTYPE_INT32,\n      TYPE_UINT32: CPPTYPE_UINT32,\n      TYPE_FIXED32: CPPTYPE_UINT32,\n      TYPE_BYTES: CPPTYPE_STRING,\n      TYPE_STRING: CPPTYPE_STRING,\n      TYPE_BOOL: CPPTYPE_BOOL,\n      TYPE_MESSAGE: CPPTYPE_MESSAGE,\n      TYPE_GROUP: CPPTYPE_MESSAGE\n      }\n\n  # Must be consistent with C++ FieldDescriptor::Label enum in\n  # descriptor.h.\n  #\n  # TODO(robinson): Find a way to eliminate this repetition.\n  LABEL_OPTIONAL      = 1\n  LABEL_REQUIRED      = 2\n  LABEL_REPEATED      = 3\n  MAX_LABEL           = 3\n\n  # Must be consistent with C++ constants kMaxNumber, kFirstReservedNumber,\n  # and kLastReservedNumber in descriptor.h\n  MAX_FIELD_NUMBER = (1 &lt;&lt; 29) - 1\n  FIRST_RESERVED_FIELD_NUMBER = 19000\n  LAST_RESERVED_FIELD_NUMBER = 19999\n\n  if _USE_C_DESCRIPTORS:\n    _C_DESCRIPTOR_CLASS = _message.FieldDescriptor\n\n    def __new__(cls, name, full_name, index, number, type, cpp_type, label,\n                default_value, message_type, enum_type, containing_type,\n                is_extension, extension_scope, options=None,\n                serialized_options=None,\n                has_default_value=True, containing_oneof=None, json_name=None,\n                file=None, create_key=None):  # pylint: disable=redefined-builtin\n      _message.Message._CheckCalledFromGeneratedFile()\n      if is_extension:\n        return _message.default_pool.FindExtensionByName(full_name)\n      else:\n        return _message.default_pool.FindFieldByName(full_name)\n\n  def __init__(self, name, full_name, index, number, type, cpp_type, label,\n               default_value, message_type, enum_type, containing_type,\n               is_extension, extension_scope, options=None,\n               serialized_options=None,\n               has_default_value=True, containing_oneof=None, json_name=None,\n               file=None, create_key=None):  # pylint: disable=redefined-builtin\n    \"\"\"The arguments are as described in the description of FieldDescriptor\n    attributes above.\n\n    Note that containing_type may be None, and may be set later if necessary\n    (to deal with circular references between message types, for example).\n    Likewise for extension_scope.\n    \"\"\"\n    if create_key is not _internal_create_key:\n      _Deprecated('FieldDescriptor')\n\n    super(FieldDescriptor, self).__init__(\n        options, serialized_options, 'FieldOptions')\n    self.name = name\n    self.full_name = full_name\n    self.file = file\n    self._camelcase_name = None\n    if json_name is None:\n      self.json_name = _ToJsonName(name)\n    else:\n      self.json_name = json_name\n    self.index = index\n    self.number = number\n    self.type = type\n    self.cpp_type = cpp_type\n    self.label = label\n    self.has_default_value = has_default_value\n    self.default_value = default_value\n    self.containing_type = containing_type\n    self.message_type = message_type\n    self.enum_type = enum_type\n    self.is_extension = is_extension\n    self.extension_scope = extension_scope\n    self.containing_oneof = containing_oneof\n    if api_implementation.Type() == 'cpp':\n      if is_extension:\n        self._cdescriptor = _message.default_pool.FindExtensionByName(full_name)\n      else:\n        self._cdescriptor = _message.default_pool.FindFieldByName(full_name)\n    else:\n      self._cdescriptor = None\n\n  @property\n  def camelcase_name(self):\n    \"\"\"Camelcase name of this field.\n\n    Returns:\n      str: the name in CamelCase.\n    \"\"\"\n    if self._camelcase_name is None:\n      self._camelcase_name = _ToCamelCase(self.name)\n    return self._camelcase_name\n\n  @property\n  def has_presence(self):\n    \"\"\"Whether the field distinguishes between unpopulated and default values.\n\n    Raises:\n      RuntimeError: singular field that is not linked with message nor file.\n    \"\"\"\n    if self.label == FieldDescriptor.LABEL_REPEATED:\n      return False\n    if (self.cpp_type == FieldDescriptor.CPPTYPE_MESSAGE or\n        self.containing_oneof):\n      return True\n    if hasattr(self.file, 'syntax'):\n      return self.file.syntax == 'proto2'\n    if hasattr(self.message_type, 'syntax'):\n      return self.message_type.syntax == 'proto2'\n    raise RuntimeError(\n        'has_presence is not ready to use because field %s is not'\n        ' linked with message type nor file' % self.full_name)\n\n  @staticmethod\n  def ProtoTypeToCppProtoType(proto_type):\n    \"\"\"Converts from a Python proto type to a C++ Proto Type.\n\n    The Python ProtocolBuffer classes specify both the 'Python' datatype and the\n    'C++' datatype - and they're not the same. This helper method should\n    translate from one to another.\n\n    Args:\n      proto_type: the Python proto type (descriptor.FieldDescriptor.TYPE_*)\n    Returns:\n      int: descriptor.FieldDescriptor.CPPTYPE_*, the C++ type.\n    Raises:\n      TypeTransformationError: when the Python proto type isn't known.\n    \"\"\"\n    try:\n      return FieldDescriptor._PYTHON_TO_CPP_PROTO_TYPE_MAP[proto_type]\n    except KeyError:\n      raise TypeTransformationError('Unknown proto_type: %s' % proto_type)\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/descriptor.html#client.ayon_hiero.vendor.google.protobuf.descriptor.FieldDescriptor.camelcase_name","title":"<code>camelcase_name</code>  <code>property</code>","text":"<p>Camelcase name of this field.</p> <p>Returns:</p> Name Type Description <code>str</code> <p>the name in CamelCase.</p>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/descriptor.html#client.ayon_hiero.vendor.google.protobuf.descriptor.FieldDescriptor.has_presence","title":"<code>has_presence</code>  <code>property</code>","text":"<p>Whether the field distinguishes between unpopulated and default values.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>singular field that is not linked with message nor file.</p>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/descriptor.html#client.ayon_hiero.vendor.google.protobuf.descriptor.FieldDescriptor.ProtoTypeToCppProtoType","title":"<code>ProtoTypeToCppProtoType(proto_type)</code>  <code>staticmethod</code>","text":"<p>Converts from a Python proto type to a C++ Proto Type.</p> <p>The Python ProtocolBuffer classes specify both the 'Python' datatype and the 'C++' datatype - and they're not the same. This helper method should translate from one to another.</p> <p>Parameters:</p> Name Type Description Default <code>proto_type</code> <p>the Python proto type (descriptor.FieldDescriptor.TYPE_*)</p> required <p>Returns:   int: descriptor.FieldDescriptor.CPPTYPE_*, the C++ type. Raises:   TypeTransformationError: when the Python proto type isn't known.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/descriptor.py</code> <pre><code>@staticmethod\ndef ProtoTypeToCppProtoType(proto_type):\n  \"\"\"Converts from a Python proto type to a C++ Proto Type.\n\n  The Python ProtocolBuffer classes specify both the 'Python' datatype and the\n  'C++' datatype - and they're not the same. This helper method should\n  translate from one to another.\n\n  Args:\n    proto_type: the Python proto type (descriptor.FieldDescriptor.TYPE_*)\n  Returns:\n    int: descriptor.FieldDescriptor.CPPTYPE_*, the C++ type.\n  Raises:\n    TypeTransformationError: when the Python proto type isn't known.\n  \"\"\"\n  try:\n    return FieldDescriptor._PYTHON_TO_CPP_PROTO_TYPE_MAP[proto_type]\n  except KeyError:\n    raise TypeTransformationError('Unknown proto_type: %s' % proto_type)\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/descriptor.html#client.ayon_hiero.vendor.google.protobuf.descriptor.FieldDescriptor.__init__","title":"<code>__init__(name, full_name, index, number, type, cpp_type, label, default_value, message_type, enum_type, containing_type, is_extension, extension_scope, options=None, serialized_options=None, has_default_value=True, containing_oneof=None, json_name=None, file=None, create_key=None)</code>","text":"<p>The arguments are as described in the description of FieldDescriptor attributes above.</p> <p>Note that containing_type may be None, and may be set later if necessary (to deal with circular references between message types, for example). Likewise for extension_scope.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/descriptor.py</code> <pre><code>def __init__(self, name, full_name, index, number, type, cpp_type, label,\n             default_value, message_type, enum_type, containing_type,\n             is_extension, extension_scope, options=None,\n             serialized_options=None,\n             has_default_value=True, containing_oneof=None, json_name=None,\n             file=None, create_key=None):  # pylint: disable=redefined-builtin\n  \"\"\"The arguments are as described in the description of FieldDescriptor\n  attributes above.\n\n  Note that containing_type may be None, and may be set later if necessary\n  (to deal with circular references between message types, for example).\n  Likewise for extension_scope.\n  \"\"\"\n  if create_key is not _internal_create_key:\n    _Deprecated('FieldDescriptor')\n\n  super(FieldDescriptor, self).__init__(\n      options, serialized_options, 'FieldOptions')\n  self.name = name\n  self.full_name = full_name\n  self.file = file\n  self._camelcase_name = None\n  if json_name is None:\n    self.json_name = _ToJsonName(name)\n  else:\n    self.json_name = json_name\n  self.index = index\n  self.number = number\n  self.type = type\n  self.cpp_type = cpp_type\n  self.label = label\n  self.has_default_value = has_default_value\n  self.default_value = default_value\n  self.containing_type = containing_type\n  self.message_type = message_type\n  self.enum_type = enum_type\n  self.is_extension = is_extension\n  self.extension_scope = extension_scope\n  self.containing_oneof = containing_oneof\n  if api_implementation.Type() == 'cpp':\n    if is_extension:\n      self._cdescriptor = _message.default_pool.FindExtensionByName(full_name)\n    else:\n      self._cdescriptor = _message.default_pool.FindFieldByName(full_name)\n  else:\n    self._cdescriptor = None\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/descriptor.html#client.ayon_hiero.vendor.google.protobuf.descriptor.FileDescriptor","title":"<code>FileDescriptor</code>","text":"<p>               Bases: <code>DescriptorBase</code></p> <p>Descriptor for a file. Mimics the descriptor_pb2.FileDescriptorProto.</p> <p>Note that :attr:<code>enum_types_by_name</code>, :attr:<code>extensions_by_name</code>, and :attr:<code>dependencies</code> fields are only set by the :py:mod:<code>google.protobuf.message_factory</code> module, and not by the generated proto code.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Name of file, relative to root of source tree.</p> <code>package</code> <code>str</code> <p>Name of the package</p> <code>syntax</code> <code>str</code> <p>string indicating syntax of the file (can be \"proto2\" or \"proto3\")</p> <code>serialized_pb</code> <code>bytes</code> <p>Byte string of serialized :class:<code>descriptor_pb2.FileDescriptorProto</code>.</p> <code>dependencies</code> <code>list[FileDescriptor]</code> <p>List of other :class:<code>FileDescriptor</code> objects this :class:<code>FileDescriptor</code> depends on.</p> <code>public_dependencies</code> <code>list[FileDescriptor]</code> <p>A product of :attr:<code>dependencies</code>, which were declared as \"public\".</p> <code>message_types_by_name</code> <code>dict(str, Descriptor</code> <p>Mapping from message names to their :class:<code>Descriptor</code>.</p> <code>enum_types_by_name</code> <code>dict(str, EnumDescriptor</code> <p>Mapping from enum names to their :class:<code>EnumDescriptor</code>.</p> <code>extensions_by_name</code> <code>dict(str, FieldDescriptor</code> <p>Mapping from extension names declared at file scope to their :class:<code>FieldDescriptor</code>.</p> <code>services_by_name</code> <code>dict(str, ServiceDescriptor</code> <p>Mapping from services' names to their :class:<code>ServiceDescriptor</code>.</p> <code>pool</code> <code>DescriptorPool</code> <p>The pool this descriptor belongs to.  When not passed to the constructor, the global default pool is used.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/descriptor.py</code> <pre><code>class FileDescriptor(DescriptorBase):\n  \"\"\"Descriptor for a file. Mimics the descriptor_pb2.FileDescriptorProto.\n\n  Note that :attr:`enum_types_by_name`, :attr:`extensions_by_name`, and\n  :attr:`dependencies` fields are only set by the\n  :py:mod:`google.protobuf.message_factory` module, and not by the generated\n  proto code.\n\n  Attributes:\n    name (str): Name of file, relative to root of source tree.\n    package (str): Name of the package\n    syntax (str): string indicating syntax of the file (can be \"proto2\" or\n      \"proto3\")\n    serialized_pb (bytes): Byte string of serialized\n      :class:`descriptor_pb2.FileDescriptorProto`.\n    dependencies (list[FileDescriptor]): List of other :class:`FileDescriptor`\n      objects this :class:`FileDescriptor` depends on.\n    public_dependencies (list[FileDescriptor]): A product of\n      :attr:`dependencies`, which were declared as \"public\".\n    message_types_by_name (dict(str, Descriptor)): Mapping from message names\n      to their :class:`Descriptor`.\n    enum_types_by_name (dict(str, EnumDescriptor)): Mapping from enum names to\n      their :class:`EnumDescriptor`.\n    extensions_by_name (dict(str, FieldDescriptor)): Mapping from extension\n      names declared at file scope to their :class:`FieldDescriptor`.\n    services_by_name (dict(str, ServiceDescriptor)): Mapping from services'\n      names to their :class:`ServiceDescriptor`.\n    pool (DescriptorPool): The pool this descriptor belongs to.  When not\n      passed to the constructor, the global default pool is used.\n  \"\"\"\n\n  if _USE_C_DESCRIPTORS:\n    _C_DESCRIPTOR_CLASS = _message.FileDescriptor\n\n    def __new__(cls, name, package, options=None,\n                serialized_options=None, serialized_pb=None,\n                dependencies=None, public_dependencies=None,\n                syntax=None, pool=None, create_key=None):\n      # FileDescriptor() is called from various places, not only from generated\n      # files, to register dynamic proto files and messages.\n      # pylint: disable=g-explicit-bool-comparison\n      if serialized_pb == b'':\n        # Cpp generated code must be linked in if serialized_pb is ''\n        try:\n          return _message.default_pool.FindFileByName(name)\n        except KeyError:\n          raise RuntimeError('Please link in cpp generated lib for %s' % (name))\n      elif serialized_pb:\n        return _message.default_pool.AddSerializedFile(serialized_pb)\n      else:\n        return super(FileDescriptor, cls).__new__(cls)\n\n  def __init__(self, name, package, options=None,\n               serialized_options=None, serialized_pb=None,\n               dependencies=None, public_dependencies=None,\n               syntax=None, pool=None, create_key=None):\n    \"\"\"Constructor.\"\"\"\n    if create_key is not _internal_create_key:\n      _Deprecated('FileDescriptor')\n\n    super(FileDescriptor, self).__init__(\n        options, serialized_options, 'FileOptions')\n\n    if pool is None:\n      from google.protobuf import descriptor_pool\n      pool = descriptor_pool.Default()\n    self.pool = pool\n    self.message_types_by_name = {}\n    self.name = name\n    self.package = package\n    self.syntax = syntax or \"proto2\"\n    self.serialized_pb = serialized_pb\n\n    self.enum_types_by_name = {}\n    self.extensions_by_name = {}\n    self.services_by_name = {}\n    self.dependencies = (dependencies or [])\n    self.public_dependencies = (public_dependencies or [])\n\n  def CopyToProto(self, proto):\n    \"\"\"Copies this to a descriptor_pb2.FileDescriptorProto.\n\n    Args:\n      proto: An empty descriptor_pb2.FileDescriptorProto.\n    \"\"\"\n    proto.ParseFromString(self.serialized_pb)\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/descriptor.html#client.ayon_hiero.vendor.google.protobuf.descriptor.FileDescriptor.CopyToProto","title":"<code>CopyToProto(proto)</code>","text":"<p>Copies this to a descriptor_pb2.FileDescriptorProto.</p> <p>Parameters:</p> Name Type Description Default <code>proto</code> <p>An empty descriptor_pb2.FileDescriptorProto.</p> required Source code in <code>client/ayon_hiero/vendor/google/protobuf/descriptor.py</code> <pre><code>def CopyToProto(self, proto):\n  \"\"\"Copies this to a descriptor_pb2.FileDescriptorProto.\n\n  Args:\n    proto: An empty descriptor_pb2.FileDescriptorProto.\n  \"\"\"\n  proto.ParseFromString(self.serialized_pb)\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/descriptor.html#client.ayon_hiero.vendor.google.protobuf.descriptor.FileDescriptor.__init__","title":"<code>__init__(name, package, options=None, serialized_options=None, serialized_pb=None, dependencies=None, public_dependencies=None, syntax=None, pool=None, create_key=None)</code>","text":"<p>Constructor.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/descriptor.py</code> <pre><code>def __init__(self, name, package, options=None,\n             serialized_options=None, serialized_pb=None,\n             dependencies=None, public_dependencies=None,\n             syntax=None, pool=None, create_key=None):\n  \"\"\"Constructor.\"\"\"\n  if create_key is not _internal_create_key:\n    _Deprecated('FileDescriptor')\n\n  super(FileDescriptor, self).__init__(\n      options, serialized_options, 'FileOptions')\n\n  if pool is None:\n    from google.protobuf import descriptor_pool\n    pool = descriptor_pool.Default()\n  self.pool = pool\n  self.message_types_by_name = {}\n  self.name = name\n  self.package = package\n  self.syntax = syntax or \"proto2\"\n  self.serialized_pb = serialized_pb\n\n  self.enum_types_by_name = {}\n  self.extensions_by_name = {}\n  self.services_by_name = {}\n  self.dependencies = (dependencies or [])\n  self.public_dependencies = (public_dependencies or [])\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/descriptor.html#client.ayon_hiero.vendor.google.protobuf.descriptor.MethodDescriptor","title":"<code>MethodDescriptor</code>","text":"<p>               Bases: <code>DescriptorBase</code></p> <p>Descriptor for a method in a service.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Name of the method within the service.</p> <code>full_name</code> <code>str</code> <p>Full name of method.</p> <code>index</code> <code>int</code> <p>0-indexed index of the method inside the service.</p> <code>containing_service</code> <code>ServiceDescriptor</code> <p>The service that contains this method.</p> <code>input_type</code> <code>Descriptor</code> <p>The descriptor of the message that this method accepts.</p> <code>output_type</code> <code>Descriptor</code> <p>The descriptor of the message that this method returns.</p> <code>client_streaming</code> <code>bool</code> <p>Whether this method uses client streaming.</p> <code>server_streaming</code> <code>bool</code> <p>Whether this method uses server streaming.</p> <code>options</code> <code>MethodOptions or None</code> <p>Method options message, or None to use default method options.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/descriptor.py</code> <pre><code>class MethodDescriptor(DescriptorBase):\n\n  \"\"\"Descriptor for a method in a service.\n\n  Attributes:\n    name (str): Name of the method within the service.\n    full_name (str): Full name of method.\n    index (int): 0-indexed index of the method inside the service.\n    containing_service (ServiceDescriptor): The service that contains this\n      method.\n    input_type (Descriptor): The descriptor of the message that this method\n      accepts.\n    output_type (Descriptor): The descriptor of the message that this method\n      returns.\n    client_streaming (bool): Whether this method uses client streaming.\n    server_streaming (bool): Whether this method uses server streaming.\n    options (descriptor_pb2.MethodOptions or None): Method options message, or\n      None to use default method options.\n  \"\"\"\n\n  if _USE_C_DESCRIPTORS:\n    _C_DESCRIPTOR_CLASS = _message.MethodDescriptor\n\n    def __new__(cls,\n                name,\n                full_name,\n                index,\n                containing_service,\n                input_type,\n                output_type,\n                client_streaming=False,\n                server_streaming=False,\n                options=None,\n                serialized_options=None,\n                create_key=None):\n      _message.Message._CheckCalledFromGeneratedFile()  # pylint: disable=protected-access\n      return _message.default_pool.FindMethodByName(full_name)\n\n  def __init__(self,\n               name,\n               full_name,\n               index,\n               containing_service,\n               input_type,\n               output_type,\n               client_streaming=False,\n               server_streaming=False,\n               options=None,\n               serialized_options=None,\n               create_key=None):\n    \"\"\"The arguments are as described in the description of MethodDescriptor\n    attributes above.\n\n    Note that containing_service may be None, and may be set later if necessary.\n    \"\"\"\n    if create_key is not _internal_create_key:\n      _Deprecated('MethodDescriptor')\n\n    super(MethodDescriptor, self).__init__(\n        options, serialized_options, 'MethodOptions')\n    self.name = name\n    self.full_name = full_name\n    self.index = index\n    self.containing_service = containing_service\n    self.input_type = input_type\n    self.output_type = output_type\n    self.client_streaming = client_streaming\n    self.server_streaming = server_streaming\n\n  def CopyToProto(self, proto):\n    \"\"\"Copies this to a descriptor_pb2.MethodDescriptorProto.\n\n    Args:\n      proto (descriptor_pb2.MethodDescriptorProto): An empty descriptor proto.\n\n    Raises:\n      Error: If self couldn't be serialized, due to too few constructor\n        arguments.\n    \"\"\"\n    if self.containing_service is not None:\n      from google.protobuf import descriptor_pb2\n      service_proto = descriptor_pb2.ServiceDescriptorProto()\n      self.containing_service.CopyToProto(service_proto)\n      proto.CopyFrom(service_proto.method[self.index])\n    else:\n      raise Error('Descriptor does not contain a service.')\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/descriptor.html#client.ayon_hiero.vendor.google.protobuf.descriptor.MethodDescriptor.CopyToProto","title":"<code>CopyToProto(proto)</code>","text":"<p>Copies this to a descriptor_pb2.MethodDescriptorProto.</p> <p>Parameters:</p> Name Type Description Default <code>proto</code> <code>MethodDescriptorProto</code> <p>An empty descriptor proto.</p> required <p>Raises:</p> Type Description <code>Error</code> <p>If self couldn't be serialized, due to too few constructor arguments.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/descriptor.py</code> <pre><code>def CopyToProto(self, proto):\n  \"\"\"Copies this to a descriptor_pb2.MethodDescriptorProto.\n\n  Args:\n    proto (descriptor_pb2.MethodDescriptorProto): An empty descriptor proto.\n\n  Raises:\n    Error: If self couldn't be serialized, due to too few constructor\n      arguments.\n  \"\"\"\n  if self.containing_service is not None:\n    from google.protobuf import descriptor_pb2\n    service_proto = descriptor_pb2.ServiceDescriptorProto()\n    self.containing_service.CopyToProto(service_proto)\n    proto.CopyFrom(service_proto.method[self.index])\n  else:\n    raise Error('Descriptor does not contain a service.')\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/descriptor.html#client.ayon_hiero.vendor.google.protobuf.descriptor.MethodDescriptor.__init__","title":"<code>__init__(name, full_name, index, containing_service, input_type, output_type, client_streaming=False, server_streaming=False, options=None, serialized_options=None, create_key=None)</code>","text":"<p>The arguments are as described in the description of MethodDescriptor attributes above.</p> <p>Note that containing_service may be None, and may be set later if necessary.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/descriptor.py</code> <pre><code>def __init__(self,\n             name,\n             full_name,\n             index,\n             containing_service,\n             input_type,\n             output_type,\n             client_streaming=False,\n             server_streaming=False,\n             options=None,\n             serialized_options=None,\n             create_key=None):\n  \"\"\"The arguments are as described in the description of MethodDescriptor\n  attributes above.\n\n  Note that containing_service may be None, and may be set later if necessary.\n  \"\"\"\n  if create_key is not _internal_create_key:\n    _Deprecated('MethodDescriptor')\n\n  super(MethodDescriptor, self).__init__(\n      options, serialized_options, 'MethodOptions')\n  self.name = name\n  self.full_name = full_name\n  self.index = index\n  self.containing_service = containing_service\n  self.input_type = input_type\n  self.output_type = output_type\n  self.client_streaming = client_streaming\n  self.server_streaming = server_streaming\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/descriptor.html#client.ayon_hiero.vendor.google.protobuf.descriptor.OneofDescriptor","title":"<code>OneofDescriptor</code>","text":"<p>               Bases: <code>DescriptorBase</code></p> <p>Descriptor for a oneof field.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Name of the oneof field.</p> <code>full_name</code> <code>str</code> <p>Full name of the oneof field, including package name.</p> <code>index</code> <code>int</code> <p>0-based index giving the order of the oneof field inside its containing type.</p> <code>containing_type</code> <code>Descriptor</code> <p>:class:<code>Descriptor</code> of the protocol message type that contains this field.  Set by the :class:<code>Descriptor</code> constructor if we're passed into one.</p> <code>fields</code> <code>list[FieldDescriptor]</code> <p>The list of field descriptors this oneof can contain.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/descriptor.py</code> <pre><code>class OneofDescriptor(DescriptorBase):\n  \"\"\"Descriptor for a oneof field.\n\n  Attributes:\n    name (str): Name of the oneof field.\n    full_name (str): Full name of the oneof field, including package name.\n    index (int): 0-based index giving the order of the oneof field inside\n      its containing type.\n    containing_type (Descriptor): :class:`Descriptor` of the protocol message\n      type that contains this field.  Set by the :class:`Descriptor` constructor\n      if we're passed into one.\n    fields (list[FieldDescriptor]): The list of field descriptors this\n      oneof can contain.\n  \"\"\"\n\n  if _USE_C_DESCRIPTORS:\n    _C_DESCRIPTOR_CLASS = _message.OneofDescriptor\n\n    def __new__(\n        cls, name, full_name, index, containing_type, fields, options=None,\n        serialized_options=None, create_key=None):\n      _message.Message._CheckCalledFromGeneratedFile()\n      return _message.default_pool.FindOneofByName(full_name)\n\n  def __init__(\n      self, name, full_name, index, containing_type, fields, options=None,\n      serialized_options=None, create_key=None):\n    \"\"\"Arguments are as described in the attribute description above.\"\"\"\n    if create_key is not _internal_create_key:\n      _Deprecated('OneofDescriptor')\n\n    super(OneofDescriptor, self).__init__(\n        options, serialized_options, 'OneofOptions')\n    self.name = name\n    self.full_name = full_name\n    self.index = index\n    self.containing_type = containing_type\n    self.fields = fields\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/descriptor.html#client.ayon_hiero.vendor.google.protobuf.descriptor.OneofDescriptor.__init__","title":"<code>__init__(name, full_name, index, containing_type, fields, options=None, serialized_options=None, create_key=None)</code>","text":"<p>Arguments are as described in the attribute description above.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/descriptor.py</code> <pre><code>def __init__(\n    self, name, full_name, index, containing_type, fields, options=None,\n    serialized_options=None, create_key=None):\n  \"\"\"Arguments are as described in the attribute description above.\"\"\"\n  if create_key is not _internal_create_key:\n    _Deprecated('OneofDescriptor')\n\n  super(OneofDescriptor, self).__init__(\n      options, serialized_options, 'OneofOptions')\n  self.name = name\n  self.full_name = full_name\n  self.index = index\n  self.containing_type = containing_type\n  self.fields = fields\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/descriptor.html#client.ayon_hiero.vendor.google.protobuf.descriptor.ServiceDescriptor","title":"<code>ServiceDescriptor</code>","text":"<p>               Bases: <code>_NestedDescriptorBase</code></p> <p>Descriptor for a service.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Name of the service.</p> <code>full_name</code> <code>str</code> <p>Full name of the service, including package name.</p> <code>index</code> <code>int</code> <p>0-indexed index giving the order that this services definition appears within the .proto file.</p> <code>methods</code> <code>list[MethodDescriptor]</code> <p>List of methods provided by this service.</p> <code>methods_by_name</code> <code>dict(str, MethodDescriptor</code> <p>Same :class:<code>MethodDescriptor</code> objects as in :attr:<code>methods_by_name</code>, but indexed by \"name\" attribute in each :class:<code>MethodDescriptor</code>.</p> <code>options</code> <code>ServiceOptions</code> <p>Service options message or None to use default service options.</p> <code>file</code> <code>FileDescriptor</code> <p>Reference to file info.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/descriptor.py</code> <pre><code>class ServiceDescriptor(_NestedDescriptorBase):\n\n  \"\"\"Descriptor for a service.\n\n  Attributes:\n    name (str): Name of the service.\n    full_name (str): Full name of the service, including package name.\n    index (int): 0-indexed index giving the order that this services\n      definition appears within the .proto file.\n    methods (list[MethodDescriptor]): List of methods provided by this\n      service.\n    methods_by_name (dict(str, MethodDescriptor)): Same\n      :class:`MethodDescriptor` objects as in :attr:`methods_by_name`, but\n      indexed by \"name\" attribute in each :class:`MethodDescriptor`.\n    options (descriptor_pb2.ServiceOptions): Service options message or\n      None to use default service options.\n    file (FileDescriptor): Reference to file info.\n  \"\"\"\n\n  if _USE_C_DESCRIPTORS:\n    _C_DESCRIPTOR_CLASS = _message.ServiceDescriptor\n\n    def __new__(\n        cls,\n        name=None,\n        full_name=None,\n        index=None,\n        methods=None,\n        options=None,\n        serialized_options=None,\n        file=None,  # pylint: disable=redefined-builtin\n        serialized_start=None,\n        serialized_end=None,\n        create_key=None):\n      _message.Message._CheckCalledFromGeneratedFile()  # pylint: disable=protected-access\n      return _message.default_pool.FindServiceByName(full_name)\n\n  def __init__(self, name, full_name, index, methods, options=None,\n               serialized_options=None, file=None,  # pylint: disable=redefined-builtin\n               serialized_start=None, serialized_end=None, create_key=None):\n    if create_key is not _internal_create_key:\n      _Deprecated('ServiceDescriptor')\n\n    super(ServiceDescriptor, self).__init__(\n        options, 'ServiceOptions', name, full_name, file,\n        None, serialized_start=serialized_start,\n        serialized_end=serialized_end, serialized_options=serialized_options)\n    self.index = index\n    self.methods = methods\n    self.methods_by_name = dict((m.name, m) for m in methods)\n    # Set the containing service for each method in this service.\n    for method in self.methods:\n      method.containing_service = self\n\n  def FindMethodByName(self, name):\n    \"\"\"Searches for the specified method, and returns its descriptor.\n\n    Args:\n      name (str): Name of the method.\n    Returns:\n      MethodDescriptor or None: the descriptor for the requested method, if\n      found.\n    \"\"\"\n    return self.methods_by_name.get(name, None)\n\n  def CopyToProto(self, proto):\n    \"\"\"Copies this to a descriptor_pb2.ServiceDescriptorProto.\n\n    Args:\n      proto (descriptor_pb2.ServiceDescriptorProto): An empty descriptor proto.\n    \"\"\"\n    # This function is overridden to give a better doc comment.\n    super(ServiceDescriptor, self).CopyToProto(proto)\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/descriptor.html#client.ayon_hiero.vendor.google.protobuf.descriptor.ServiceDescriptor.CopyToProto","title":"<code>CopyToProto(proto)</code>","text":"<p>Copies this to a descriptor_pb2.ServiceDescriptorProto.</p> <p>Parameters:</p> Name Type Description Default <code>proto</code> <code>ServiceDescriptorProto</code> <p>An empty descriptor proto.</p> required Source code in <code>client/ayon_hiero/vendor/google/protobuf/descriptor.py</code> <pre><code>def CopyToProto(self, proto):\n  \"\"\"Copies this to a descriptor_pb2.ServiceDescriptorProto.\n\n  Args:\n    proto (descriptor_pb2.ServiceDescriptorProto): An empty descriptor proto.\n  \"\"\"\n  # This function is overridden to give a better doc comment.\n  super(ServiceDescriptor, self).CopyToProto(proto)\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/descriptor.html#client.ayon_hiero.vendor.google.protobuf.descriptor.ServiceDescriptor.FindMethodByName","title":"<code>FindMethodByName(name)</code>","text":"<p>Searches for the specified method, and returns its descriptor.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the method.</p> required <p>Returns:   MethodDescriptor or None: the descriptor for the requested method, if   found.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/descriptor.py</code> <pre><code>def FindMethodByName(self, name):\n  \"\"\"Searches for the specified method, and returns its descriptor.\n\n  Args:\n    name (str): Name of the method.\n  Returns:\n    MethodDescriptor or None: the descriptor for the requested method, if\n    found.\n  \"\"\"\n  return self.methods_by_name.get(name, None)\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/descriptor.html#client.ayon_hiero.vendor.google.protobuf.descriptor.TypeTransformationError","title":"<code>TypeTransformationError</code>","text":"<p>               Bases: <code>Error</code></p> <p>Error transforming between python proto type and corresponding C++ type.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/descriptor.py</code> <pre><code>class TypeTransformationError(Error):\n  \"\"\"Error transforming between python proto type and corresponding C++ type.\"\"\"\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/descriptor.html#client.ayon_hiero.vendor.google.protobuf.descriptor.MakeDescriptor","title":"<code>MakeDescriptor(desc_proto, package='', build_file_if_cpp=True, syntax=None)</code>","text":"<p>Make a protobuf Descriptor given a DescriptorProto protobuf.</p> <p>Handles nested descriptors. Note that this is limited to the scope of defining a message inside of another message. Composite fields can currently only be resolved if the message is defined in the same scope as the field.</p> <p>Parameters:</p> Name Type Description Default <code>desc_proto</code> <p>The descriptor_pb2.DescriptorProto protobuf message.</p> required <code>package</code> <p>Optional package name for the new message Descriptor (string).</p> <code>''</code> <code>build_file_if_cpp</code> <p>Update the C++ descriptor pool if api matches.                  Set to False on recursion, so no duplicates are created.</p> <code>True</code> <code>syntax</code> <p>The syntax/semantics that should be used.  Set to \"proto3\" to get       proto3 field presence semantics.</p> <code>None</code> <p>Returns:   A Descriptor for protobuf messages.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/descriptor.py</code> <pre><code>def MakeDescriptor(desc_proto, package='', build_file_if_cpp=True,\n                   syntax=None):\n  \"\"\"Make a protobuf Descriptor given a DescriptorProto protobuf.\n\n  Handles nested descriptors. Note that this is limited to the scope of defining\n  a message inside of another message. Composite fields can currently only be\n  resolved if the message is defined in the same scope as the field.\n\n  Args:\n    desc_proto: The descriptor_pb2.DescriptorProto protobuf message.\n    package: Optional package name for the new message Descriptor (string).\n    build_file_if_cpp: Update the C++ descriptor pool if api matches.\n                       Set to False on recursion, so no duplicates are created.\n    syntax: The syntax/semantics that should be used.  Set to \"proto3\" to get\n            proto3 field presence semantics.\n  Returns:\n    A Descriptor for protobuf messages.\n  \"\"\"\n  if api_implementation.Type() == 'cpp' and build_file_if_cpp:\n    # The C++ implementation requires all descriptors to be backed by the same\n    # definition in the C++ descriptor pool. To do this, we build a\n    # FileDescriptorProto with the same definition as this descriptor and build\n    # it into the pool.\n    from google.protobuf import descriptor_pb2\n    file_descriptor_proto = descriptor_pb2.FileDescriptorProto()\n    file_descriptor_proto.message_type.add().MergeFrom(desc_proto)\n\n    # Generate a random name for this proto file to prevent conflicts with any\n    # imported ones. We need to specify a file name so the descriptor pool\n    # accepts our FileDescriptorProto, but it is not important what that file\n    # name is actually set to.\n    proto_name = binascii.hexlify(os.urandom(16)).decode('ascii')\n\n    if package:\n      file_descriptor_proto.name = os.path.join(package.replace('.', '/'),\n                                                proto_name + '.proto')\n      file_descriptor_proto.package = package\n    else:\n      file_descriptor_proto.name = proto_name + '.proto'\n\n    _message.default_pool.Add(file_descriptor_proto)\n    result = _message.default_pool.FindFileByName(file_descriptor_proto.name)\n\n    if _USE_C_DESCRIPTORS:\n      return result.message_types_by_name[desc_proto.name]\n\n  full_message_name = [desc_proto.name]\n  if package: full_message_name.insert(0, package)\n\n  # Create Descriptors for enum types\n  enum_types = {}\n  for enum_proto in desc_proto.enum_type:\n    full_name = '.'.join(full_message_name + [enum_proto.name])\n    enum_desc = EnumDescriptor(\n        enum_proto.name, full_name, None, [\n            EnumValueDescriptor(enum_val.name, ii, enum_val.number,\n                                create_key=_internal_create_key)\n            for ii, enum_val in enumerate(enum_proto.value)],\n        create_key=_internal_create_key)\n    enum_types[full_name] = enum_desc\n\n  # Create Descriptors for nested types\n  nested_types = {}\n  for nested_proto in desc_proto.nested_type:\n    full_name = '.'.join(full_message_name + [nested_proto.name])\n    # Nested types are just those defined inside of the message, not all types\n    # used by fields in the message, so no loops are possible here.\n    nested_desc = MakeDescriptor(nested_proto,\n                                 package='.'.join(full_message_name),\n                                 build_file_if_cpp=False,\n                                 syntax=syntax)\n    nested_types[full_name] = nested_desc\n\n  fields = []\n  for field_proto in desc_proto.field:\n    full_name = '.'.join(full_message_name + [field_proto.name])\n    enum_desc = None\n    nested_desc = None\n    if field_proto.json_name:\n      json_name = field_proto.json_name\n    else:\n      json_name = None\n    if field_proto.HasField('type_name'):\n      type_name = field_proto.type_name\n      full_type_name = '.'.join(full_message_name +\n                                [type_name[type_name.rfind('.')+1:]])\n      if full_type_name in nested_types:\n        nested_desc = nested_types[full_type_name]\n      elif full_type_name in enum_types:\n        enum_desc = enum_types[full_type_name]\n      # Else type_name references a non-local type, which isn't implemented\n    field = FieldDescriptor(\n        field_proto.name, full_name, field_proto.number - 1,\n        field_proto.number, field_proto.type,\n        FieldDescriptor.ProtoTypeToCppProtoType(field_proto.type),\n        field_proto.label, None, nested_desc, enum_desc, None, False, None,\n        options=_OptionsOrNone(field_proto), has_default_value=False,\n        json_name=json_name, create_key=_internal_create_key)\n    fields.append(field)\n\n  desc_name = '.'.join(full_message_name)\n  return Descriptor(desc_proto.name, desc_name, None, None, fields,\n                    list(nested_types.values()), list(enum_types.values()), [],\n                    options=_OptionsOrNone(desc_proto),\n                    create_key=_internal_create_key)\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/descriptor_database.html","title":"descriptor_database","text":"<p>Provides a container for DescriptorProtos.</p>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/descriptor_database.html#client.ayon_hiero.vendor.google.protobuf.descriptor_database.DescriptorDatabase","title":"<code>DescriptorDatabase</code>","text":"<p>               Bases: <code>object</code></p> <p>A container accepting FileDescriptorProtos and maps DescriptorProtos.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/descriptor_database.py</code> <pre><code>class DescriptorDatabase(object):\n  \"\"\"A container accepting FileDescriptorProtos and maps DescriptorProtos.\"\"\"\n\n  def __init__(self):\n    self._file_desc_protos_by_file = {}\n    self._file_desc_protos_by_symbol = {}\n\n  def Add(self, file_desc_proto):\n    \"\"\"Adds the FileDescriptorProto and its types to this database.\n\n    Args:\n      file_desc_proto: The FileDescriptorProto to add.\n    Raises:\n      DescriptorDatabaseConflictingDefinitionError: if an attempt is made to\n        add a proto with the same name but different definition than an\n        existing proto in the database.\n    \"\"\"\n    proto_name = file_desc_proto.name\n    if proto_name not in self._file_desc_protos_by_file:\n      self._file_desc_protos_by_file[proto_name] = file_desc_proto\n    elif self._file_desc_protos_by_file[proto_name] != file_desc_proto:\n      raise DescriptorDatabaseConflictingDefinitionError(\n          '%s already added, but with different descriptor.' % proto_name)\n    else:\n      return\n\n    # Add all the top-level descriptors to the index.\n    package = file_desc_proto.package\n    for message in file_desc_proto.message_type:\n      for name in _ExtractSymbols(message, package):\n        self._AddSymbol(name, file_desc_proto)\n    for enum in file_desc_proto.enum_type:\n      self._AddSymbol(('.'.join((package, enum.name))), file_desc_proto)\n      for enum_value in enum.value:\n        self._file_desc_protos_by_symbol[\n            '.'.join((package, enum_value.name))] = file_desc_proto\n    for extension in file_desc_proto.extension:\n      self._AddSymbol(('.'.join((package, extension.name))), file_desc_proto)\n    for service in file_desc_proto.service:\n      self._AddSymbol(('.'.join((package, service.name))), file_desc_proto)\n\n  def FindFileByName(self, name):\n    \"\"\"Finds the file descriptor proto by file name.\n\n    Typically the file name is a relative path ending to a .proto file. The\n    proto with the given name will have to have been added to this database\n    using the Add method or else an error will be raised.\n\n    Args:\n      name: The file name to find.\n\n    Returns:\n      The file descriptor proto matching the name.\n\n    Raises:\n      KeyError if no file by the given name was added.\n    \"\"\"\n\n    return self._file_desc_protos_by_file[name]\n\n  def FindFileContainingSymbol(self, symbol):\n    \"\"\"Finds the file descriptor proto containing the specified symbol.\n\n    The symbol should be a fully qualified name including the file descriptor's\n    package and any containing messages. Some examples:\n\n    'some.package.name.Message'\n    'some.package.name.Message.NestedEnum'\n    'some.package.name.Message.some_field'\n\n    The file descriptor proto containing the specified symbol must be added to\n    this database using the Add method or else an error will be raised.\n\n    Args:\n      symbol: The fully qualified symbol name.\n\n    Returns:\n      The file descriptor proto containing the symbol.\n\n    Raises:\n      KeyError if no file contains the specified symbol.\n    \"\"\"\n    try:\n      return self._file_desc_protos_by_symbol[symbol]\n    except KeyError:\n      # Fields, enum values, and nested extensions are not in\n      # _file_desc_protos_by_symbol. Try to find the top level\n      # descriptor. Non-existent nested symbol under a valid top level\n      # descriptor can also be found. The behavior is the same with\n      # protobuf C++.\n      top_level, _, _ = symbol.rpartition('.')\n      try:\n        return self._file_desc_protos_by_symbol[top_level]\n      except KeyError:\n        # Raise the original symbol as a KeyError for better diagnostics.\n        raise KeyError(symbol)\n\n  def FindFileContainingExtension(self, extendee_name, extension_number):\n    # TODO(jieluo): implement this API.\n    return None\n\n  def FindAllExtensionNumbers(self, extendee_name):\n    # TODO(jieluo): implement this API.\n    return []\n\n  def _AddSymbol(self, name, file_desc_proto):\n    if name in self._file_desc_protos_by_symbol:\n      warn_msg = ('Conflict register for file \"' + file_desc_proto.name +\n                  '\": ' + name +\n                  ' is already defined in file \"' +\n                  self._file_desc_protos_by_symbol[name].name + '\"')\n      warnings.warn(warn_msg, RuntimeWarning)\n    self._file_desc_protos_by_symbol[name] = file_desc_proto\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/descriptor_database.html#client.ayon_hiero.vendor.google.protobuf.descriptor_database.DescriptorDatabase.Add","title":"<code>Add(file_desc_proto)</code>","text":"<p>Adds the FileDescriptorProto and its types to this database.</p> <p>Parameters:</p> Name Type Description Default <code>file_desc_proto</code> <p>The FileDescriptorProto to add.</p> required <p>Raises:   DescriptorDatabaseConflictingDefinitionError: if an attempt is made to     add a proto with the same name but different definition than an     existing proto in the database.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/descriptor_database.py</code> <pre><code>def Add(self, file_desc_proto):\n  \"\"\"Adds the FileDescriptorProto and its types to this database.\n\n  Args:\n    file_desc_proto: The FileDescriptorProto to add.\n  Raises:\n    DescriptorDatabaseConflictingDefinitionError: if an attempt is made to\n      add a proto with the same name but different definition than an\n      existing proto in the database.\n  \"\"\"\n  proto_name = file_desc_proto.name\n  if proto_name not in self._file_desc_protos_by_file:\n    self._file_desc_protos_by_file[proto_name] = file_desc_proto\n  elif self._file_desc_protos_by_file[proto_name] != file_desc_proto:\n    raise DescriptorDatabaseConflictingDefinitionError(\n        '%s already added, but with different descriptor.' % proto_name)\n  else:\n    return\n\n  # Add all the top-level descriptors to the index.\n  package = file_desc_proto.package\n  for message in file_desc_proto.message_type:\n    for name in _ExtractSymbols(message, package):\n      self._AddSymbol(name, file_desc_proto)\n  for enum in file_desc_proto.enum_type:\n    self._AddSymbol(('.'.join((package, enum.name))), file_desc_proto)\n    for enum_value in enum.value:\n      self._file_desc_protos_by_symbol[\n          '.'.join((package, enum_value.name))] = file_desc_proto\n  for extension in file_desc_proto.extension:\n    self._AddSymbol(('.'.join((package, extension.name))), file_desc_proto)\n  for service in file_desc_proto.service:\n    self._AddSymbol(('.'.join((package, service.name))), file_desc_proto)\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/descriptor_database.html#client.ayon_hiero.vendor.google.protobuf.descriptor_database.DescriptorDatabase.FindFileByName","title":"<code>FindFileByName(name)</code>","text":"<p>Finds the file descriptor proto by file name.</p> <p>Typically the file name is a relative path ending to a .proto file. The proto with the given name will have to have been added to this database using the Add method or else an error will be raised.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <p>The file name to find.</p> required <p>Returns:</p> Type Description <p>The file descriptor proto matching the name.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/descriptor_database.py</code> <pre><code>def FindFileByName(self, name):\n  \"\"\"Finds the file descriptor proto by file name.\n\n  Typically the file name is a relative path ending to a .proto file. The\n  proto with the given name will have to have been added to this database\n  using the Add method or else an error will be raised.\n\n  Args:\n    name: The file name to find.\n\n  Returns:\n    The file descriptor proto matching the name.\n\n  Raises:\n    KeyError if no file by the given name was added.\n  \"\"\"\n\n  return self._file_desc_protos_by_file[name]\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/descriptor_database.html#client.ayon_hiero.vendor.google.protobuf.descriptor_database.DescriptorDatabase.FindFileContainingSymbol","title":"<code>FindFileContainingSymbol(symbol)</code>","text":"<p>Finds the file descriptor proto containing the specified symbol.</p> <p>The symbol should be a fully qualified name including the file descriptor's package and any containing messages. Some examples:</p> <p>'some.package.name.Message' 'some.package.name.Message.NestedEnum' 'some.package.name.Message.some_field'</p> <p>The file descriptor proto containing the specified symbol must be added to this database using the Add method or else an error will be raised.</p> <p>Parameters:</p> Name Type Description Default <code>symbol</code> <p>The fully qualified symbol name.</p> required <p>Returns:</p> Type Description <p>The file descriptor proto containing the symbol.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/descriptor_database.py</code> <pre><code>def FindFileContainingSymbol(self, symbol):\n  \"\"\"Finds the file descriptor proto containing the specified symbol.\n\n  The symbol should be a fully qualified name including the file descriptor's\n  package and any containing messages. Some examples:\n\n  'some.package.name.Message'\n  'some.package.name.Message.NestedEnum'\n  'some.package.name.Message.some_field'\n\n  The file descriptor proto containing the specified symbol must be added to\n  this database using the Add method or else an error will be raised.\n\n  Args:\n    symbol: The fully qualified symbol name.\n\n  Returns:\n    The file descriptor proto containing the symbol.\n\n  Raises:\n    KeyError if no file contains the specified symbol.\n  \"\"\"\n  try:\n    return self._file_desc_protos_by_symbol[symbol]\n  except KeyError:\n    # Fields, enum values, and nested extensions are not in\n    # _file_desc_protos_by_symbol. Try to find the top level\n    # descriptor. Non-existent nested symbol under a valid top level\n    # descriptor can also be found. The behavior is the same with\n    # protobuf C++.\n    top_level, _, _ = symbol.rpartition('.')\n    try:\n      return self._file_desc_protos_by_symbol[top_level]\n    except KeyError:\n      # Raise the original symbol as a KeyError for better diagnostics.\n      raise KeyError(symbol)\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/descriptor_database.html#client.ayon_hiero.vendor.google.protobuf.descriptor_database.DescriptorDatabaseConflictingDefinitionError","title":"<code>DescriptorDatabaseConflictingDefinitionError</code>","text":"<p>               Bases: <code>Error</code></p> <p>Raised when a proto is added with the same name &amp; different descriptor.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/descriptor_database.py</code> <pre><code>class DescriptorDatabaseConflictingDefinitionError(Error):\n  \"\"\"Raised when a proto is added with the same name &amp; different descriptor.\"\"\"\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/descriptor_pb2.html","title":"descriptor_pb2","text":"<p>Generated protocol buffer code.</p>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/descriptor_pool.html","title":"descriptor_pool","text":"<p>Provides DescriptorPool to use as a container for proto2 descriptors.</p> <p>The DescriptorPool is used in conjection with a DescriptorDatabase to maintain a collection of protocol buffer descriptors for use when dynamically creating message types at runtime.</p> <p>For most applications protocol buffers should be used via modules generated by the protocol buffer compiler tool. This should only be used when the type of protocol buffers used in an application or library cannot be predetermined.</p> <p>Below is a straightforward example on how to use this class::</p> <p>pool = DescriptorPool()   file_descriptor_protos = [ ... ]   for file_descriptor_proto in file_descriptor_protos:     pool.Add(file_descriptor_proto)   my_message_descriptor = pool.FindMessageTypeByName('some.package.MessageType')</p> <p>The message descriptor can be used in conjunction with the message_factory module in order to create a protocol buffer class that can be encoded and decoded.</p> <p>If you want to get a Python class for the specified proto, use the helper functions inside google.protobuf.message_factory directly instead of this class.</p>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/descriptor_pool.html#client.ayon_hiero.vendor.google.protobuf.descriptor_pool.DescriptorPool","title":"<code>DescriptorPool</code>","text":"<p>               Bases: <code>object</code></p> <p>A collection of protobufs dynamically constructed by descriptor protos.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/descriptor_pool.py</code> <pre><code>class DescriptorPool(object):\n  \"\"\"A collection of protobufs dynamically constructed by descriptor protos.\"\"\"\n\n  if _USE_C_DESCRIPTORS:\n\n    def __new__(cls, descriptor_db=None):\n      # pylint: disable=protected-access\n      return descriptor._message.DescriptorPool(descriptor_db)\n\n  def __init__(self, descriptor_db=None):\n    \"\"\"Initializes a Pool of proto buffs.\n\n    The descriptor_db argument to the constructor is provided to allow\n    specialized file descriptor proto lookup code to be triggered on demand. An\n    example would be an implementation which will read and compile a file\n    specified in a call to FindFileByName() and not require the call to Add()\n    at all. Results from this database will be cached internally here as well.\n\n    Args:\n      descriptor_db: A secondary source of file descriptors.\n    \"\"\"\n\n    self._internal_db = descriptor_database.DescriptorDatabase()\n    self._descriptor_db = descriptor_db\n    self._descriptors = {}\n    self._enum_descriptors = {}\n    self._service_descriptors = {}\n    self._file_descriptors = {}\n    self._toplevel_extensions = {}\n    # TODO(jieluo): Remove _file_desc_by_toplevel_extension after\n    # maybe year 2020 for compatibility issue (with 3.4.1 only).\n    self._file_desc_by_toplevel_extension = {}\n    self._top_enum_values = {}\n    # We store extensions in two two-level mappings: The first key is the\n    # descriptor of the message being extended, the second key is the extension\n    # full name or its tag number.\n    self._extensions_by_name = collections.defaultdict(dict)\n    self._extensions_by_number = collections.defaultdict(dict)\n\n  def _CheckConflictRegister(self, desc, desc_name, file_name):\n    \"\"\"Check if the descriptor name conflicts with another of the same name.\n\n    Args:\n      desc: Descriptor of a message, enum, service, extension or enum value.\n      desc_name (str): the full name of desc.\n      file_name (str): The file name of descriptor.\n    \"\"\"\n    for register, descriptor_type in [\n        (self._descriptors, descriptor.Descriptor),\n        (self._enum_descriptors, descriptor.EnumDescriptor),\n        (self._service_descriptors, descriptor.ServiceDescriptor),\n        (self._toplevel_extensions, descriptor.FieldDescriptor),\n        (self._top_enum_values, descriptor.EnumValueDescriptor)]:\n      if desc_name in register:\n        old_desc = register[desc_name]\n        if isinstance(old_desc, descriptor.EnumValueDescriptor):\n          old_file = old_desc.type.file.name\n        else:\n          old_file = old_desc.file.name\n\n        if not isinstance(desc, descriptor_type) or (\n            old_file != file_name):\n          error_msg = ('Conflict register for file \"' + file_name +\n                       '\": ' + desc_name +\n                       ' is already defined in file \"' +\n                       old_file + '\". Please fix the conflict by adding '\n                       'package name on the proto file, or use different '\n                       'name for the duplication.')\n          if isinstance(desc, descriptor.EnumValueDescriptor):\n            error_msg += ('\\nNote: enum values appear as '\n                          'siblings of the enum type instead of '\n                          'children of it.')\n\n          raise TypeError(error_msg)\n\n        return\n\n  def Add(self, file_desc_proto):\n    \"\"\"Adds the FileDescriptorProto and its types to this pool.\n\n    Args:\n      file_desc_proto (FileDescriptorProto): The file descriptor to add.\n    \"\"\"\n\n    self._internal_db.Add(file_desc_proto)\n\n  def AddSerializedFile(self, serialized_file_desc_proto):\n    \"\"\"Adds the FileDescriptorProto and its types to this pool.\n\n    Args:\n      serialized_file_desc_proto (bytes): A bytes string, serialization of the\n        :class:`FileDescriptorProto` to add.\n\n    Returns:\n      FileDescriptor: Descriptor for the added file.\n    \"\"\"\n\n    # pylint: disable=g-import-not-at-top\n    from google.protobuf import descriptor_pb2\n    file_desc_proto = descriptor_pb2.FileDescriptorProto.FromString(\n        serialized_file_desc_proto)\n    file_desc = self._ConvertFileProtoToFileDescriptor(file_desc_proto)\n    file_desc.serialized_pb = serialized_file_desc_proto\n    return file_desc\n\n  # Add Descriptor to descriptor pool is dreprecated. Please use Add()\n  # or AddSerializedFile() to add a FileDescriptorProto instead.\n  @_Deprecated\n  def AddDescriptor(self, desc):\n    self._AddDescriptor(desc)\n\n  # Never call this method. It is for internal usage only.\n  def _AddDescriptor(self, desc):\n    \"\"\"Adds a Descriptor to the pool, non-recursively.\n\n    If the Descriptor contains nested messages or enums, the caller must\n    explicitly register them. This method also registers the FileDescriptor\n    associated with the message.\n\n    Args:\n      desc: A Descriptor.\n    \"\"\"\n    if not isinstance(desc, descriptor.Descriptor):\n      raise TypeError('Expected instance of descriptor.Descriptor.')\n\n    self._CheckConflictRegister(desc, desc.full_name, desc.file.name)\n\n    self._descriptors[desc.full_name] = desc\n    self._AddFileDescriptor(desc.file)\n\n  # Add EnumDescriptor to descriptor pool is dreprecated. Please use Add()\n  # or AddSerializedFile() to add a FileDescriptorProto instead.\n  @_Deprecated\n  def AddEnumDescriptor(self, enum_desc):\n    self._AddEnumDescriptor(enum_desc)\n\n  # Never call this method. It is for internal usage only.\n  def _AddEnumDescriptor(self, enum_desc):\n    \"\"\"Adds an EnumDescriptor to the pool.\n\n    This method also registers the FileDescriptor associated with the enum.\n\n    Args:\n      enum_desc: An EnumDescriptor.\n    \"\"\"\n\n    if not isinstance(enum_desc, descriptor.EnumDescriptor):\n      raise TypeError('Expected instance of descriptor.EnumDescriptor.')\n\n    file_name = enum_desc.file.name\n    self._CheckConflictRegister(enum_desc, enum_desc.full_name, file_name)\n    self._enum_descriptors[enum_desc.full_name] = enum_desc\n\n    # Top enum values need to be indexed.\n    # Count the number of dots to see whether the enum is toplevel or nested\n    # in a message. We cannot use enum_desc.containing_type at this stage.\n    if enum_desc.file.package:\n      top_level = (enum_desc.full_name.count('.')\n                   - enum_desc.file.package.count('.') == 1)\n    else:\n      top_level = enum_desc.full_name.count('.') == 0\n    if top_level:\n      file_name = enum_desc.file.name\n      package = enum_desc.file.package\n      for enum_value in enum_desc.values:\n        full_name = _NormalizeFullyQualifiedName(\n            '.'.join((package, enum_value.name)))\n        self._CheckConflictRegister(enum_value, full_name, file_name)\n        self._top_enum_values[full_name] = enum_value\n    self._AddFileDescriptor(enum_desc.file)\n\n  # Add ServiceDescriptor to descriptor pool is dreprecated. Please use Add()\n  # or AddSerializedFile() to add a FileDescriptorProto instead.\n  @_Deprecated\n  def AddServiceDescriptor(self, service_desc):\n    self._AddServiceDescriptor(service_desc)\n\n  # Never call this method. It is for internal usage only.\n  def _AddServiceDescriptor(self, service_desc):\n    \"\"\"Adds a ServiceDescriptor to the pool.\n\n    Args:\n      service_desc: A ServiceDescriptor.\n    \"\"\"\n\n    if not isinstance(service_desc, descriptor.ServiceDescriptor):\n      raise TypeError('Expected instance of descriptor.ServiceDescriptor.')\n\n    self._CheckConflictRegister(service_desc, service_desc.full_name,\n                                service_desc.file.name)\n    self._service_descriptors[service_desc.full_name] = service_desc\n\n  # Add ExtensionDescriptor to descriptor pool is dreprecated. Please use Add()\n  # or AddSerializedFile() to add a FileDescriptorProto instead.\n  @_Deprecated\n  def AddExtensionDescriptor(self, extension):\n    self._AddExtensionDescriptor(extension)\n\n  # Never call this method. It is for internal usage only.\n  def _AddExtensionDescriptor(self, extension):\n    \"\"\"Adds a FieldDescriptor describing an extension to the pool.\n\n    Args:\n      extension: A FieldDescriptor.\n\n    Raises:\n      AssertionError: when another extension with the same number extends the\n        same message.\n      TypeError: when the specified extension is not a\n        descriptor.FieldDescriptor.\n    \"\"\"\n    if not (isinstance(extension, descriptor.FieldDescriptor) and\n            extension.is_extension):\n      raise TypeError('Expected an extension descriptor.')\n\n    if extension.extension_scope is None:\n      self._toplevel_extensions[extension.full_name] = extension\n\n    try:\n      existing_desc = self._extensions_by_number[\n          extension.containing_type][extension.number]\n    except KeyError:\n      pass\n    else:\n      if extension is not existing_desc:\n        raise AssertionError(\n            'Extensions \"%s\" and \"%s\" both try to extend message type \"%s\" '\n            'with field number %d.' %\n            (extension.full_name, existing_desc.full_name,\n             extension.containing_type.full_name, extension.number))\n\n    self._extensions_by_number[extension.containing_type][\n        extension.number] = extension\n    self._extensions_by_name[extension.containing_type][\n        extension.full_name] = extension\n\n    # Also register MessageSet extensions with the type name.\n    if _IsMessageSetExtension(extension):\n      self._extensions_by_name[extension.containing_type][\n          extension.message_type.full_name] = extension\n\n  @_Deprecated\n  def AddFileDescriptor(self, file_desc):\n    self._InternalAddFileDescriptor(file_desc)\n\n  # Never call this method. It is for internal usage only.\n  def _InternalAddFileDescriptor(self, file_desc):\n    \"\"\"Adds a FileDescriptor to the pool, non-recursively.\n\n    If the FileDescriptor contains messages or enums, the caller must explicitly\n    register them.\n\n    Args:\n      file_desc: A FileDescriptor.\n    \"\"\"\n\n    self._AddFileDescriptor(file_desc)\n    # TODO(jieluo): This is a temporary solution for FieldDescriptor.file.\n    # FieldDescriptor.file is added in code gen. Remove this solution after\n    # maybe 2020 for compatibility reason (with 3.4.1 only).\n    for extension in file_desc.extensions_by_name.values():\n      self._file_desc_by_toplevel_extension[\n          extension.full_name] = file_desc\n\n  def _AddFileDescriptor(self, file_desc):\n    \"\"\"Adds a FileDescriptor to the pool, non-recursively.\n\n    If the FileDescriptor contains messages or enums, the caller must explicitly\n    register them.\n\n    Args:\n      file_desc: A FileDescriptor.\n    \"\"\"\n\n    if not isinstance(file_desc, descriptor.FileDescriptor):\n      raise TypeError('Expected instance of descriptor.FileDescriptor.')\n    self._file_descriptors[file_desc.name] = file_desc\n\n  def FindFileByName(self, file_name):\n    \"\"\"Gets a FileDescriptor by file name.\n\n    Args:\n      file_name (str): The path to the file to get a descriptor for.\n\n    Returns:\n      FileDescriptor: The descriptor for the named file.\n\n    Raises:\n      KeyError: if the file cannot be found in the pool.\n    \"\"\"\n\n    try:\n      return self._file_descriptors[file_name]\n    except KeyError:\n      pass\n\n    try:\n      file_proto = self._internal_db.FindFileByName(file_name)\n    except KeyError as error:\n      if self._descriptor_db:\n        file_proto = self._descriptor_db.FindFileByName(file_name)\n      else:\n        raise error\n    if not file_proto:\n      raise KeyError('Cannot find a file named %s' % file_name)\n    return self._ConvertFileProtoToFileDescriptor(file_proto)\n\n  def FindFileContainingSymbol(self, symbol):\n    \"\"\"Gets the FileDescriptor for the file containing the specified symbol.\n\n    Args:\n      symbol (str): The name of the symbol to search for.\n\n    Returns:\n      FileDescriptor: Descriptor for the file that contains the specified\n      symbol.\n\n    Raises:\n      KeyError: if the file cannot be found in the pool.\n    \"\"\"\n\n    symbol = _NormalizeFullyQualifiedName(symbol)\n    try:\n      return self._InternalFindFileContainingSymbol(symbol)\n    except KeyError:\n      pass\n\n    try:\n      # Try fallback database. Build and find again if possible.\n      self._FindFileContainingSymbolInDb(symbol)\n      return self._InternalFindFileContainingSymbol(symbol)\n    except KeyError:\n      raise KeyError('Cannot find a file containing %s' % symbol)\n\n  def _InternalFindFileContainingSymbol(self, symbol):\n    \"\"\"Gets the already built FileDescriptor containing the specified symbol.\n\n    Args:\n      symbol (str): The name of the symbol to search for.\n\n    Returns:\n      FileDescriptor: Descriptor for the file that contains the specified\n      symbol.\n\n    Raises:\n      KeyError: if the file cannot be found in the pool.\n    \"\"\"\n    try:\n      return self._descriptors[symbol].file\n    except KeyError:\n      pass\n\n    try:\n      return self._enum_descriptors[symbol].file\n    except KeyError:\n      pass\n\n    try:\n      return self._service_descriptors[symbol].file\n    except KeyError:\n      pass\n\n    try:\n      return self._top_enum_values[symbol].type.file\n    except KeyError:\n      pass\n\n    try:\n      return self._file_desc_by_toplevel_extension[symbol]\n    except KeyError:\n      pass\n\n    # Try fields, enum values and nested extensions inside a message.\n    top_name, _, sub_name = symbol.rpartition('.')\n    try:\n      message = self.FindMessageTypeByName(top_name)\n      assert (sub_name in message.extensions_by_name or\n              sub_name in message.fields_by_name or\n              sub_name in message.enum_values_by_name)\n      return message.file\n    except (KeyError, AssertionError):\n      raise KeyError('Cannot find a file containing %s' % symbol)\n\n  def FindMessageTypeByName(self, full_name):\n    \"\"\"Loads the named descriptor from the pool.\n\n    Args:\n      full_name (str): The full name of the descriptor to load.\n\n    Returns:\n      Descriptor: The descriptor for the named type.\n\n    Raises:\n      KeyError: if the message cannot be found in the pool.\n    \"\"\"\n\n    full_name = _NormalizeFullyQualifiedName(full_name)\n    if full_name not in self._descriptors:\n      self._FindFileContainingSymbolInDb(full_name)\n    return self._descriptors[full_name]\n\n  def FindEnumTypeByName(self, full_name):\n    \"\"\"Loads the named enum descriptor from the pool.\n\n    Args:\n      full_name (str): The full name of the enum descriptor to load.\n\n    Returns:\n      EnumDescriptor: The enum descriptor for the named type.\n\n    Raises:\n      KeyError: if the enum cannot be found in the pool.\n    \"\"\"\n\n    full_name = _NormalizeFullyQualifiedName(full_name)\n    if full_name not in self._enum_descriptors:\n      self._FindFileContainingSymbolInDb(full_name)\n    return self._enum_descriptors[full_name]\n\n  def FindFieldByName(self, full_name):\n    \"\"\"Loads the named field descriptor from the pool.\n\n    Args:\n      full_name (str): The full name of the field descriptor to load.\n\n    Returns:\n      FieldDescriptor: The field descriptor for the named field.\n\n    Raises:\n      KeyError: if the field cannot be found in the pool.\n    \"\"\"\n    full_name = _NormalizeFullyQualifiedName(full_name)\n    message_name, _, field_name = full_name.rpartition('.')\n    message_descriptor = self.FindMessageTypeByName(message_name)\n    return message_descriptor.fields_by_name[field_name]\n\n  def FindOneofByName(self, full_name):\n    \"\"\"Loads the named oneof descriptor from the pool.\n\n    Args:\n      full_name (str): The full name of the oneof descriptor to load.\n\n    Returns:\n      OneofDescriptor: The oneof descriptor for the named oneof.\n\n    Raises:\n      KeyError: if the oneof cannot be found in the pool.\n    \"\"\"\n    full_name = _NormalizeFullyQualifiedName(full_name)\n    message_name, _, oneof_name = full_name.rpartition('.')\n    message_descriptor = self.FindMessageTypeByName(message_name)\n    return message_descriptor.oneofs_by_name[oneof_name]\n\n  def FindExtensionByName(self, full_name):\n    \"\"\"Loads the named extension descriptor from the pool.\n\n    Args:\n      full_name (str): The full name of the extension descriptor to load.\n\n    Returns:\n      FieldDescriptor: The field descriptor for the named extension.\n\n    Raises:\n      KeyError: if the extension cannot be found in the pool.\n    \"\"\"\n    full_name = _NormalizeFullyQualifiedName(full_name)\n    try:\n      # The proto compiler does not give any link between the FileDescriptor\n      # and top-level extensions unless the FileDescriptorProto is added to\n      # the DescriptorDatabase, but this can impact memory usage.\n      # So we registered these extensions by name explicitly.\n      return self._toplevel_extensions[full_name]\n    except KeyError:\n      pass\n    message_name, _, extension_name = full_name.rpartition('.')\n    try:\n      # Most extensions are nested inside a message.\n      scope = self.FindMessageTypeByName(message_name)\n    except KeyError:\n      # Some extensions are defined at file scope.\n      scope = self._FindFileContainingSymbolInDb(full_name)\n    return scope.extensions_by_name[extension_name]\n\n  def FindExtensionByNumber(self, message_descriptor, number):\n    \"\"\"Gets the extension of the specified message with the specified number.\n\n    Extensions have to be registered to this pool by calling :func:`Add` or\n    :func:`AddExtensionDescriptor`.\n\n    Args:\n      message_descriptor (Descriptor): descriptor of the extended message.\n      number (int): Number of the extension field.\n\n    Returns:\n      FieldDescriptor: The descriptor for the extension.\n\n    Raises:\n      KeyError: when no extension with the given number is known for the\n        specified message.\n    \"\"\"\n    try:\n      return self._extensions_by_number[message_descriptor][number]\n    except KeyError:\n      self._TryLoadExtensionFromDB(message_descriptor, number)\n      return self._extensions_by_number[message_descriptor][number]\n\n  def FindAllExtensions(self, message_descriptor):\n    \"\"\"Gets all the known extensions of a given message.\n\n    Extensions have to be registered to this pool by build related\n    :func:`Add` or :func:`AddExtensionDescriptor`.\n\n    Args:\n      message_descriptor (Descriptor): Descriptor of the extended message.\n\n    Returns:\n      list[FieldDescriptor]: Field descriptors describing the extensions.\n    \"\"\"\n    # Fallback to descriptor db if FindAllExtensionNumbers is provided.\n    if self._descriptor_db and hasattr(\n        self._descriptor_db, 'FindAllExtensionNumbers'):\n      full_name = message_descriptor.full_name\n      all_numbers = self._descriptor_db.FindAllExtensionNumbers(full_name)\n      for number in all_numbers:\n        if number in self._extensions_by_number[message_descriptor]:\n          continue\n        self._TryLoadExtensionFromDB(message_descriptor, number)\n\n    return list(self._extensions_by_number[message_descriptor].values())\n\n  def _TryLoadExtensionFromDB(self, message_descriptor, number):\n    \"\"\"Try to Load extensions from descriptor db.\n\n    Args:\n      message_descriptor: descriptor of the extended message.\n      number: the extension number that needs to be loaded.\n    \"\"\"\n    if not self._descriptor_db:\n      return\n    # Only supported when FindFileContainingExtension is provided.\n    if not hasattr(\n        self._descriptor_db, 'FindFileContainingExtension'):\n      return\n\n    full_name = message_descriptor.full_name\n    file_proto = self._descriptor_db.FindFileContainingExtension(\n        full_name, number)\n\n    if file_proto is None:\n      return\n\n    try:\n      self._ConvertFileProtoToFileDescriptor(file_proto)\n    except:\n      warn_msg = ('Unable to load proto file %s for extension number %d.' %\n                  (file_proto.name, number))\n      warnings.warn(warn_msg, RuntimeWarning)\n\n  def FindServiceByName(self, full_name):\n    \"\"\"Loads the named service descriptor from the pool.\n\n    Args:\n      full_name (str): The full name of the service descriptor to load.\n\n    Returns:\n      ServiceDescriptor: The service descriptor for the named service.\n\n    Raises:\n      KeyError: if the service cannot be found in the pool.\n    \"\"\"\n    full_name = _NormalizeFullyQualifiedName(full_name)\n    if full_name not in self._service_descriptors:\n      self._FindFileContainingSymbolInDb(full_name)\n    return self._service_descriptors[full_name]\n\n  def FindMethodByName(self, full_name):\n    \"\"\"Loads the named service method descriptor from the pool.\n\n    Args:\n      full_name (str): The full name of the method descriptor to load.\n\n    Returns:\n      MethodDescriptor: The method descriptor for the service method.\n\n    Raises:\n      KeyError: if the method cannot be found in the pool.\n    \"\"\"\n    full_name = _NormalizeFullyQualifiedName(full_name)\n    service_name, _, method_name = full_name.rpartition('.')\n    service_descriptor = self.FindServiceByName(service_name)\n    return service_descriptor.methods_by_name[method_name]\n\n  def _FindFileContainingSymbolInDb(self, symbol):\n    \"\"\"Finds the file in descriptor DB containing the specified symbol.\n\n    Args:\n      symbol (str): The name of the symbol to search for.\n\n    Returns:\n      FileDescriptor: The file that contains the specified symbol.\n\n    Raises:\n      KeyError: if the file cannot be found in the descriptor database.\n    \"\"\"\n    try:\n      file_proto = self._internal_db.FindFileContainingSymbol(symbol)\n    except KeyError as error:\n      if self._descriptor_db:\n        file_proto = self._descriptor_db.FindFileContainingSymbol(symbol)\n      else:\n        raise error\n    if not file_proto:\n      raise KeyError('Cannot find a file containing %s' % symbol)\n    return self._ConvertFileProtoToFileDescriptor(file_proto)\n\n  def _ConvertFileProtoToFileDescriptor(self, file_proto):\n    \"\"\"Creates a FileDescriptor from a proto or returns a cached copy.\n\n    This method also has the side effect of loading all the symbols found in\n    the file into the appropriate dictionaries in the pool.\n\n    Args:\n      file_proto: The proto to convert.\n\n    Returns:\n      A FileDescriptor matching the passed in proto.\n    \"\"\"\n    if file_proto.name not in self._file_descriptors:\n      built_deps = list(self._GetDeps(file_proto.dependency))\n      direct_deps = [self.FindFileByName(n) for n in file_proto.dependency]\n      public_deps = [direct_deps[i] for i in file_proto.public_dependency]\n\n      file_descriptor = descriptor.FileDescriptor(\n          pool=self,\n          name=file_proto.name,\n          package=file_proto.package,\n          syntax=file_proto.syntax,\n          options=_OptionsOrNone(file_proto),\n          serialized_pb=file_proto.SerializeToString(),\n          dependencies=direct_deps,\n          public_dependencies=public_deps,\n          # pylint: disable=protected-access\n          create_key=descriptor._internal_create_key)\n      scope = {}\n\n      # This loop extracts all the message and enum types from all the\n      # dependencies of the file_proto. This is necessary to create the\n      # scope of available message types when defining the passed in\n      # file proto.\n      for dependency in built_deps:\n        scope.update(self._ExtractSymbols(\n            dependency.message_types_by_name.values()))\n        scope.update((_PrefixWithDot(enum.full_name), enum)\n                     for enum in dependency.enum_types_by_name.values())\n\n      for message_type in file_proto.message_type:\n        message_desc = self._ConvertMessageDescriptor(\n            message_type, file_proto.package, file_descriptor, scope,\n            file_proto.syntax)\n        file_descriptor.message_types_by_name[message_desc.name] = (\n            message_desc)\n\n      for enum_type in file_proto.enum_type:\n        file_descriptor.enum_types_by_name[enum_type.name] = (\n            self._ConvertEnumDescriptor(enum_type, file_proto.package,\n                                        file_descriptor, None, scope, True))\n\n      for index, extension_proto in enumerate(file_proto.extension):\n        extension_desc = self._MakeFieldDescriptor(\n            extension_proto, file_proto.package, index, file_descriptor,\n            is_extension=True)\n        extension_desc.containing_type = self._GetTypeFromScope(\n            file_descriptor.package, extension_proto.extendee, scope)\n        self._SetFieldType(extension_proto, extension_desc,\n                           file_descriptor.package, scope)\n        file_descriptor.extensions_by_name[extension_desc.name] = (\n            extension_desc)\n        self._file_desc_by_toplevel_extension[extension_desc.full_name] = (\n            file_descriptor)\n\n      for desc_proto in file_proto.message_type:\n        self._SetAllFieldTypes(file_proto.package, desc_proto, scope)\n\n      if file_proto.package:\n        desc_proto_prefix = _PrefixWithDot(file_proto.package)\n      else:\n        desc_proto_prefix = ''\n\n      for desc_proto in file_proto.message_type:\n        desc = self._GetTypeFromScope(\n            desc_proto_prefix, desc_proto.name, scope)\n        file_descriptor.message_types_by_name[desc_proto.name] = desc\n\n      for index, service_proto in enumerate(file_proto.service):\n        file_descriptor.services_by_name[service_proto.name] = (\n            self._MakeServiceDescriptor(service_proto, index, scope,\n                                        file_proto.package, file_descriptor))\n\n      self._file_descriptors[file_proto.name] = file_descriptor\n\n    # Add extensions to the pool\n    file_desc = self._file_descriptors[file_proto.name]\n    for extension in file_desc.extensions_by_name.values():\n      self._AddExtensionDescriptor(extension)\n    for message_type in file_desc.message_types_by_name.values():\n      for extension in message_type.extensions:\n        self._AddExtensionDescriptor(extension)\n\n    return file_desc\n\n  def _ConvertMessageDescriptor(self, desc_proto, package=None, file_desc=None,\n                                scope=None, syntax=None):\n    \"\"\"Adds the proto to the pool in the specified package.\n\n    Args:\n      desc_proto: The descriptor_pb2.DescriptorProto protobuf message.\n      package: The package the proto should be located in.\n      file_desc: The file containing this message.\n      scope: Dict mapping short and full symbols to message and enum types.\n      syntax: string indicating syntax of the file (\"proto2\" or \"proto3\")\n\n    Returns:\n      The added descriptor.\n    \"\"\"\n\n    if package:\n      desc_name = '.'.join((package, desc_proto.name))\n    else:\n      desc_name = desc_proto.name\n\n    if file_desc is None:\n      file_name = None\n    else:\n      file_name = file_desc.name\n\n    if scope is None:\n      scope = {}\n\n    nested = [\n        self._ConvertMessageDescriptor(\n            nested, desc_name, file_desc, scope, syntax)\n        for nested in desc_proto.nested_type]\n    enums = [\n        self._ConvertEnumDescriptor(enum, desc_name, file_desc, None,\n                                    scope, False)\n        for enum in desc_proto.enum_type]\n    fields = [self._MakeFieldDescriptor(field, desc_name, index, file_desc)\n              for index, field in enumerate(desc_proto.field)]\n    extensions = [\n        self._MakeFieldDescriptor(extension, desc_name, index, file_desc,\n                                  is_extension=True)\n        for index, extension in enumerate(desc_proto.extension)]\n    oneofs = [\n        # pylint: disable=g-complex-comprehension\n        descriptor.OneofDescriptor(\n            desc.name,\n            '.'.join((desc_name, desc.name)),\n            index,\n            None,\n            [],\n            _OptionsOrNone(desc),\n            # pylint: disable=protected-access\n            create_key=descriptor._internal_create_key)\n        for index, desc in enumerate(desc_proto.oneof_decl)\n    ]\n    extension_ranges = [(r.start, r.end) for r in desc_proto.extension_range]\n    if extension_ranges:\n      is_extendable = True\n    else:\n      is_extendable = False\n    desc = descriptor.Descriptor(\n        name=desc_proto.name,\n        full_name=desc_name,\n        filename=file_name,\n        containing_type=None,\n        fields=fields,\n        oneofs=oneofs,\n        nested_types=nested,\n        enum_types=enums,\n        extensions=extensions,\n        options=_OptionsOrNone(desc_proto),\n        is_extendable=is_extendable,\n        extension_ranges=extension_ranges,\n        file=file_desc,\n        serialized_start=None,\n        serialized_end=None,\n        syntax=syntax,\n        # pylint: disable=protected-access\n        create_key=descriptor._internal_create_key)\n    for nested in desc.nested_types:\n      nested.containing_type = desc\n    for enum in desc.enum_types:\n      enum.containing_type = desc\n    for field_index, field_desc in enumerate(desc_proto.field):\n      if field_desc.HasField('oneof_index'):\n        oneof_index = field_desc.oneof_index\n        oneofs[oneof_index].fields.append(fields[field_index])\n        fields[field_index].containing_oneof = oneofs[oneof_index]\n\n    scope[_PrefixWithDot(desc_name)] = desc\n    self._CheckConflictRegister(desc, desc.full_name, desc.file.name)\n    self._descriptors[desc_name] = desc\n    return desc\n\n  def _ConvertEnumDescriptor(self, enum_proto, package=None, file_desc=None,\n                             containing_type=None, scope=None, top_level=False):\n    \"\"\"Make a protobuf EnumDescriptor given an EnumDescriptorProto protobuf.\n\n    Args:\n      enum_proto: The descriptor_pb2.EnumDescriptorProto protobuf message.\n      package: Optional package name for the new message EnumDescriptor.\n      file_desc: The file containing the enum descriptor.\n      containing_type: The type containing this enum.\n      scope: Scope containing available types.\n      top_level: If True, the enum is a top level symbol. If False, the enum\n          is defined inside a message.\n\n    Returns:\n      The added descriptor\n    \"\"\"\n\n    if package:\n      enum_name = '.'.join((package, enum_proto.name))\n    else:\n      enum_name = enum_proto.name\n\n    if file_desc is None:\n      file_name = None\n    else:\n      file_name = file_desc.name\n\n    values = [self._MakeEnumValueDescriptor(value, index)\n              for index, value in enumerate(enum_proto.value)]\n    desc = descriptor.EnumDescriptor(name=enum_proto.name,\n                                     full_name=enum_name,\n                                     filename=file_name,\n                                     file=file_desc,\n                                     values=values,\n                                     containing_type=containing_type,\n                                     options=_OptionsOrNone(enum_proto),\n                                     # pylint: disable=protected-access\n                                     create_key=descriptor._internal_create_key)\n    scope['.%s' % enum_name] = desc\n    self._CheckConflictRegister(desc, desc.full_name, desc.file.name)\n    self._enum_descriptors[enum_name] = desc\n\n    # Add top level enum values.\n    if top_level:\n      for value in values:\n        full_name = _NormalizeFullyQualifiedName(\n            '.'.join((package, value.name)))\n        self._CheckConflictRegister(value, full_name, file_name)\n        self._top_enum_values[full_name] = value\n\n    return desc\n\n  def _MakeFieldDescriptor(self, field_proto, message_name, index,\n                           file_desc, is_extension=False):\n    \"\"\"Creates a field descriptor from a FieldDescriptorProto.\n\n    For message and enum type fields, this method will do a look up\n    in the pool for the appropriate descriptor for that type. If it\n    is unavailable, it will fall back to the _source function to\n    create it. If this type is still unavailable, construction will\n    fail.\n\n    Args:\n      field_proto: The proto describing the field.\n      message_name: The name of the containing message.\n      index: Index of the field\n      file_desc: The file containing the field descriptor.\n      is_extension: Indication that this field is for an extension.\n\n    Returns:\n      An initialized FieldDescriptor object\n    \"\"\"\n\n    if message_name:\n      full_name = '.'.join((message_name, field_proto.name))\n    else:\n      full_name = field_proto.name\n\n    if field_proto.json_name:\n      json_name = field_proto.json_name\n    else:\n      json_name = None\n\n    return descriptor.FieldDescriptor(\n        name=field_proto.name,\n        full_name=full_name,\n        index=index,\n        number=field_proto.number,\n        type=field_proto.type,\n        cpp_type=None,\n        message_type=None,\n        enum_type=None,\n        containing_type=None,\n        label=field_proto.label,\n        has_default_value=False,\n        default_value=None,\n        is_extension=is_extension,\n        extension_scope=None,\n        options=_OptionsOrNone(field_proto),\n        json_name=json_name,\n        file=file_desc,\n        # pylint: disable=protected-access\n        create_key=descriptor._internal_create_key)\n\n  def _SetAllFieldTypes(self, package, desc_proto, scope):\n    \"\"\"Sets all the descriptor's fields's types.\n\n    This method also sets the containing types on any extensions.\n\n    Args:\n      package: The current package of desc_proto.\n      desc_proto: The message descriptor to update.\n      scope: Enclosing scope of available types.\n    \"\"\"\n\n    package = _PrefixWithDot(package)\n\n    main_desc = self._GetTypeFromScope(package, desc_proto.name, scope)\n\n    if package == '.':\n      nested_package = _PrefixWithDot(desc_proto.name)\n    else:\n      nested_package = '.'.join([package, desc_proto.name])\n\n    for field_proto, field_desc in zip(desc_proto.field, main_desc.fields):\n      self._SetFieldType(field_proto, field_desc, nested_package, scope)\n\n    for extension_proto, extension_desc in (\n        zip(desc_proto.extension, main_desc.extensions)):\n      extension_desc.containing_type = self._GetTypeFromScope(\n          nested_package, extension_proto.extendee, scope)\n      self._SetFieldType(extension_proto, extension_desc, nested_package, scope)\n\n    for nested_type in desc_proto.nested_type:\n      self._SetAllFieldTypes(nested_package, nested_type, scope)\n\n  def _SetFieldType(self, field_proto, field_desc, package, scope):\n    \"\"\"Sets the field's type, cpp_type, message_type and enum_type.\n\n    Args:\n      field_proto: Data about the field in proto format.\n      field_desc: The descriptor to modify.\n      package: The package the field's container is in.\n      scope: Enclosing scope of available types.\n    \"\"\"\n    if field_proto.type_name:\n      desc = self._GetTypeFromScope(package, field_proto.type_name, scope)\n    else:\n      desc = None\n\n    if not field_proto.HasField('type'):\n      if isinstance(desc, descriptor.Descriptor):\n        field_proto.type = descriptor.FieldDescriptor.TYPE_MESSAGE\n      else:\n        field_proto.type = descriptor.FieldDescriptor.TYPE_ENUM\n\n    field_desc.cpp_type = descriptor.FieldDescriptor.ProtoTypeToCppProtoType(\n        field_proto.type)\n\n    if (field_proto.type == descriptor.FieldDescriptor.TYPE_MESSAGE\n        or field_proto.type == descriptor.FieldDescriptor.TYPE_GROUP):\n      field_desc.message_type = desc\n\n    if field_proto.type == descriptor.FieldDescriptor.TYPE_ENUM:\n      field_desc.enum_type = desc\n\n    if field_proto.label == descriptor.FieldDescriptor.LABEL_REPEATED:\n      field_desc.has_default_value = False\n      field_desc.default_value = []\n    elif field_proto.HasField('default_value'):\n      field_desc.has_default_value = True\n      if (field_proto.type == descriptor.FieldDescriptor.TYPE_DOUBLE or\n          field_proto.type == descriptor.FieldDescriptor.TYPE_FLOAT):\n        field_desc.default_value = float(field_proto.default_value)\n      elif field_proto.type == descriptor.FieldDescriptor.TYPE_STRING:\n        field_desc.default_value = field_proto.default_value\n      elif field_proto.type == descriptor.FieldDescriptor.TYPE_BOOL:\n        field_desc.default_value = field_proto.default_value.lower() == 'true'\n      elif field_proto.type == descriptor.FieldDescriptor.TYPE_ENUM:\n        field_desc.default_value = field_desc.enum_type.values_by_name[\n            field_proto.default_value].number\n      elif field_proto.type == descriptor.FieldDescriptor.TYPE_BYTES:\n        field_desc.default_value = text_encoding.CUnescape(\n            field_proto.default_value)\n      elif field_proto.type == descriptor.FieldDescriptor.TYPE_MESSAGE:\n        field_desc.default_value = None\n      else:\n        # All other types are of the \"int\" type.\n        field_desc.default_value = int(field_proto.default_value)\n    else:\n      field_desc.has_default_value = False\n      if (field_proto.type == descriptor.FieldDescriptor.TYPE_DOUBLE or\n          field_proto.type == descriptor.FieldDescriptor.TYPE_FLOAT):\n        field_desc.default_value = 0.0\n      elif field_proto.type == descriptor.FieldDescriptor.TYPE_STRING:\n        field_desc.default_value = u''\n      elif field_proto.type == descriptor.FieldDescriptor.TYPE_BOOL:\n        field_desc.default_value = False\n      elif field_proto.type == descriptor.FieldDescriptor.TYPE_ENUM:\n        field_desc.default_value = field_desc.enum_type.values[0].number\n      elif field_proto.type == descriptor.FieldDescriptor.TYPE_BYTES:\n        field_desc.default_value = b''\n      elif field_proto.type == descriptor.FieldDescriptor.TYPE_MESSAGE:\n        field_desc.default_value = None\n      elif field_proto.type == descriptor.FieldDescriptor.TYPE_GROUP:\n        field_desc.default_value = None\n      else:\n        # All other types are of the \"int\" type.\n        field_desc.default_value = 0\n\n    field_desc.type = field_proto.type\n\n  def _MakeEnumValueDescriptor(self, value_proto, index):\n    \"\"\"Creates a enum value descriptor object from a enum value proto.\n\n    Args:\n      value_proto: The proto describing the enum value.\n      index: The index of the enum value.\n\n    Returns:\n      An initialized EnumValueDescriptor object.\n    \"\"\"\n\n    return descriptor.EnumValueDescriptor(\n        name=value_proto.name,\n        index=index,\n        number=value_proto.number,\n        options=_OptionsOrNone(value_proto),\n        type=None,\n        # pylint: disable=protected-access\n        create_key=descriptor._internal_create_key)\n\n  def _MakeServiceDescriptor(self, service_proto, service_index, scope,\n                             package, file_desc):\n    \"\"\"Make a protobuf ServiceDescriptor given a ServiceDescriptorProto.\n\n    Args:\n      service_proto: The descriptor_pb2.ServiceDescriptorProto protobuf message.\n      service_index: The index of the service in the File.\n      scope: Dict mapping short and full symbols to message and enum types.\n      package: Optional package name for the new message EnumDescriptor.\n      file_desc: The file containing the service descriptor.\n\n    Returns:\n      The added descriptor.\n    \"\"\"\n\n    if package:\n      service_name = '.'.join((package, service_proto.name))\n    else:\n      service_name = service_proto.name\n\n    methods = [self._MakeMethodDescriptor(method_proto, service_name, package,\n                                          scope, index)\n               for index, method_proto in enumerate(service_proto.method)]\n    desc = descriptor.ServiceDescriptor(\n        name=service_proto.name,\n        full_name=service_name,\n        index=service_index,\n        methods=methods,\n        options=_OptionsOrNone(service_proto),\n        file=file_desc,\n        # pylint: disable=protected-access\n        create_key=descriptor._internal_create_key)\n    self._CheckConflictRegister(desc, desc.full_name, desc.file.name)\n    self._service_descriptors[service_name] = desc\n    return desc\n\n  def _MakeMethodDescriptor(self, method_proto, service_name, package, scope,\n                            index):\n    \"\"\"Creates a method descriptor from a MethodDescriptorProto.\n\n    Args:\n      method_proto: The proto describing the method.\n      service_name: The name of the containing service.\n      package: Optional package name to look up for types.\n      scope: Scope containing available types.\n      index: Index of the method in the service.\n\n    Returns:\n      An initialized MethodDescriptor object.\n    \"\"\"\n    full_name = '.'.join((service_name, method_proto.name))\n    input_type = self._GetTypeFromScope(\n        package, method_proto.input_type, scope)\n    output_type = self._GetTypeFromScope(\n        package, method_proto.output_type, scope)\n    return descriptor.MethodDescriptor(\n        name=method_proto.name,\n        full_name=full_name,\n        index=index,\n        containing_service=None,\n        input_type=input_type,\n        output_type=output_type,\n        client_streaming=method_proto.client_streaming,\n        server_streaming=method_proto.server_streaming,\n        options=_OptionsOrNone(method_proto),\n        # pylint: disable=protected-access\n        create_key=descriptor._internal_create_key)\n\n  def _ExtractSymbols(self, descriptors):\n    \"\"\"Pulls out all the symbols from descriptor protos.\n\n    Args:\n      descriptors: The messages to extract descriptors from.\n    Yields:\n      A two element tuple of the type name and descriptor object.\n    \"\"\"\n\n    for desc in descriptors:\n      yield (_PrefixWithDot(desc.full_name), desc)\n      for symbol in self._ExtractSymbols(desc.nested_types):\n        yield symbol\n      for enum in desc.enum_types:\n        yield (_PrefixWithDot(enum.full_name), enum)\n\n  def _GetDeps(self, dependencies, visited=None):\n    \"\"\"Recursively finds dependencies for file protos.\n\n    Args:\n      dependencies: The names of the files being depended on.\n      visited: The names of files already found.\n\n    Yields:\n      Each direct and indirect dependency.\n    \"\"\"\n\n    visited = visited or set()\n    for dependency in dependencies:\n      if dependency not in visited:\n        visited.add(dependency)\n        dep_desc = self.FindFileByName(dependency)\n        yield dep_desc\n        public_files = [d.name for d in dep_desc.public_dependencies]\n        yield from self._GetDeps(public_files, visited)\n\n  def _GetTypeFromScope(self, package, type_name, scope):\n    \"\"\"Finds a given type name in the current scope.\n\n    Args:\n      package: The package the proto should be located in.\n      type_name: The name of the type to be found in the scope.\n      scope: Dict mapping short and full symbols to message and enum types.\n\n    Returns:\n      The descriptor for the requested type.\n    \"\"\"\n    if type_name not in scope:\n      components = _PrefixWithDot(package).split('.')\n      while components:\n        possible_match = '.'.join(components + [type_name])\n        if possible_match in scope:\n          type_name = possible_match\n          break\n        else:\n          components.pop(-1)\n    return scope[type_name]\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/descriptor_pool.html#client.ayon_hiero.vendor.google.protobuf.descriptor_pool.DescriptorPool.Add","title":"<code>Add(file_desc_proto)</code>","text":"<p>Adds the FileDescriptorProto and its types to this pool.</p> <p>Parameters:</p> Name Type Description Default <code>file_desc_proto</code> <code>FileDescriptorProto</code> <p>The file descriptor to add.</p> required Source code in <code>client/ayon_hiero/vendor/google/protobuf/descriptor_pool.py</code> <pre><code>def Add(self, file_desc_proto):\n  \"\"\"Adds the FileDescriptorProto and its types to this pool.\n\n  Args:\n    file_desc_proto (FileDescriptorProto): The file descriptor to add.\n  \"\"\"\n\n  self._internal_db.Add(file_desc_proto)\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/descriptor_pool.html#client.ayon_hiero.vendor.google.protobuf.descriptor_pool.DescriptorPool.AddSerializedFile","title":"<code>AddSerializedFile(serialized_file_desc_proto)</code>","text":"<p>Adds the FileDescriptorProto and its types to this pool.</p> <p>Parameters:</p> Name Type Description Default <code>serialized_file_desc_proto</code> <code>bytes</code> <p>A bytes string, serialization of the :class:<code>FileDescriptorProto</code> to add.</p> required <p>Returns:</p> Name Type Description <code>FileDescriptor</code> <p>Descriptor for the added file.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/descriptor_pool.py</code> <pre><code>def AddSerializedFile(self, serialized_file_desc_proto):\n  \"\"\"Adds the FileDescriptorProto and its types to this pool.\n\n  Args:\n    serialized_file_desc_proto (bytes): A bytes string, serialization of the\n      :class:`FileDescriptorProto` to add.\n\n  Returns:\n    FileDescriptor: Descriptor for the added file.\n  \"\"\"\n\n  # pylint: disable=g-import-not-at-top\n  from google.protobuf import descriptor_pb2\n  file_desc_proto = descriptor_pb2.FileDescriptorProto.FromString(\n      serialized_file_desc_proto)\n  file_desc = self._ConvertFileProtoToFileDescriptor(file_desc_proto)\n  file_desc.serialized_pb = serialized_file_desc_proto\n  return file_desc\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/descriptor_pool.html#client.ayon_hiero.vendor.google.protobuf.descriptor_pool.DescriptorPool.FindAllExtensions","title":"<code>FindAllExtensions(message_descriptor)</code>","text":"<p>Gets all the known extensions of a given message.</p> <p>Extensions have to be registered to this pool by build related :func:<code>Add</code> or :func:<code>AddExtensionDescriptor</code>.</p> <p>Parameters:</p> Name Type Description Default <code>message_descriptor</code> <code>Descriptor</code> <p>Descriptor of the extended message.</p> required <p>Returns:</p> Type Description <p>list[FieldDescriptor]: Field descriptors describing the extensions.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/descriptor_pool.py</code> <pre><code>def FindAllExtensions(self, message_descriptor):\n  \"\"\"Gets all the known extensions of a given message.\n\n  Extensions have to be registered to this pool by build related\n  :func:`Add` or :func:`AddExtensionDescriptor`.\n\n  Args:\n    message_descriptor (Descriptor): Descriptor of the extended message.\n\n  Returns:\n    list[FieldDescriptor]: Field descriptors describing the extensions.\n  \"\"\"\n  # Fallback to descriptor db if FindAllExtensionNumbers is provided.\n  if self._descriptor_db and hasattr(\n      self._descriptor_db, 'FindAllExtensionNumbers'):\n    full_name = message_descriptor.full_name\n    all_numbers = self._descriptor_db.FindAllExtensionNumbers(full_name)\n    for number in all_numbers:\n      if number in self._extensions_by_number[message_descriptor]:\n        continue\n      self._TryLoadExtensionFromDB(message_descriptor, number)\n\n  return list(self._extensions_by_number[message_descriptor].values())\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/descriptor_pool.html#client.ayon_hiero.vendor.google.protobuf.descriptor_pool.DescriptorPool.FindEnumTypeByName","title":"<code>FindEnumTypeByName(full_name)</code>","text":"<p>Loads the named enum descriptor from the pool.</p> <p>Parameters:</p> Name Type Description Default <code>full_name</code> <code>str</code> <p>The full name of the enum descriptor to load.</p> required <p>Returns:</p> Name Type Description <code>EnumDescriptor</code> <p>The enum descriptor for the named type.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>if the enum cannot be found in the pool.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/descriptor_pool.py</code> <pre><code>def FindEnumTypeByName(self, full_name):\n  \"\"\"Loads the named enum descriptor from the pool.\n\n  Args:\n    full_name (str): The full name of the enum descriptor to load.\n\n  Returns:\n    EnumDescriptor: The enum descriptor for the named type.\n\n  Raises:\n    KeyError: if the enum cannot be found in the pool.\n  \"\"\"\n\n  full_name = _NormalizeFullyQualifiedName(full_name)\n  if full_name not in self._enum_descriptors:\n    self._FindFileContainingSymbolInDb(full_name)\n  return self._enum_descriptors[full_name]\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/descriptor_pool.html#client.ayon_hiero.vendor.google.protobuf.descriptor_pool.DescriptorPool.FindExtensionByName","title":"<code>FindExtensionByName(full_name)</code>","text":"<p>Loads the named extension descriptor from the pool.</p> <p>Parameters:</p> Name Type Description Default <code>full_name</code> <code>str</code> <p>The full name of the extension descriptor to load.</p> required <p>Returns:</p> Name Type Description <code>FieldDescriptor</code> <p>The field descriptor for the named extension.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>if the extension cannot be found in the pool.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/descriptor_pool.py</code> <pre><code>def FindExtensionByName(self, full_name):\n  \"\"\"Loads the named extension descriptor from the pool.\n\n  Args:\n    full_name (str): The full name of the extension descriptor to load.\n\n  Returns:\n    FieldDescriptor: The field descriptor for the named extension.\n\n  Raises:\n    KeyError: if the extension cannot be found in the pool.\n  \"\"\"\n  full_name = _NormalizeFullyQualifiedName(full_name)\n  try:\n    # The proto compiler does not give any link between the FileDescriptor\n    # and top-level extensions unless the FileDescriptorProto is added to\n    # the DescriptorDatabase, but this can impact memory usage.\n    # So we registered these extensions by name explicitly.\n    return self._toplevel_extensions[full_name]\n  except KeyError:\n    pass\n  message_name, _, extension_name = full_name.rpartition('.')\n  try:\n    # Most extensions are nested inside a message.\n    scope = self.FindMessageTypeByName(message_name)\n  except KeyError:\n    # Some extensions are defined at file scope.\n    scope = self._FindFileContainingSymbolInDb(full_name)\n  return scope.extensions_by_name[extension_name]\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/descriptor_pool.html#client.ayon_hiero.vendor.google.protobuf.descriptor_pool.DescriptorPool.FindExtensionByNumber","title":"<code>FindExtensionByNumber(message_descriptor, number)</code>","text":"<p>Gets the extension of the specified message with the specified number.</p> <p>Extensions have to be registered to this pool by calling :func:<code>Add</code> or :func:<code>AddExtensionDescriptor</code>.</p> <p>Parameters:</p> Name Type Description Default <code>message_descriptor</code> <code>Descriptor</code> <p>descriptor of the extended message.</p> required <code>number</code> <code>int</code> <p>Number of the extension field.</p> required <p>Returns:</p> Name Type Description <code>FieldDescriptor</code> <p>The descriptor for the extension.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>when no extension with the given number is known for the specified message.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/descriptor_pool.py</code> <pre><code>def FindExtensionByNumber(self, message_descriptor, number):\n  \"\"\"Gets the extension of the specified message with the specified number.\n\n  Extensions have to be registered to this pool by calling :func:`Add` or\n  :func:`AddExtensionDescriptor`.\n\n  Args:\n    message_descriptor (Descriptor): descriptor of the extended message.\n    number (int): Number of the extension field.\n\n  Returns:\n    FieldDescriptor: The descriptor for the extension.\n\n  Raises:\n    KeyError: when no extension with the given number is known for the\n      specified message.\n  \"\"\"\n  try:\n    return self._extensions_by_number[message_descriptor][number]\n  except KeyError:\n    self._TryLoadExtensionFromDB(message_descriptor, number)\n    return self._extensions_by_number[message_descriptor][number]\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/descriptor_pool.html#client.ayon_hiero.vendor.google.protobuf.descriptor_pool.DescriptorPool.FindFieldByName","title":"<code>FindFieldByName(full_name)</code>","text":"<p>Loads the named field descriptor from the pool.</p> <p>Parameters:</p> Name Type Description Default <code>full_name</code> <code>str</code> <p>The full name of the field descriptor to load.</p> required <p>Returns:</p> Name Type Description <code>FieldDescriptor</code> <p>The field descriptor for the named field.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>if the field cannot be found in the pool.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/descriptor_pool.py</code> <pre><code>def FindFieldByName(self, full_name):\n  \"\"\"Loads the named field descriptor from the pool.\n\n  Args:\n    full_name (str): The full name of the field descriptor to load.\n\n  Returns:\n    FieldDescriptor: The field descriptor for the named field.\n\n  Raises:\n    KeyError: if the field cannot be found in the pool.\n  \"\"\"\n  full_name = _NormalizeFullyQualifiedName(full_name)\n  message_name, _, field_name = full_name.rpartition('.')\n  message_descriptor = self.FindMessageTypeByName(message_name)\n  return message_descriptor.fields_by_name[field_name]\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/descriptor_pool.html#client.ayon_hiero.vendor.google.protobuf.descriptor_pool.DescriptorPool.FindFileByName","title":"<code>FindFileByName(file_name)</code>","text":"<p>Gets a FileDescriptor by file name.</p> <p>Parameters:</p> Name Type Description Default <code>file_name</code> <code>str</code> <p>The path to the file to get a descriptor for.</p> required <p>Returns:</p> Name Type Description <code>FileDescriptor</code> <p>The descriptor for the named file.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>if the file cannot be found in the pool.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/descriptor_pool.py</code> <pre><code>def FindFileByName(self, file_name):\n  \"\"\"Gets a FileDescriptor by file name.\n\n  Args:\n    file_name (str): The path to the file to get a descriptor for.\n\n  Returns:\n    FileDescriptor: The descriptor for the named file.\n\n  Raises:\n    KeyError: if the file cannot be found in the pool.\n  \"\"\"\n\n  try:\n    return self._file_descriptors[file_name]\n  except KeyError:\n    pass\n\n  try:\n    file_proto = self._internal_db.FindFileByName(file_name)\n  except KeyError as error:\n    if self._descriptor_db:\n      file_proto = self._descriptor_db.FindFileByName(file_name)\n    else:\n      raise error\n  if not file_proto:\n    raise KeyError('Cannot find a file named %s' % file_name)\n  return self._ConvertFileProtoToFileDescriptor(file_proto)\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/descriptor_pool.html#client.ayon_hiero.vendor.google.protobuf.descriptor_pool.DescriptorPool.FindFileContainingSymbol","title":"<code>FindFileContainingSymbol(symbol)</code>","text":"<p>Gets the FileDescriptor for the file containing the specified symbol.</p> <p>Parameters:</p> Name Type Description Default <code>symbol</code> <code>str</code> <p>The name of the symbol to search for.</p> required <p>Returns:</p> Name Type Description <code>FileDescriptor</code> <p>Descriptor for the file that contains the specified</p> <p>symbol.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>if the file cannot be found in the pool.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/descriptor_pool.py</code> <pre><code>def FindFileContainingSymbol(self, symbol):\n  \"\"\"Gets the FileDescriptor for the file containing the specified symbol.\n\n  Args:\n    symbol (str): The name of the symbol to search for.\n\n  Returns:\n    FileDescriptor: Descriptor for the file that contains the specified\n    symbol.\n\n  Raises:\n    KeyError: if the file cannot be found in the pool.\n  \"\"\"\n\n  symbol = _NormalizeFullyQualifiedName(symbol)\n  try:\n    return self._InternalFindFileContainingSymbol(symbol)\n  except KeyError:\n    pass\n\n  try:\n    # Try fallback database. Build and find again if possible.\n    self._FindFileContainingSymbolInDb(symbol)\n    return self._InternalFindFileContainingSymbol(symbol)\n  except KeyError:\n    raise KeyError('Cannot find a file containing %s' % symbol)\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/descriptor_pool.html#client.ayon_hiero.vendor.google.protobuf.descriptor_pool.DescriptorPool.FindMessageTypeByName","title":"<code>FindMessageTypeByName(full_name)</code>","text":"<p>Loads the named descriptor from the pool.</p> <p>Parameters:</p> Name Type Description Default <code>full_name</code> <code>str</code> <p>The full name of the descriptor to load.</p> required <p>Returns:</p> Name Type Description <code>Descriptor</code> <p>The descriptor for the named type.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>if the message cannot be found in the pool.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/descriptor_pool.py</code> <pre><code>def FindMessageTypeByName(self, full_name):\n  \"\"\"Loads the named descriptor from the pool.\n\n  Args:\n    full_name (str): The full name of the descriptor to load.\n\n  Returns:\n    Descriptor: The descriptor for the named type.\n\n  Raises:\n    KeyError: if the message cannot be found in the pool.\n  \"\"\"\n\n  full_name = _NormalizeFullyQualifiedName(full_name)\n  if full_name not in self._descriptors:\n    self._FindFileContainingSymbolInDb(full_name)\n  return self._descriptors[full_name]\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/descriptor_pool.html#client.ayon_hiero.vendor.google.protobuf.descriptor_pool.DescriptorPool.FindMethodByName","title":"<code>FindMethodByName(full_name)</code>","text":"<p>Loads the named service method descriptor from the pool.</p> <p>Parameters:</p> Name Type Description Default <code>full_name</code> <code>str</code> <p>The full name of the method descriptor to load.</p> required <p>Returns:</p> Name Type Description <code>MethodDescriptor</code> <p>The method descriptor for the service method.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>if the method cannot be found in the pool.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/descriptor_pool.py</code> <pre><code>def FindMethodByName(self, full_name):\n  \"\"\"Loads the named service method descriptor from the pool.\n\n  Args:\n    full_name (str): The full name of the method descriptor to load.\n\n  Returns:\n    MethodDescriptor: The method descriptor for the service method.\n\n  Raises:\n    KeyError: if the method cannot be found in the pool.\n  \"\"\"\n  full_name = _NormalizeFullyQualifiedName(full_name)\n  service_name, _, method_name = full_name.rpartition('.')\n  service_descriptor = self.FindServiceByName(service_name)\n  return service_descriptor.methods_by_name[method_name]\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/descriptor_pool.html#client.ayon_hiero.vendor.google.protobuf.descriptor_pool.DescriptorPool.FindOneofByName","title":"<code>FindOneofByName(full_name)</code>","text":"<p>Loads the named oneof descriptor from the pool.</p> <p>Parameters:</p> Name Type Description Default <code>full_name</code> <code>str</code> <p>The full name of the oneof descriptor to load.</p> required <p>Returns:</p> Name Type Description <code>OneofDescriptor</code> <p>The oneof descriptor for the named oneof.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>if the oneof cannot be found in the pool.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/descriptor_pool.py</code> <pre><code>def FindOneofByName(self, full_name):\n  \"\"\"Loads the named oneof descriptor from the pool.\n\n  Args:\n    full_name (str): The full name of the oneof descriptor to load.\n\n  Returns:\n    OneofDescriptor: The oneof descriptor for the named oneof.\n\n  Raises:\n    KeyError: if the oneof cannot be found in the pool.\n  \"\"\"\n  full_name = _NormalizeFullyQualifiedName(full_name)\n  message_name, _, oneof_name = full_name.rpartition('.')\n  message_descriptor = self.FindMessageTypeByName(message_name)\n  return message_descriptor.oneofs_by_name[oneof_name]\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/descriptor_pool.html#client.ayon_hiero.vendor.google.protobuf.descriptor_pool.DescriptorPool.FindServiceByName","title":"<code>FindServiceByName(full_name)</code>","text":"<p>Loads the named service descriptor from the pool.</p> <p>Parameters:</p> Name Type Description Default <code>full_name</code> <code>str</code> <p>The full name of the service descriptor to load.</p> required <p>Returns:</p> Name Type Description <code>ServiceDescriptor</code> <p>The service descriptor for the named service.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>if the service cannot be found in the pool.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/descriptor_pool.py</code> <pre><code>def FindServiceByName(self, full_name):\n  \"\"\"Loads the named service descriptor from the pool.\n\n  Args:\n    full_name (str): The full name of the service descriptor to load.\n\n  Returns:\n    ServiceDescriptor: The service descriptor for the named service.\n\n  Raises:\n    KeyError: if the service cannot be found in the pool.\n  \"\"\"\n  full_name = _NormalizeFullyQualifiedName(full_name)\n  if full_name not in self._service_descriptors:\n    self._FindFileContainingSymbolInDb(full_name)\n  return self._service_descriptors[full_name]\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/descriptor_pool.html#client.ayon_hiero.vendor.google.protobuf.descriptor_pool.DescriptorPool.__init__","title":"<code>__init__(descriptor_db=None)</code>","text":"<p>Initializes a Pool of proto buffs.</p> <p>The descriptor_db argument to the constructor is provided to allow specialized file descriptor proto lookup code to be triggered on demand. An example would be an implementation which will read and compile a file specified in a call to FindFileByName() and not require the call to Add() at all. Results from this database will be cached internally here as well.</p> <p>Parameters:</p> Name Type Description Default <code>descriptor_db</code> <p>A secondary source of file descriptors.</p> <code>None</code> Source code in <code>client/ayon_hiero/vendor/google/protobuf/descriptor_pool.py</code> <pre><code>def __init__(self, descriptor_db=None):\n  \"\"\"Initializes a Pool of proto buffs.\n\n  The descriptor_db argument to the constructor is provided to allow\n  specialized file descriptor proto lookup code to be triggered on demand. An\n  example would be an implementation which will read and compile a file\n  specified in a call to FindFileByName() and not require the call to Add()\n  at all. Results from this database will be cached internally here as well.\n\n  Args:\n    descriptor_db: A secondary source of file descriptors.\n  \"\"\"\n\n  self._internal_db = descriptor_database.DescriptorDatabase()\n  self._descriptor_db = descriptor_db\n  self._descriptors = {}\n  self._enum_descriptors = {}\n  self._service_descriptors = {}\n  self._file_descriptors = {}\n  self._toplevel_extensions = {}\n  # TODO(jieluo): Remove _file_desc_by_toplevel_extension after\n  # maybe year 2020 for compatibility issue (with 3.4.1 only).\n  self._file_desc_by_toplevel_extension = {}\n  self._top_enum_values = {}\n  # We store extensions in two two-level mappings: The first key is the\n  # descriptor of the message being extended, the second key is the extension\n  # full name or its tag number.\n  self._extensions_by_name = collections.defaultdict(dict)\n  self._extensions_by_number = collections.defaultdict(dict)\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/duration_pb2.html","title":"duration_pb2","text":"<p>Generated protocol buffer code.</p>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/empty_pb2.html","title":"empty_pb2","text":"<p>Generated protocol buffer code.</p>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/field_mask_pb2.html","title":"field_mask_pb2","text":"<p>Generated protocol buffer code.</p>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/json_format.html","title":"json_format","text":"<p>Contains routines for printing protocol messages in JSON format.</p> <p>Simple usage example:</p> <p># Create a proto object and serialize it to a json format string.   message = my_proto_pb2.MyMessage(foo='bar')   json_string = json_format.MessageToJson(message)</p> <p># Parse a json format string to proto object.   message = json_format.Parse(json_string, my_proto_pb2.MyMessage())</p>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/json_format.html#client.ayon_hiero.vendor.google.protobuf.json_format.Error","title":"<code>Error</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Top-level module error for json_format.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/json_format.py</code> <pre><code>class Error(Exception):\n  \"\"\"Top-level module error for json_format.\"\"\"\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/json_format.html#client.ayon_hiero.vendor.google.protobuf.json_format.ParseError","title":"<code>ParseError</code>","text":"<p>               Bases: <code>Error</code></p> <p>Thrown in case of parsing error.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/json_format.py</code> <pre><code>class ParseError(Error):\n  \"\"\"Thrown in case of parsing error.\"\"\"\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/json_format.html#client.ayon_hiero.vendor.google.protobuf.json_format.SerializeToJsonError","title":"<code>SerializeToJsonError</code>","text":"<p>               Bases: <code>Error</code></p> <p>Thrown if serialization to JSON fails.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/json_format.py</code> <pre><code>class SerializeToJsonError(Error):\n  \"\"\"Thrown if serialization to JSON fails.\"\"\"\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/json_format.html#client.ayon_hiero.vendor.google.protobuf.json_format.MessageToDict","title":"<code>MessageToDict(message, including_default_value_fields=False, preserving_proto_field_name=False, use_integers_for_enums=False, descriptor_pool=None, float_precision=None)</code>","text":"<p>Converts protobuf message to a dictionary.</p> <p>When the dictionary is encoded to JSON, it conforms to proto3 JSON spec.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <p>The protocol buffers message instance to serialize.</p> required <code>including_default_value_fields</code> <p>If True, singular primitive fields,   repeated fields, and map fields will always be serialized.  If   False, only serialize non-empty fields.  Singular message fields   and oneof fields are not affected by this option.</p> <code>False</code> <code>preserving_proto_field_name</code> <p>If True, use the original proto field   names as defined in the .proto file. If False, convert the field   names to lowerCamelCase.</p> <code>False</code> <code>use_integers_for_enums</code> <p>If true, print integers instead of enum names.</p> <code>False</code> <code>descriptor_pool</code> <p>A Descriptor Pool for resolving types. If None use the   default.</p> <code>None</code> <code>float_precision</code> <p>If set, use this to specify float field valid digits.</p> <code>None</code> <p>Returns:</p> Type Description <p>A dict representation of the protocol buffer message.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/json_format.py</code> <pre><code>def MessageToDict(\n    message,\n    including_default_value_fields=False,\n    preserving_proto_field_name=False,\n    use_integers_for_enums=False,\n    descriptor_pool=None,\n    float_precision=None):\n  \"\"\"Converts protobuf message to a dictionary.\n\n  When the dictionary is encoded to JSON, it conforms to proto3 JSON spec.\n\n  Args:\n    message: The protocol buffers message instance to serialize.\n    including_default_value_fields: If True, singular primitive fields,\n        repeated fields, and map fields will always be serialized.  If\n        False, only serialize non-empty fields.  Singular message fields\n        and oneof fields are not affected by this option.\n    preserving_proto_field_name: If True, use the original proto field\n        names as defined in the .proto file. If False, convert the field\n        names to lowerCamelCase.\n    use_integers_for_enums: If true, print integers instead of enum names.\n    descriptor_pool: A Descriptor Pool for resolving types. If None use the\n        default.\n    float_precision: If set, use this to specify float field valid digits.\n\n  Returns:\n    A dict representation of the protocol buffer message.\n  \"\"\"\n  printer = _Printer(\n      including_default_value_fields,\n      preserving_proto_field_name,\n      use_integers_for_enums,\n      descriptor_pool,\n      float_precision=float_precision)\n  # pylint: disable=protected-access\n  return printer._MessageToJsonObject(message)\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/json_format.html#client.ayon_hiero.vendor.google.protobuf.json_format.MessageToJson","title":"<code>MessageToJson(message, including_default_value_fields=False, preserving_proto_field_name=False, indent=2, sort_keys=False, use_integers_for_enums=False, descriptor_pool=None, float_precision=None, ensure_ascii=True)</code>","text":"<p>Converts protobuf message to JSON format.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <p>The protocol buffers message instance to serialize.</p> required <code>including_default_value_fields</code> <p>If True, singular primitive fields,   repeated fields, and map fields will always be serialized.  If   False, only serialize non-empty fields.  Singular message fields   and oneof fields are not affected by this option.</p> <code>False</code> <code>preserving_proto_field_name</code> <p>If True, use the original proto field   names as defined in the .proto file. If False, convert the field   names to lowerCamelCase.</p> <code>False</code> <code>indent</code> <p>The JSON object will be pretty-printed with this indent level.   An indent level of 0 or negative will only insert newlines.</p> <code>2</code> <code>sort_keys</code> <p>If True, then the output will be sorted by field names.</p> <code>False</code> <code>use_integers_for_enums</code> <p>If true, print integers instead of enum names.</p> <code>False</code> <code>descriptor_pool</code> <p>A Descriptor Pool for resolving types. If None use the   default.</p> <code>None</code> <code>float_precision</code> <p>If set, use this to specify float field valid digits.</p> <code>None</code> <code>ensure_ascii</code> <p>If True, strings with non-ASCII characters are escaped.   If False, Unicode strings are returned unchanged.</p> <code>True</code> <p>Returns:</p> Type Description <p>A string containing the JSON formatted protocol buffer message.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/json_format.py</code> <pre><code>def MessageToJson(\n    message,\n    including_default_value_fields=False,\n    preserving_proto_field_name=False,\n    indent=2,\n    sort_keys=False,\n    use_integers_for_enums=False,\n    descriptor_pool=None,\n    float_precision=None,\n    ensure_ascii=True):\n  \"\"\"Converts protobuf message to JSON format.\n\n  Args:\n    message: The protocol buffers message instance to serialize.\n    including_default_value_fields: If True, singular primitive fields,\n        repeated fields, and map fields will always be serialized.  If\n        False, only serialize non-empty fields.  Singular message fields\n        and oneof fields are not affected by this option.\n    preserving_proto_field_name: If True, use the original proto field\n        names as defined in the .proto file. If False, convert the field\n        names to lowerCamelCase.\n    indent: The JSON object will be pretty-printed with this indent level.\n        An indent level of 0 or negative will only insert newlines.\n    sort_keys: If True, then the output will be sorted by field names.\n    use_integers_for_enums: If true, print integers instead of enum names.\n    descriptor_pool: A Descriptor Pool for resolving types. If None use the\n        default.\n    float_precision: If set, use this to specify float field valid digits.\n    ensure_ascii: If True, strings with non-ASCII characters are escaped.\n        If False, Unicode strings are returned unchanged.\n\n  Returns:\n    A string containing the JSON formatted protocol buffer message.\n  \"\"\"\n  printer = _Printer(\n      including_default_value_fields,\n      preserving_proto_field_name,\n      use_integers_for_enums,\n      descriptor_pool,\n      float_precision=float_precision)\n  return printer.ToJsonString(message, indent, sort_keys, ensure_ascii)\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/json_format.html#client.ayon_hiero.vendor.google.protobuf.json_format.Parse","title":"<code>Parse(text, message, ignore_unknown_fields=False, descriptor_pool=None, max_recursion_depth=100)</code>","text":"<p>Parses a JSON representation of a protocol message into a message.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <p>Message JSON representation.</p> required <code>message</code> <p>A protocol buffer message to merge into.</p> required <code>ignore_unknown_fields</code> <p>If True, do not raise errors for unknown fields.</p> <code>False</code> <code>descriptor_pool</code> <p>A Descriptor Pool for resolving types. If None use the default.</p> <code>None</code> <code>max_recursion_depth</code> <p>max recursion depth of JSON message to be deserialized. JSON messages over this depth will fail to be deserialized. Default value is 100.</p> <code>100</code> <p>Returns:</p> Type Description <p>The same message passed as argument.</p> <p>Raises::   ParseError: On JSON parsing problems.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/json_format.py</code> <pre><code>def Parse(text,\n          message,\n          ignore_unknown_fields=False,\n          descriptor_pool=None,\n          max_recursion_depth=100):\n  \"\"\"Parses a JSON representation of a protocol message into a message.\n\n  Args:\n    text: Message JSON representation.\n    message: A protocol buffer message to merge into.\n    ignore_unknown_fields: If True, do not raise errors for unknown fields.\n    descriptor_pool: A Descriptor Pool for resolving types. If None use the\n      default.\n    max_recursion_depth: max recursion depth of JSON message to be\n      deserialized. JSON messages over this depth will fail to be\n      deserialized. Default value is 100.\n\n  Returns:\n    The same message passed as argument.\n\n  Raises::\n    ParseError: On JSON parsing problems.\n  \"\"\"\n  if not isinstance(text, str):\n    text = text.decode('utf-8')\n  try:\n    js = json.loads(text, object_pairs_hook=_DuplicateChecker)\n  except ValueError as e:\n    raise ParseError('Failed to load JSON: {0}.'.format(str(e)))\n  return ParseDict(js, message, ignore_unknown_fields, descriptor_pool,\n                   max_recursion_depth)\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/json_format.html#client.ayon_hiero.vendor.google.protobuf.json_format.ParseDict","title":"<code>ParseDict(js_dict, message, ignore_unknown_fields=False, descriptor_pool=None, max_recursion_depth=100)</code>","text":"<p>Parses a JSON dictionary representation into a message.</p> <p>Parameters:</p> Name Type Description Default <code>js_dict</code> <p>Dict representation of a JSON message.</p> required <code>message</code> <p>A protocol buffer message to merge into.</p> required <code>ignore_unknown_fields</code> <p>If True, do not raise errors for unknown fields.</p> <code>False</code> <code>descriptor_pool</code> <p>A Descriptor Pool for resolving types. If None use the default.</p> <code>None</code> <code>max_recursion_depth</code> <p>max recursion depth of JSON message to be deserialized. JSON messages over this depth will fail to be deserialized. Default value is 100.</p> <code>100</code> <p>Returns:</p> Type Description <p>The same message passed as argument.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/json_format.py</code> <pre><code>def ParseDict(js_dict,\n              message,\n              ignore_unknown_fields=False,\n              descriptor_pool=None,\n              max_recursion_depth=100):\n  \"\"\"Parses a JSON dictionary representation into a message.\n\n  Args:\n    js_dict: Dict representation of a JSON message.\n    message: A protocol buffer message to merge into.\n    ignore_unknown_fields: If True, do not raise errors for unknown fields.\n    descriptor_pool: A Descriptor Pool for resolving types. If None use the\n      default.\n    max_recursion_depth: max recursion depth of JSON message to be\n      deserialized. JSON messages over this depth will fail to be\n      deserialized. Default value is 100.\n\n  Returns:\n    The same message passed as argument.\n  \"\"\"\n  parser = _Parser(ignore_unknown_fields, descriptor_pool, max_recursion_depth)\n  parser.ConvertMessage(js_dict, message, '')\n  return message\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/message.html","title":"message","text":"<p>Contains an abstract base class for protocol messages.</p>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/message.html#client.ayon_hiero.vendor.google.protobuf.message.DecodeError","title":"<code>DecodeError</code>","text":"<p>               Bases: <code>Error</code></p> <p>Exception raised when deserializing messages.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/message.py</code> <pre><code>class DecodeError(Error):\n  \"\"\"Exception raised when deserializing messages.\"\"\"\n  pass\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/message.html#client.ayon_hiero.vendor.google.protobuf.message.EncodeError","title":"<code>EncodeError</code>","text":"<p>               Bases: <code>Error</code></p> <p>Exception raised when serializing messages.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/message.py</code> <pre><code>class EncodeError(Error):\n  \"\"\"Exception raised when serializing messages.\"\"\"\n  pass\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/message.html#client.ayon_hiero.vendor.google.protobuf.message.Error","title":"<code>Error</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Base error type for this module.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/message.py</code> <pre><code>class Error(Exception):\n  \"\"\"Base error type for this module.\"\"\"\n  pass\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/message.html#client.ayon_hiero.vendor.google.protobuf.message.Message","title":"<code>Message</code>","text":"<p>               Bases: <code>object</code></p> <p>Abstract base class for protocol messages.</p> <p>Protocol message classes are almost always generated by the protocol compiler.  These generated types subclass Message and implement the methods shown below.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/message.py</code> <pre><code>class Message(object):\n\n  \"\"\"Abstract base class for protocol messages.\n\n  Protocol message classes are almost always generated by the protocol\n  compiler.  These generated types subclass Message and implement the methods\n  shown below.\n  \"\"\"\n\n  # TODO(robinson): Link to an HTML document here.\n\n  # TODO(robinson): Document that instances of this class will also\n  # have an Extensions attribute with __getitem__ and __setitem__.\n  # Again, not sure how to best convey this.\n\n  # TODO(robinson): Document that the class must also have a static\n  #   RegisterExtension(extension_field) method.\n  #   Not sure how to best express at this point.\n\n  # TODO(robinson): Document these fields and methods.\n\n  __slots__ = []\n\n  #: The :class:`google.protobuf.descriptor.Descriptor` for this message type.\n  DESCRIPTOR = None\n\n  def __deepcopy__(self, memo=None):\n    clone = type(self)()\n    clone.MergeFrom(self)\n    return clone\n\n  def __eq__(self, other_msg):\n    \"\"\"Recursively compares two messages by value and structure.\"\"\"\n    raise NotImplementedError\n\n  def __ne__(self, other_msg):\n    # Can't just say self != other_msg, since that would infinitely recurse. :)\n    return not self == other_msg\n\n  def __hash__(self):\n    raise TypeError('unhashable object')\n\n  def __str__(self):\n    \"\"\"Outputs a human-readable representation of the message.\"\"\"\n    raise NotImplementedError\n\n  def __unicode__(self):\n    \"\"\"Outputs a human-readable representation of the message.\"\"\"\n    raise NotImplementedError\n\n  def MergeFrom(self, other_msg):\n    \"\"\"Merges the contents of the specified message into current message.\n\n    This method merges the contents of the specified message into the current\n    message. Singular fields that are set in the specified message overwrite\n    the corresponding fields in the current message. Repeated fields are\n    appended. Singular sub-messages and groups are recursively merged.\n\n    Args:\n      other_msg (Message): A message to merge into the current message.\n    \"\"\"\n    raise NotImplementedError\n\n  def CopyFrom(self, other_msg):\n    \"\"\"Copies the content of the specified message into the current message.\n\n    The method clears the current message and then merges the specified\n    message using MergeFrom.\n\n    Args:\n      other_msg (Message): A message to copy into the current one.\n    \"\"\"\n    if self is other_msg:\n      return\n    self.Clear()\n    self.MergeFrom(other_msg)\n\n  def Clear(self):\n    \"\"\"Clears all data that was set in the message.\"\"\"\n    raise NotImplementedError\n\n  def SetInParent(self):\n    \"\"\"Mark this as present in the parent.\n\n    This normally happens automatically when you assign a field of a\n    sub-message, but sometimes you want to make the sub-message\n    present while keeping it empty.  If you find yourself using this,\n    you may want to reconsider your design.\n    \"\"\"\n    raise NotImplementedError\n\n  def IsInitialized(self):\n    \"\"\"Checks if the message is initialized.\n\n    Returns:\n      bool: The method returns True if the message is initialized (i.e. all of\n      its required fields are set).\n    \"\"\"\n    raise NotImplementedError\n\n  # TODO(robinson): MergeFromString() should probably return None and be\n  # implemented in terms of a helper that returns the # of bytes read.  Our\n  # deserialization routines would use the helper when recursively\n  # deserializing, but the end user would almost always just want the no-return\n  # MergeFromString().\n\n  def MergeFromString(self, serialized):\n    \"\"\"Merges serialized protocol buffer data into this message.\n\n    When we find a field in `serialized` that is already present\n    in this message:\n\n    -   If it's a \"repeated\" field, we append to the end of our list.\n    -   Else, if it's a scalar, we overwrite our field.\n    -   Else, (it's a nonrepeated composite), we recursively merge\n        into the existing composite.\n\n    Args:\n      serialized (bytes): Any object that allows us to call\n        ``memoryview(serialized)`` to access a string of bytes using the\n        buffer interface.\n\n    Returns:\n      int: The number of bytes read from `serialized`.\n      For non-group messages, this will always be `len(serialized)`,\n      but for messages which are actually groups, this will\n      generally be less than `len(serialized)`, since we must\n      stop when we reach an ``END_GROUP`` tag.  Note that if\n      we *do* stop because of an ``END_GROUP`` tag, the number\n      of bytes returned does not include the bytes\n      for the ``END_GROUP`` tag information.\n\n    Raises:\n      DecodeError: if the input cannot be parsed.\n    \"\"\"\n    # TODO(robinson): Document handling of unknown fields.\n    # TODO(robinson): When we switch to a helper, this will return None.\n    raise NotImplementedError\n\n  def ParseFromString(self, serialized):\n    \"\"\"Parse serialized protocol buffer data into this message.\n\n    Like :func:`MergeFromString()`, except we clear the object first.\n\n    Raises:\n      message.DecodeError if the input cannot be parsed.\n    \"\"\"\n    self.Clear()\n    return self.MergeFromString(serialized)\n\n  def SerializeToString(self, **kwargs):\n    \"\"\"Serializes the protocol message to a binary string.\n\n    Keyword Args:\n      deterministic (bool): If true, requests deterministic serialization\n        of the protobuf, with predictable ordering of map keys.\n\n    Returns:\n      A binary string representation of the message if all of the required\n      fields in the message are set (i.e. the message is initialized).\n\n    Raises:\n      EncodeError: if the message isn't initialized (see :func:`IsInitialized`).\n    \"\"\"\n    raise NotImplementedError\n\n  def SerializePartialToString(self, **kwargs):\n    \"\"\"Serializes the protocol message to a binary string.\n\n    This method is similar to SerializeToString but doesn't check if the\n    message is initialized.\n\n    Keyword Args:\n      deterministic (bool): If true, requests deterministic serialization\n        of the protobuf, with predictable ordering of map keys.\n\n    Returns:\n      bytes: A serialized representation of the partial message.\n    \"\"\"\n    raise NotImplementedError\n\n  # TODO(robinson): Decide whether we like these better\n  # than auto-generated has_foo() and clear_foo() methods\n  # on the instances themselves.  This way is less consistent\n  # with C++, but it makes reflection-type access easier and\n  # reduces the number of magically autogenerated things.\n  #\n  # TODO(robinson): Be sure to document (and test) exactly\n  # which field names are accepted here.  Are we case-sensitive?\n  # What do we do with fields that share names with Python keywords\n  # like 'lambda' and 'yield'?\n  #\n  # nnorwitz says:\n  # \"\"\"\n  # Typically (in python), an underscore is appended to names that are\n  # keywords. So they would become lambda_ or yield_.\n  # \"\"\"\n  def ListFields(self):\n    \"\"\"Returns a list of (FieldDescriptor, value) tuples for present fields.\n\n    A message field is non-empty if HasField() would return true. A singular\n    primitive field is non-empty if HasField() would return true in proto2 or it\n    is non zero in proto3. A repeated field is non-empty if it contains at least\n    one element. The fields are ordered by field number.\n\n    Returns:\n      list[tuple(FieldDescriptor, value)]: field descriptors and values\n      for all fields in the message which are not empty. The values vary by\n      field type.\n    \"\"\"\n    raise NotImplementedError\n\n  def HasField(self, field_name):\n    \"\"\"Checks if a certain field is set for the message.\n\n    For a oneof group, checks if any field inside is set. Note that if the\n    field_name is not defined in the message descriptor, :exc:`ValueError` will\n    be raised.\n\n    Args:\n      field_name (str): The name of the field to check for presence.\n\n    Returns:\n      bool: Whether a value has been set for the named field.\n\n    Raises:\n      ValueError: if the `field_name` is not a member of this message.\n    \"\"\"\n    raise NotImplementedError\n\n  def ClearField(self, field_name):\n    \"\"\"Clears the contents of a given field.\n\n    Inside a oneof group, clears the field set. If the name neither refers to a\n    defined field or oneof group, :exc:`ValueError` is raised.\n\n    Args:\n      field_name (str): The name of the field to check for presence.\n\n    Raises:\n      ValueError: if the `field_name` is not a member of this message.\n    \"\"\"\n    raise NotImplementedError\n\n  def WhichOneof(self, oneof_group):\n    \"\"\"Returns the name of the field that is set inside a oneof group.\n\n    If no field is set, returns None.\n\n    Args:\n      oneof_group (str): the name of the oneof group to check.\n\n    Returns:\n      str or None: The name of the group that is set, or None.\n\n    Raises:\n      ValueError: no group with the given name exists\n    \"\"\"\n    raise NotImplementedError\n\n  def HasExtension(self, extension_handle):\n    \"\"\"Checks if a certain extension is present for this message.\n\n    Extensions are retrieved using the :attr:`Extensions` mapping (if present).\n\n    Args:\n      extension_handle: The handle for the extension to check.\n\n    Returns:\n      bool: Whether the extension is present for this message.\n\n    Raises:\n      KeyError: if the extension is repeated. Similar to repeated fields,\n        there is no separate notion of presence: a \"not present\" repeated\n        extension is an empty list.\n    \"\"\"\n    raise NotImplementedError\n\n  def ClearExtension(self, extension_handle):\n    \"\"\"Clears the contents of a given extension.\n\n    Args:\n      extension_handle: The handle for the extension to clear.\n    \"\"\"\n    raise NotImplementedError\n\n  def UnknownFields(self):\n    \"\"\"Returns the UnknownFieldSet.\n\n    Returns:\n      UnknownFieldSet: The unknown fields stored in this message.\n    \"\"\"\n    raise NotImplementedError\n\n  def DiscardUnknownFields(self):\n    \"\"\"Clears all fields in the :class:`UnknownFieldSet`.\n\n    This operation is recursive for nested message.\n    \"\"\"\n    raise NotImplementedError\n\n  def ByteSize(self):\n    \"\"\"Returns the serialized size of this message.\n\n    Recursively calls ByteSize() on all contained messages.\n\n    Returns:\n      int: The number of bytes required to serialize this message.\n    \"\"\"\n    raise NotImplementedError\n\n  @classmethod\n  def FromString(cls, s):\n    raise NotImplementedError\n\n  @staticmethod\n  def RegisterExtension(extension_handle):\n    raise NotImplementedError\n\n  def _SetListener(self, message_listener):\n    \"\"\"Internal method used by the protocol message implementation.\n    Clients should not call this directly.\n\n    Sets a listener that this message will call on certain state transitions.\n\n    The purpose of this method is to register back-edges from children to\n    parents at runtime, for the purpose of setting \"has\" bits and\n    byte-size-dirty bits in the parent and ancestor objects whenever a child or\n    descendant object is modified.\n\n    If the client wants to disconnect this Message from the object tree, she\n    explicitly sets callback to None.\n\n    If message_listener is None, unregisters any existing listener.  Otherwise,\n    message_listener must implement the MessageListener interface in\n    internal/message_listener.py, and we discard any listener registered\n    via a previous _SetListener() call.\n    \"\"\"\n    raise NotImplementedError\n\n  def __getstate__(self):\n    \"\"\"Support the pickle protocol.\"\"\"\n    return dict(serialized=self.SerializePartialToString())\n\n  def __setstate__(self, state):\n    \"\"\"Support the pickle protocol.\"\"\"\n    self.__init__()\n    serialized = state['serialized']\n    # On Python 3, using encoding='latin1' is required for unpickling\n    # protos pickled by Python 2.\n    if not isinstance(serialized, bytes):\n      serialized = serialized.encode('latin1')\n    self.ParseFromString(serialized)\n\n  def __reduce__(self):\n    message_descriptor = self.DESCRIPTOR\n    if message_descriptor.containing_type is None:\n      return type(self), (), self.__getstate__()\n    # the message type must be nested.\n    # Python does not pickle nested classes; use the symbol_database on the\n    # receiving end.\n    container = message_descriptor\n    return (_InternalConstructMessage, (container.full_name,),\n            self.__getstate__())\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/message.html#client.ayon_hiero.vendor.google.protobuf.message.Message.ByteSize","title":"<code>ByteSize()</code>","text":"<p>Returns the serialized size of this message.</p> <p>Recursively calls ByteSize() on all contained messages.</p> <p>Returns:</p> Name Type Description <code>int</code> <p>The number of bytes required to serialize this message.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/message.py</code> <pre><code>def ByteSize(self):\n  \"\"\"Returns the serialized size of this message.\n\n  Recursively calls ByteSize() on all contained messages.\n\n  Returns:\n    int: The number of bytes required to serialize this message.\n  \"\"\"\n  raise NotImplementedError\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/message.html#client.ayon_hiero.vendor.google.protobuf.message.Message.Clear","title":"<code>Clear()</code>","text":"<p>Clears all data that was set in the message.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/message.py</code> <pre><code>def Clear(self):\n  \"\"\"Clears all data that was set in the message.\"\"\"\n  raise NotImplementedError\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/message.html#client.ayon_hiero.vendor.google.protobuf.message.Message.ClearExtension","title":"<code>ClearExtension(extension_handle)</code>","text":"<p>Clears the contents of a given extension.</p> <p>Parameters:</p> Name Type Description Default <code>extension_handle</code> <p>The handle for the extension to clear.</p> required Source code in <code>client/ayon_hiero/vendor/google/protobuf/message.py</code> <pre><code>def ClearExtension(self, extension_handle):\n  \"\"\"Clears the contents of a given extension.\n\n  Args:\n    extension_handle: The handle for the extension to clear.\n  \"\"\"\n  raise NotImplementedError\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/message.html#client.ayon_hiero.vendor.google.protobuf.message.Message.ClearField","title":"<code>ClearField(field_name)</code>","text":"<p>Clears the contents of a given field.</p> <p>Inside a oneof group, clears the field set. If the name neither refers to a defined field or oneof group, :exc:<code>ValueError</code> is raised.</p> <p>Parameters:</p> Name Type Description Default <code>field_name</code> <code>str</code> <p>The name of the field to check for presence.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>if the <code>field_name</code> is not a member of this message.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/message.py</code> <pre><code>def ClearField(self, field_name):\n  \"\"\"Clears the contents of a given field.\n\n  Inside a oneof group, clears the field set. If the name neither refers to a\n  defined field or oneof group, :exc:`ValueError` is raised.\n\n  Args:\n    field_name (str): The name of the field to check for presence.\n\n  Raises:\n    ValueError: if the `field_name` is not a member of this message.\n  \"\"\"\n  raise NotImplementedError\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/message.html#client.ayon_hiero.vendor.google.protobuf.message.Message.CopyFrom","title":"<code>CopyFrom(other_msg)</code>","text":"<p>Copies the content of the specified message into the current message.</p> <p>The method clears the current message and then merges the specified message using MergeFrom.</p> <p>Parameters:</p> Name Type Description Default <code>other_msg</code> <code>Message</code> <p>A message to copy into the current one.</p> required Source code in <code>client/ayon_hiero/vendor/google/protobuf/message.py</code> <pre><code>def CopyFrom(self, other_msg):\n  \"\"\"Copies the content of the specified message into the current message.\n\n  The method clears the current message and then merges the specified\n  message using MergeFrom.\n\n  Args:\n    other_msg (Message): A message to copy into the current one.\n  \"\"\"\n  if self is other_msg:\n    return\n  self.Clear()\n  self.MergeFrom(other_msg)\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/message.html#client.ayon_hiero.vendor.google.protobuf.message.Message.DiscardUnknownFields","title":"<code>DiscardUnknownFields()</code>","text":"<p>Clears all fields in the :class:<code>UnknownFieldSet</code>.</p> <p>This operation is recursive for nested message.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/message.py</code> <pre><code>def DiscardUnknownFields(self):\n  \"\"\"Clears all fields in the :class:`UnknownFieldSet`.\n\n  This operation is recursive for nested message.\n  \"\"\"\n  raise NotImplementedError\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/message.html#client.ayon_hiero.vendor.google.protobuf.message.Message.HasExtension","title":"<code>HasExtension(extension_handle)</code>","text":"<p>Checks if a certain extension is present for this message.</p> <p>Extensions are retrieved using the :attr:<code>Extensions</code> mapping (if present).</p> <p>Parameters:</p> Name Type Description Default <code>extension_handle</code> <p>The handle for the extension to check.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <p>Whether the extension is present for this message.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>if the extension is repeated. Similar to repeated fields, there is no separate notion of presence: a \"not present\" repeated extension is an empty list.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/message.py</code> <pre><code>def HasExtension(self, extension_handle):\n  \"\"\"Checks if a certain extension is present for this message.\n\n  Extensions are retrieved using the :attr:`Extensions` mapping (if present).\n\n  Args:\n    extension_handle: The handle for the extension to check.\n\n  Returns:\n    bool: Whether the extension is present for this message.\n\n  Raises:\n    KeyError: if the extension is repeated. Similar to repeated fields,\n      there is no separate notion of presence: a \"not present\" repeated\n      extension is an empty list.\n  \"\"\"\n  raise NotImplementedError\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/message.html#client.ayon_hiero.vendor.google.protobuf.message.Message.HasField","title":"<code>HasField(field_name)</code>","text":"<p>Checks if a certain field is set for the message.</p> <p>For a oneof group, checks if any field inside is set. Note that if the field_name is not defined in the message descriptor, :exc:<code>ValueError</code> will be raised.</p> <p>Parameters:</p> Name Type Description Default <code>field_name</code> <code>str</code> <p>The name of the field to check for presence.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <p>Whether a value has been set for the named field.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>if the <code>field_name</code> is not a member of this message.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/message.py</code> <pre><code>def HasField(self, field_name):\n  \"\"\"Checks if a certain field is set for the message.\n\n  For a oneof group, checks if any field inside is set. Note that if the\n  field_name is not defined in the message descriptor, :exc:`ValueError` will\n  be raised.\n\n  Args:\n    field_name (str): The name of the field to check for presence.\n\n  Returns:\n    bool: Whether a value has been set for the named field.\n\n  Raises:\n    ValueError: if the `field_name` is not a member of this message.\n  \"\"\"\n  raise NotImplementedError\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/message.html#client.ayon_hiero.vendor.google.protobuf.message.Message.IsInitialized","title":"<code>IsInitialized()</code>","text":"<p>Checks if the message is initialized.</p> <p>Returns:</p> Name Type Description <code>bool</code> <p>The method returns True if the message is initialized (i.e. all of</p> <p>its required fields are set).</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/message.py</code> <pre><code>def IsInitialized(self):\n  \"\"\"Checks if the message is initialized.\n\n  Returns:\n    bool: The method returns True if the message is initialized (i.e. all of\n    its required fields are set).\n  \"\"\"\n  raise NotImplementedError\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/message.html#client.ayon_hiero.vendor.google.protobuf.message.Message.ListFields","title":"<code>ListFields()</code>","text":"<p>Returns a list of (FieldDescriptor, value) tuples for present fields.</p> <p>A message field is non-empty if HasField() would return true. A singular primitive field is non-empty if HasField() would return true in proto2 or it is non zero in proto3. A repeated field is non-empty if it contains at least one element. The fields are ordered by field number.</p> <p>Returns:</p> Type Description <p>list[tuple(FieldDescriptor, value)]: field descriptors and values</p> <p>for all fields in the message which are not empty. The values vary by</p> <p>field type.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/message.py</code> <pre><code>def ListFields(self):\n  \"\"\"Returns a list of (FieldDescriptor, value) tuples for present fields.\n\n  A message field is non-empty if HasField() would return true. A singular\n  primitive field is non-empty if HasField() would return true in proto2 or it\n  is non zero in proto3. A repeated field is non-empty if it contains at least\n  one element. The fields are ordered by field number.\n\n  Returns:\n    list[tuple(FieldDescriptor, value)]: field descriptors and values\n    for all fields in the message which are not empty. The values vary by\n    field type.\n  \"\"\"\n  raise NotImplementedError\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/message.html#client.ayon_hiero.vendor.google.protobuf.message.Message.MergeFrom","title":"<code>MergeFrom(other_msg)</code>","text":"<p>Merges the contents of the specified message into current message.</p> <p>This method merges the contents of the specified message into the current message. Singular fields that are set in the specified message overwrite the corresponding fields in the current message. Repeated fields are appended. Singular sub-messages and groups are recursively merged.</p> <p>Parameters:</p> Name Type Description Default <code>other_msg</code> <code>Message</code> <p>A message to merge into the current message.</p> required Source code in <code>client/ayon_hiero/vendor/google/protobuf/message.py</code> <pre><code>def MergeFrom(self, other_msg):\n  \"\"\"Merges the contents of the specified message into current message.\n\n  This method merges the contents of the specified message into the current\n  message. Singular fields that are set in the specified message overwrite\n  the corresponding fields in the current message. Repeated fields are\n  appended. Singular sub-messages and groups are recursively merged.\n\n  Args:\n    other_msg (Message): A message to merge into the current message.\n  \"\"\"\n  raise NotImplementedError\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/message.html#client.ayon_hiero.vendor.google.protobuf.message.Message.MergeFromString","title":"<code>MergeFromString(serialized)</code>","text":"<p>Merges serialized protocol buffer data into this message.</p> <p>When we find a field in <code>serialized</code> that is already present in this message:</p> <ul> <li>If it's a \"repeated\" field, we append to the end of our list.</li> <li>Else, if it's a scalar, we overwrite our field.</li> <li>Else, (it's a nonrepeated composite), we recursively merge     into the existing composite.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>serialized</code> <code>bytes</code> <p>Any object that allows us to call <code>memoryview(serialized)</code> to access a string of bytes using the buffer interface.</p> required <p>Returns:</p> Name Type Description <code>int</code> <p>The number of bytes read from <code>serialized</code>.</p> <p>For non-group messages, this will always be <code>len(serialized)</code>,</p> <p>but for messages which are actually groups, this will</p> <p>generally be less than <code>len(serialized)</code>, since we must</p> <p>stop when we reach an <code>END_GROUP</code> tag.  Note that if</p> <p>we do stop because of an <code>END_GROUP</code> tag, the number</p> <p>of bytes returned does not include the bytes</p> <p>for the <code>END_GROUP</code> tag information.</p> <p>Raises:</p> Type Description <code>DecodeError</code> <p>if the input cannot be parsed.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/message.py</code> <pre><code>def MergeFromString(self, serialized):\n  \"\"\"Merges serialized protocol buffer data into this message.\n\n  When we find a field in `serialized` that is already present\n  in this message:\n\n  -   If it's a \"repeated\" field, we append to the end of our list.\n  -   Else, if it's a scalar, we overwrite our field.\n  -   Else, (it's a nonrepeated composite), we recursively merge\n      into the existing composite.\n\n  Args:\n    serialized (bytes): Any object that allows us to call\n      ``memoryview(serialized)`` to access a string of bytes using the\n      buffer interface.\n\n  Returns:\n    int: The number of bytes read from `serialized`.\n    For non-group messages, this will always be `len(serialized)`,\n    but for messages which are actually groups, this will\n    generally be less than `len(serialized)`, since we must\n    stop when we reach an ``END_GROUP`` tag.  Note that if\n    we *do* stop because of an ``END_GROUP`` tag, the number\n    of bytes returned does not include the bytes\n    for the ``END_GROUP`` tag information.\n\n  Raises:\n    DecodeError: if the input cannot be parsed.\n  \"\"\"\n  # TODO(robinson): Document handling of unknown fields.\n  # TODO(robinson): When we switch to a helper, this will return None.\n  raise NotImplementedError\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/message.html#client.ayon_hiero.vendor.google.protobuf.message.Message.ParseFromString","title":"<code>ParseFromString(serialized)</code>","text":"<p>Parse serialized protocol buffer data into this message.</p> <p>Like :func:<code>MergeFromString()</code>, except we clear the object first.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/message.py</code> <pre><code>def ParseFromString(self, serialized):\n  \"\"\"Parse serialized protocol buffer data into this message.\n\n  Like :func:`MergeFromString()`, except we clear the object first.\n\n  Raises:\n    message.DecodeError if the input cannot be parsed.\n  \"\"\"\n  self.Clear()\n  return self.MergeFromString(serialized)\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/message.html#client.ayon_hiero.vendor.google.protobuf.message.Message.SerializePartialToString","title":"<code>SerializePartialToString(**kwargs)</code>","text":"<p>Serializes the protocol message to a binary string.</p> <p>This method is similar to SerializeToString but doesn't check if the message is initialized.</p> <p>Other Parameters:</p> Name Type Description <code>deterministic</code> <code>bool</code> <p>If true, requests deterministic serialization of the protobuf, with predictable ordering of map keys.</p> <p>Returns:</p> Name Type Description <code>bytes</code> <p>A serialized representation of the partial message.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/message.py</code> <pre><code>def SerializePartialToString(self, **kwargs):\n  \"\"\"Serializes the protocol message to a binary string.\n\n  This method is similar to SerializeToString but doesn't check if the\n  message is initialized.\n\n  Keyword Args:\n    deterministic (bool): If true, requests deterministic serialization\n      of the protobuf, with predictable ordering of map keys.\n\n  Returns:\n    bytes: A serialized representation of the partial message.\n  \"\"\"\n  raise NotImplementedError\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/message.html#client.ayon_hiero.vendor.google.protobuf.message.Message.SerializeToString","title":"<code>SerializeToString(**kwargs)</code>","text":"<p>Serializes the protocol message to a binary string.</p> <p>Other Parameters:</p> Name Type Description <code>deterministic</code> <code>bool</code> <p>If true, requests deterministic serialization of the protobuf, with predictable ordering of map keys.</p> <p>Returns:</p> Type Description <p>A binary string representation of the message if all of the required</p> <p>fields in the message are set (i.e. the message is initialized).</p> <p>Raises:</p> Type Description <code>EncodeError</code> <p>if the message isn't initialized (see :func:<code>IsInitialized</code>).</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/message.py</code> <pre><code>def SerializeToString(self, **kwargs):\n  \"\"\"Serializes the protocol message to a binary string.\n\n  Keyword Args:\n    deterministic (bool): If true, requests deterministic serialization\n      of the protobuf, with predictable ordering of map keys.\n\n  Returns:\n    A binary string representation of the message if all of the required\n    fields in the message are set (i.e. the message is initialized).\n\n  Raises:\n    EncodeError: if the message isn't initialized (see :func:`IsInitialized`).\n  \"\"\"\n  raise NotImplementedError\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/message.html#client.ayon_hiero.vendor.google.protobuf.message.Message.SetInParent","title":"<code>SetInParent()</code>","text":"<p>Mark this as present in the parent.</p> <p>This normally happens automatically when you assign a field of a sub-message, but sometimes you want to make the sub-message present while keeping it empty.  If you find yourself using this, you may want to reconsider your design.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/message.py</code> <pre><code>def SetInParent(self):\n  \"\"\"Mark this as present in the parent.\n\n  This normally happens automatically when you assign a field of a\n  sub-message, but sometimes you want to make the sub-message\n  present while keeping it empty.  If you find yourself using this,\n  you may want to reconsider your design.\n  \"\"\"\n  raise NotImplementedError\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/message.html#client.ayon_hiero.vendor.google.protobuf.message.Message.UnknownFields","title":"<code>UnknownFields()</code>","text":"<p>Returns the UnknownFieldSet.</p> <p>Returns:</p> Name Type Description <code>UnknownFieldSet</code> <p>The unknown fields stored in this message.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/message.py</code> <pre><code>def UnknownFields(self):\n  \"\"\"Returns the UnknownFieldSet.\n\n  Returns:\n    UnknownFieldSet: The unknown fields stored in this message.\n  \"\"\"\n  raise NotImplementedError\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/message.html#client.ayon_hiero.vendor.google.protobuf.message.Message.WhichOneof","title":"<code>WhichOneof(oneof_group)</code>","text":"<p>Returns the name of the field that is set inside a oneof group.</p> <p>If no field is set, returns None.</p> <p>Parameters:</p> Name Type Description Default <code>oneof_group</code> <code>str</code> <p>the name of the oneof group to check.</p> required <p>Returns:</p> Type Description <p>str or None: The name of the group that is set, or None.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>no group with the given name exists</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/message.py</code> <pre><code>def WhichOneof(self, oneof_group):\n  \"\"\"Returns the name of the field that is set inside a oneof group.\n\n  If no field is set, returns None.\n\n  Args:\n    oneof_group (str): the name of the oneof group to check.\n\n  Returns:\n    str or None: The name of the group that is set, or None.\n\n  Raises:\n    ValueError: no group with the given name exists\n  \"\"\"\n  raise NotImplementedError\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/message.html#client.ayon_hiero.vendor.google.protobuf.message.Message.__eq__","title":"<code>__eq__(other_msg)</code>","text":"<p>Recursively compares two messages by value and structure.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/message.py</code> <pre><code>def __eq__(self, other_msg):\n  \"\"\"Recursively compares two messages by value and structure.\"\"\"\n  raise NotImplementedError\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/message.html#client.ayon_hiero.vendor.google.protobuf.message.Message.__getstate__","title":"<code>__getstate__()</code>","text":"<p>Support the pickle protocol.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/message.py</code> <pre><code>def __getstate__(self):\n  \"\"\"Support the pickle protocol.\"\"\"\n  return dict(serialized=self.SerializePartialToString())\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/message.html#client.ayon_hiero.vendor.google.protobuf.message.Message.__setstate__","title":"<code>__setstate__(state)</code>","text":"<p>Support the pickle protocol.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/message.py</code> <pre><code>def __setstate__(self, state):\n  \"\"\"Support the pickle protocol.\"\"\"\n  self.__init__()\n  serialized = state['serialized']\n  # On Python 3, using encoding='latin1' is required for unpickling\n  # protos pickled by Python 2.\n  if not isinstance(serialized, bytes):\n    serialized = serialized.encode('latin1')\n  self.ParseFromString(serialized)\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/message.html#client.ayon_hiero.vendor.google.protobuf.message.Message.__str__","title":"<code>__str__()</code>","text":"<p>Outputs a human-readable representation of the message.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/message.py</code> <pre><code>def __str__(self):\n  \"\"\"Outputs a human-readable representation of the message.\"\"\"\n  raise NotImplementedError\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/message.html#client.ayon_hiero.vendor.google.protobuf.message.Message.__unicode__","title":"<code>__unicode__()</code>","text":"<p>Outputs a human-readable representation of the message.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/message.py</code> <pre><code>def __unicode__(self):\n  \"\"\"Outputs a human-readable representation of the message.\"\"\"\n  raise NotImplementedError\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/message_factory.html","title":"message_factory","text":"<p>Provides a factory class for generating dynamic messages.</p> <p>The easiest way to use this class is if you have access to the FileDescriptor protos containing the messages you want to create you can just do the following:</p> <p>message_classes = message_factory.GetMessages(iterable_of_file_descriptors) my_proto_instance = message_classes'some.proto.package.MessageName'</p>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/message_factory.html#client.ayon_hiero.vendor.google.protobuf.message_factory.MessageFactory","title":"<code>MessageFactory</code>","text":"<p>               Bases: <code>object</code></p> <p>Factory for creating Proto2 messages from descriptors in a pool.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/message_factory.py</code> <pre><code>class MessageFactory(object):\n  \"\"\"Factory for creating Proto2 messages from descriptors in a pool.\"\"\"\n\n  def __init__(self, pool=None):\n    \"\"\"Initializes a new factory.\"\"\"\n    self.pool = pool or descriptor_pool.DescriptorPool()\n\n    # local cache of all classes built from protobuf descriptors\n    self._classes = {}\n\n  def GetPrototype(self, descriptor):\n    \"\"\"Obtains a proto2 message class based on the passed in descriptor.\n\n    Passing a descriptor with a fully qualified name matching a previous\n    invocation will cause the same class to be returned.\n\n    Args:\n      descriptor: The descriptor to build from.\n\n    Returns:\n      A class describing the passed in descriptor.\n    \"\"\"\n    if descriptor not in self._classes:\n      result_class = self.CreatePrototype(descriptor)\n      # The assignment to _classes is redundant for the base implementation, but\n      # might avoid confusion in cases where CreatePrototype gets overridden and\n      # does not call the base implementation.\n      self._classes[descriptor] = result_class\n      return result_class\n    return self._classes[descriptor]\n\n  def CreatePrototype(self, descriptor):\n    \"\"\"Builds a proto2 message class based on the passed in descriptor.\n\n    Don't call this function directly, it always creates a new class. Call\n    GetPrototype() instead. This method is meant to be overridden in subblasses\n    to perform additional operations on the newly constructed class.\n\n    Args:\n      descriptor: The descriptor to build from.\n\n    Returns:\n      A class describing the passed in descriptor.\n    \"\"\"\n    descriptor_name = descriptor.name\n    result_class = _GENERATED_PROTOCOL_MESSAGE_TYPE(\n        descriptor_name,\n        (message.Message,),\n        {\n            'DESCRIPTOR': descriptor,\n            # If module not set, it wrongly points to message_factory module.\n            '__module__': None,\n        })\n    result_class._FACTORY = self  # pylint: disable=protected-access\n    # Assign in _classes before doing recursive calls to avoid infinite\n    # recursion.\n    self._classes[descriptor] = result_class\n    for field in descriptor.fields:\n      if field.message_type:\n        self.GetPrototype(field.message_type)\n    for extension in result_class.DESCRIPTOR.extensions:\n      if extension.containing_type not in self._classes:\n        self.GetPrototype(extension.containing_type)\n      extended_class = self._classes[extension.containing_type]\n      extended_class.RegisterExtension(extension)\n    return result_class\n\n  def GetMessages(self, files):\n    \"\"\"Gets all the messages from a specified file.\n\n    This will find and resolve dependencies, failing if the descriptor\n    pool cannot satisfy them.\n\n    Args:\n      files: The file names to extract messages from.\n\n    Returns:\n      A dictionary mapping proto names to the message classes. This will include\n      any dependent messages as well as any messages defined in the same file as\n      a specified message.\n    \"\"\"\n    result = {}\n    for file_name in files:\n      file_desc = self.pool.FindFileByName(file_name)\n      for desc in file_desc.message_types_by_name.values():\n        result[desc.full_name] = self.GetPrototype(desc)\n\n      # While the extension FieldDescriptors are created by the descriptor pool,\n      # the python classes created in the factory need them to be registered\n      # explicitly, which is done below.\n      #\n      # The call to RegisterExtension will specifically check if the\n      # extension was already registered on the object and either\n      # ignore the registration if the original was the same, or raise\n      # an error if they were different.\n\n      for extension in file_desc.extensions_by_name.values():\n        if extension.containing_type not in self._classes:\n          self.GetPrototype(extension.containing_type)\n        extended_class = self._classes[extension.containing_type]\n        extended_class.RegisterExtension(extension)\n    return result\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/message_factory.html#client.ayon_hiero.vendor.google.protobuf.message_factory.MessageFactory.CreatePrototype","title":"<code>CreatePrototype(descriptor)</code>","text":"<p>Builds a proto2 message class based on the passed in descriptor.</p> <p>Don't call this function directly, it always creates a new class. Call GetPrototype() instead. This method is meant to be overridden in subblasses to perform additional operations on the newly constructed class.</p> <p>Parameters:</p> Name Type Description Default <code>descriptor</code> <p>The descriptor to build from.</p> required <p>Returns:</p> Type Description <p>A class describing the passed in descriptor.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/message_factory.py</code> <pre><code>def CreatePrototype(self, descriptor):\n  \"\"\"Builds a proto2 message class based on the passed in descriptor.\n\n  Don't call this function directly, it always creates a new class. Call\n  GetPrototype() instead. This method is meant to be overridden in subblasses\n  to perform additional operations on the newly constructed class.\n\n  Args:\n    descriptor: The descriptor to build from.\n\n  Returns:\n    A class describing the passed in descriptor.\n  \"\"\"\n  descriptor_name = descriptor.name\n  result_class = _GENERATED_PROTOCOL_MESSAGE_TYPE(\n      descriptor_name,\n      (message.Message,),\n      {\n          'DESCRIPTOR': descriptor,\n          # If module not set, it wrongly points to message_factory module.\n          '__module__': None,\n      })\n  result_class._FACTORY = self  # pylint: disable=protected-access\n  # Assign in _classes before doing recursive calls to avoid infinite\n  # recursion.\n  self._classes[descriptor] = result_class\n  for field in descriptor.fields:\n    if field.message_type:\n      self.GetPrototype(field.message_type)\n  for extension in result_class.DESCRIPTOR.extensions:\n    if extension.containing_type not in self._classes:\n      self.GetPrototype(extension.containing_type)\n    extended_class = self._classes[extension.containing_type]\n    extended_class.RegisterExtension(extension)\n  return result_class\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/message_factory.html#client.ayon_hiero.vendor.google.protobuf.message_factory.MessageFactory.GetMessages","title":"<code>GetMessages(files)</code>","text":"<p>Gets all the messages from a specified file.</p> <p>This will find and resolve dependencies, failing if the descriptor pool cannot satisfy them.</p> <p>Parameters:</p> Name Type Description Default <code>files</code> <p>The file names to extract messages from.</p> required <p>Returns:</p> Type Description <p>A dictionary mapping proto names to the message classes. This will include</p> <p>any dependent messages as well as any messages defined in the same file as</p> <p>a specified message.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/message_factory.py</code> <pre><code>def GetMessages(self, files):\n  \"\"\"Gets all the messages from a specified file.\n\n  This will find and resolve dependencies, failing if the descriptor\n  pool cannot satisfy them.\n\n  Args:\n    files: The file names to extract messages from.\n\n  Returns:\n    A dictionary mapping proto names to the message classes. This will include\n    any dependent messages as well as any messages defined in the same file as\n    a specified message.\n  \"\"\"\n  result = {}\n  for file_name in files:\n    file_desc = self.pool.FindFileByName(file_name)\n    for desc in file_desc.message_types_by_name.values():\n      result[desc.full_name] = self.GetPrototype(desc)\n\n    # While the extension FieldDescriptors are created by the descriptor pool,\n    # the python classes created in the factory need them to be registered\n    # explicitly, which is done below.\n    #\n    # The call to RegisterExtension will specifically check if the\n    # extension was already registered on the object and either\n    # ignore the registration if the original was the same, or raise\n    # an error if they were different.\n\n    for extension in file_desc.extensions_by_name.values():\n      if extension.containing_type not in self._classes:\n        self.GetPrototype(extension.containing_type)\n      extended_class = self._classes[extension.containing_type]\n      extended_class.RegisterExtension(extension)\n  return result\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/message_factory.html#client.ayon_hiero.vendor.google.protobuf.message_factory.MessageFactory.GetPrototype","title":"<code>GetPrototype(descriptor)</code>","text":"<p>Obtains a proto2 message class based on the passed in descriptor.</p> <p>Passing a descriptor with a fully qualified name matching a previous invocation will cause the same class to be returned.</p> <p>Parameters:</p> Name Type Description Default <code>descriptor</code> <p>The descriptor to build from.</p> required <p>Returns:</p> Type Description <p>A class describing the passed in descriptor.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/message_factory.py</code> <pre><code>def GetPrototype(self, descriptor):\n  \"\"\"Obtains a proto2 message class based on the passed in descriptor.\n\n  Passing a descriptor with a fully qualified name matching a previous\n  invocation will cause the same class to be returned.\n\n  Args:\n    descriptor: The descriptor to build from.\n\n  Returns:\n    A class describing the passed in descriptor.\n  \"\"\"\n  if descriptor not in self._classes:\n    result_class = self.CreatePrototype(descriptor)\n    # The assignment to _classes is redundant for the base implementation, but\n    # might avoid confusion in cases where CreatePrototype gets overridden and\n    # does not call the base implementation.\n    self._classes[descriptor] = result_class\n    return result_class\n  return self._classes[descriptor]\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/message_factory.html#client.ayon_hiero.vendor.google.protobuf.message_factory.MessageFactory.__init__","title":"<code>__init__(pool=None)</code>","text":"<p>Initializes a new factory.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/message_factory.py</code> <pre><code>def __init__(self, pool=None):\n  \"\"\"Initializes a new factory.\"\"\"\n  self.pool = pool or descriptor_pool.DescriptorPool()\n\n  # local cache of all classes built from protobuf descriptors\n  self._classes = {}\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/message_factory.html#client.ayon_hiero.vendor.google.protobuf.message_factory.GetMessages","title":"<code>GetMessages(file_protos)</code>","text":"<p>Builds a dictionary of all the messages available in a set of files.</p> <p>Parameters:</p> Name Type Description Default <code>file_protos</code> <p>Iterable of FileDescriptorProto to build messages out of.</p> required <p>Returns:</p> Type Description <p>A dictionary mapping proto names to the message classes. This will include</p> <p>any dependent messages as well as any messages defined in the same file as</p> <p>a specified message.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/message_factory.py</code> <pre><code>def GetMessages(file_protos):\n  \"\"\"Builds a dictionary of all the messages available in a set of files.\n\n  Args:\n    file_protos: Iterable of FileDescriptorProto to build messages out of.\n\n  Returns:\n    A dictionary mapping proto names to the message classes. This will include\n    any dependent messages as well as any messages defined in the same file as\n    a specified message.\n  \"\"\"\n  # The cpp implementation of the protocol buffer library requires to add the\n  # message in topological order of the dependency graph.\n  file_by_name = {file_proto.name: file_proto for file_proto in file_protos}\n  def _AddFile(file_proto):\n    for dependency in file_proto.dependency:\n      if dependency in file_by_name:\n        # Remove from elements to be visited, in order to cut cycles.\n        _AddFile(file_by_name.pop(dependency))\n    _FACTORY.pool.Add(file_proto)\n  while file_by_name:\n    _AddFile(file_by_name.popitem()[1])\n  return _FACTORY.GetMessages([file_proto.name for file_proto in file_protos])\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/proto_builder.html","title":"proto_builder","text":"<p>Dynamic Protobuf class creator.</p>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/proto_builder.html#client.ayon_hiero.vendor.google.protobuf.proto_builder.MakeSimpleProtoClass","title":"<code>MakeSimpleProtoClass(fields, full_name=None, pool=None)</code>","text":"<p>Create a Protobuf class whose fields are basic types.</p> <p>Note: this doesn't validate field names!</p> <p>Parameters:</p> Name Type Description Default <code>fields</code> <p>dict of {name: field_type} mappings for each field in the proto. If   this is an OrderedDict the order will be maintained, otherwise the   fields will be sorted by name.</p> required <code>full_name</code> <p>optional str, the fully-qualified name of the proto type.</p> <code>None</code> <code>pool</code> <p>optional DescriptorPool instance.</p> <code>None</code> <p>Returns:   a class, the new protobuf class with a FileDescriptor.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/proto_builder.py</code> <pre><code>def MakeSimpleProtoClass(fields, full_name=None, pool=None):\n  \"\"\"Create a Protobuf class whose fields are basic types.\n\n  Note: this doesn't validate field names!\n\n  Args:\n    fields: dict of {name: field_type} mappings for each field in the proto. If\n        this is an OrderedDict the order will be maintained, otherwise the\n        fields will be sorted by name.\n    full_name: optional str, the fully-qualified name of the proto type.\n    pool: optional DescriptorPool instance.\n  Returns:\n    a class, the new protobuf class with a FileDescriptor.\n  \"\"\"\n  factory = message_factory.MessageFactory(pool=pool)\n\n  if full_name is not None:\n    try:\n      proto_cls = _GetMessageFromFactory(factory, full_name)\n      return proto_cls\n    except KeyError:\n      # The factory's DescriptorPool doesn't know about this class yet.\n      pass\n\n  # Get a list of (name, field_type) tuples from the fields dict. If fields was\n  # an OrderedDict we keep the order, but otherwise we sort the field to ensure\n  # consistent ordering.\n  field_items = fields.items()\n  if not isinstance(fields, OrderedDict):\n    field_items = sorted(field_items)\n\n  # Use a consistent file name that is unlikely to conflict with any imported\n  # proto files.\n  fields_hash = hashlib.sha1()\n  for f_name, f_type in field_items:\n    fields_hash.update(f_name.encode('utf-8'))\n    fields_hash.update(str(f_type).encode('utf-8'))\n  proto_file_name = fields_hash.hexdigest() + '.proto'\n\n  # If the proto is anonymous, use the same hash to name it.\n  if full_name is None:\n    full_name = ('net.proto2.python.public.proto_builder.AnonymousProto_' +\n                 fields_hash.hexdigest())\n    try:\n      proto_cls = _GetMessageFromFactory(factory, full_name)\n      return proto_cls\n    except KeyError:\n      # The factory's DescriptorPool doesn't know about this class yet.\n      pass\n\n  # This is the first time we see this proto: add a new descriptor to the pool.\n  factory.pool.Add(\n      _MakeFileDescriptorProto(proto_file_name, full_name, field_items))\n  return _GetMessageFromFactory(factory, full_name)\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/reflection.html","title":"reflection","text":"<p>Contains a metaclass and helper functions used to create protocol message classes from Descriptor objects at runtime.</p> <p>Recall that a metaclass is the \"type\" of a class. (A class is to a metaclass what an instance is to a class.)</p> <p>In this case, we use the GeneratedProtocolMessageType metaclass to inject all the useful functionality into the classes output by the protocol compiler at compile-time.</p> <p>The upshot of all this is that the real implementation details for ALL pure-Python protocol buffers are here in this file.</p>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/reflection.html#client.ayon_hiero.vendor.google.protobuf.reflection.MakeClass","title":"<code>MakeClass(descriptor)</code>","text":"<p>Construct a class object for a protobuf described by descriptor.</p> <p>DEPRECATED: use MessageFactory.GetPrototype() instead.</p> <p>Parameters:</p> Name Type Description Default <code>descriptor</code> <p>A descriptor.Descriptor object describing the protobuf.</p> required <p>Returns:   The Message class object described by the descriptor.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/reflection.py</code> <pre><code>def MakeClass(descriptor):\n  \"\"\"Construct a class object for a protobuf described by descriptor.\n\n  DEPRECATED: use MessageFactory.GetPrototype() instead.\n\n  Args:\n    descriptor: A descriptor.Descriptor object describing the protobuf.\n  Returns:\n    The Message class object described by the descriptor.\n  \"\"\"\n  # Original implementation leads to duplicate message classes, which won't play\n  # well with extensions. Message factory info is also missing.\n  # Redirect to message_factory.\n  return symbol_database.Default().GetPrototype(descriptor)\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/reflection.html#client.ayon_hiero.vendor.google.protobuf.reflection.ParseMessage","title":"<code>ParseMessage(descriptor, byte_str)</code>","text":"<p>Generate a new Message instance from this Descriptor and a byte string.</p> <p>DEPRECATED: ParseMessage is deprecated because it is using MakeClass(). Please use MessageFactory.GetPrototype() instead.</p> <p>Parameters:</p> Name Type Description Default <code>descriptor</code> <p>Protobuf Descriptor object</p> required <code>byte_str</code> <p>Serialized protocol buffer byte string</p> required <p>Returns:</p> Type Description <p>Newly created protobuf Message object.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/reflection.py</code> <pre><code>def ParseMessage(descriptor, byte_str):\n  \"\"\"Generate a new Message instance from this Descriptor and a byte string.\n\n  DEPRECATED: ParseMessage is deprecated because it is using MakeClass().\n  Please use MessageFactory.GetPrototype() instead.\n\n  Args:\n    descriptor: Protobuf Descriptor object\n    byte_str: Serialized protocol buffer byte string\n\n  Returns:\n    Newly created protobuf Message object.\n  \"\"\"\n  result_class = MakeClass(descriptor)\n  new_msg = result_class()\n  new_msg.ParseFromString(byte_str)\n  return new_msg\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/service.html","title":"service","text":"<p>DEPRECATED:  Declares the RPC service interfaces.</p> <p>This module declares the abstract interfaces underlying proto2 RPC services.  These are intended to be independent of any particular RPC implementation, so that proto2 services can be used on top of a variety of implementations.  Starting with version 2.3.0, RPC implementations should not try to build on these, but should instead provide code generator plugins which generate code specific to the particular RPC implementation.  This way the generated code can be more appropriate for the implementation in use and can avoid unnecessary layers of indirection.</p>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/service.html#client.ayon_hiero.vendor.google.protobuf.service.RpcChannel","title":"<code>RpcChannel</code>","text":"<p>               Bases: <code>object</code></p> <p>Abstract interface for an RPC channel.</p> <p>An RpcChannel represents a communication line to a service which can be used to call that service's methods.  The service may be running on another machine. Normally, you should not use an RpcChannel directly, but instead construct a stub {@link Service} wrapping it.  Example:</p> Example <p>RpcChannel channel = rpcImpl.Channel(\"remotehost.example.com:1234\") RpcController controller = rpcImpl.Controller() MyService service = MyService_Stub(channel) service.MyMethod(controller, request, callback)</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/service.py</code> <pre><code>class RpcChannel(object):\n\n  \"\"\"Abstract interface for an RPC channel.\n\n  An RpcChannel represents a communication line to a service which can be used\n  to call that service's methods.  The service may be running on another\n  machine. Normally, you should not use an RpcChannel directly, but instead\n  construct a stub {@link Service} wrapping it.  Example:\n\n  Example:\n    RpcChannel channel = rpcImpl.Channel(\"remotehost.example.com:1234\")\n    RpcController controller = rpcImpl.Controller()\n    MyService service = MyService_Stub(channel)\n    service.MyMethod(controller, request, callback)\n  \"\"\"\n\n  def CallMethod(self, method_descriptor, rpc_controller,\n                 request, response_class, done):\n    \"\"\"Calls the method identified by the descriptor.\n\n    Call the given method of the remote service.  The signature of this\n    procedure looks the same as Service.CallMethod(), but the requirements\n    are less strict in one important way:  the request object doesn't have to\n    be of any specific class as long as its descriptor is method.input_type.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/service.html#client.ayon_hiero.vendor.google.protobuf.service.RpcChannel.CallMethod","title":"<code>CallMethod(method_descriptor, rpc_controller, request, response_class, done)</code>","text":"<p>Calls the method identified by the descriptor.</p> <p>Call the given method of the remote service.  The signature of this procedure looks the same as Service.CallMethod(), but the requirements are less strict in one important way:  the request object doesn't have to be of any specific class as long as its descriptor is method.input_type.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/service.py</code> <pre><code>def CallMethod(self, method_descriptor, rpc_controller,\n               request, response_class, done):\n  \"\"\"Calls the method identified by the descriptor.\n\n  Call the given method of the remote service.  The signature of this\n  procedure looks the same as Service.CallMethod(), but the requirements\n  are less strict in one important way:  the request object doesn't have to\n  be of any specific class as long as its descriptor is method.input_type.\n  \"\"\"\n  raise NotImplementedError\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/service.html#client.ayon_hiero.vendor.google.protobuf.service.RpcController","title":"<code>RpcController</code>","text":"<p>               Bases: <code>object</code></p> <p>An RpcController mediates a single method call.</p> <p>The primary purpose of the controller is to provide a way to manipulate settings specific to the RPC implementation and to find out about RPC-level errors. The methods provided by the RpcController interface are intended to be a \"least common denominator\" set of features which we expect all implementations to support.  Specific implementations may provide more advanced features (e.g. deadline propagation).</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/service.py</code> <pre><code>class RpcController(object):\n\n  \"\"\"An RpcController mediates a single method call.\n\n  The primary purpose of the controller is to provide a way to manipulate\n  settings specific to the RPC implementation and to find out about RPC-level\n  errors. The methods provided by the RpcController interface are intended\n  to be a \"least common denominator\" set of features which we expect all\n  implementations to support.  Specific implementations may provide more\n  advanced features (e.g. deadline propagation).\n  \"\"\"\n\n  # Client-side methods below\n\n  def Reset(self):\n    \"\"\"Resets the RpcController to its initial state.\n\n    After the RpcController has been reset, it may be reused in\n    a new call. Must not be called while an RPC is in progress.\n    \"\"\"\n    raise NotImplementedError\n\n  def Failed(self):\n    \"\"\"Returns true if the call failed.\n\n    After a call has finished, returns true if the call failed.  The possible\n    reasons for failure depend on the RPC implementation.  Failed() must not\n    be called before a call has finished.  If Failed() returns true, the\n    contents of the response message are undefined.\n    \"\"\"\n    raise NotImplementedError\n\n  def ErrorText(self):\n    \"\"\"If Failed is true, returns a human-readable description of the error.\"\"\"\n    raise NotImplementedError\n\n  def StartCancel(self):\n    \"\"\"Initiate cancellation.\n\n    Advises the RPC system that the caller desires that the RPC call be\n    canceled.  The RPC system may cancel it immediately, may wait awhile and\n    then cancel it, or may not even cancel the call at all.  If the call is\n    canceled, the \"done\" callback will still be called and the RpcController\n    will indicate that the call failed at that time.\n    \"\"\"\n    raise NotImplementedError\n\n  # Server-side methods below\n\n  def SetFailed(self, reason):\n    \"\"\"Sets a failure reason.\n\n    Causes Failed() to return true on the client side.  \"reason\" will be\n    incorporated into the message returned by ErrorText().  If you find\n    you need to return machine-readable information about failures, you\n    should incorporate it into your response protocol buffer and should\n    NOT call SetFailed().\n    \"\"\"\n    raise NotImplementedError\n\n  def IsCanceled(self):\n    \"\"\"Checks if the client cancelled the RPC.\n\n    If true, indicates that the client canceled the RPC, so the server may\n    as well give up on replying to it.  The server should still call the\n    final \"done\" callback.\n    \"\"\"\n    raise NotImplementedError\n\n  def NotifyOnCancel(self, callback):\n    \"\"\"Sets a callback to invoke on cancel.\n\n    Asks that the given callback be called when the RPC is canceled.  The\n    callback will always be called exactly once.  If the RPC completes without\n    being canceled, the callback will be called after completion.  If the RPC\n    has already been canceled when NotifyOnCancel() is called, the callback\n    will be called immediately.\n\n    NotifyOnCancel() must be called no more than once per request.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/service.html#client.ayon_hiero.vendor.google.protobuf.service.RpcController.ErrorText","title":"<code>ErrorText()</code>","text":"<p>If Failed is true, returns a human-readable description of the error.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/service.py</code> <pre><code>def ErrorText(self):\n  \"\"\"If Failed is true, returns a human-readable description of the error.\"\"\"\n  raise NotImplementedError\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/service.html#client.ayon_hiero.vendor.google.protobuf.service.RpcController.Failed","title":"<code>Failed()</code>","text":"<p>Returns true if the call failed.</p> <p>After a call has finished, returns true if the call failed.  The possible reasons for failure depend on the RPC implementation.  Failed() must not be called before a call has finished.  If Failed() returns true, the contents of the response message are undefined.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/service.py</code> <pre><code>def Failed(self):\n  \"\"\"Returns true if the call failed.\n\n  After a call has finished, returns true if the call failed.  The possible\n  reasons for failure depend on the RPC implementation.  Failed() must not\n  be called before a call has finished.  If Failed() returns true, the\n  contents of the response message are undefined.\n  \"\"\"\n  raise NotImplementedError\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/service.html#client.ayon_hiero.vendor.google.protobuf.service.RpcController.IsCanceled","title":"<code>IsCanceled()</code>","text":"<p>Checks if the client cancelled the RPC.</p> <p>If true, indicates that the client canceled the RPC, so the server may as well give up on replying to it.  The server should still call the final \"done\" callback.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/service.py</code> <pre><code>def IsCanceled(self):\n  \"\"\"Checks if the client cancelled the RPC.\n\n  If true, indicates that the client canceled the RPC, so the server may\n  as well give up on replying to it.  The server should still call the\n  final \"done\" callback.\n  \"\"\"\n  raise NotImplementedError\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/service.html#client.ayon_hiero.vendor.google.protobuf.service.RpcController.NotifyOnCancel","title":"<code>NotifyOnCancel(callback)</code>","text":"<p>Sets a callback to invoke on cancel.</p> <p>Asks that the given callback be called when the RPC is canceled.  The callback will always be called exactly once.  If the RPC completes without being canceled, the callback will be called after completion.  If the RPC has already been canceled when NotifyOnCancel() is called, the callback will be called immediately.</p> <p>NotifyOnCancel() must be called no more than once per request.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/service.py</code> <pre><code>def NotifyOnCancel(self, callback):\n  \"\"\"Sets a callback to invoke on cancel.\n\n  Asks that the given callback be called when the RPC is canceled.  The\n  callback will always be called exactly once.  If the RPC completes without\n  being canceled, the callback will be called after completion.  If the RPC\n  has already been canceled when NotifyOnCancel() is called, the callback\n  will be called immediately.\n\n  NotifyOnCancel() must be called no more than once per request.\n  \"\"\"\n  raise NotImplementedError\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/service.html#client.ayon_hiero.vendor.google.protobuf.service.RpcController.Reset","title":"<code>Reset()</code>","text":"<p>Resets the RpcController to its initial state.</p> <p>After the RpcController has been reset, it may be reused in a new call. Must not be called while an RPC is in progress.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/service.py</code> <pre><code>def Reset(self):\n  \"\"\"Resets the RpcController to its initial state.\n\n  After the RpcController has been reset, it may be reused in\n  a new call. Must not be called while an RPC is in progress.\n  \"\"\"\n  raise NotImplementedError\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/service.html#client.ayon_hiero.vendor.google.protobuf.service.RpcController.SetFailed","title":"<code>SetFailed(reason)</code>","text":"<p>Sets a failure reason.</p> <p>Causes Failed() to return true on the client side.  \"reason\" will be incorporated into the message returned by ErrorText().  If you find you need to return machine-readable information about failures, you should incorporate it into your response protocol buffer and should NOT call SetFailed().</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/service.py</code> <pre><code>def SetFailed(self, reason):\n  \"\"\"Sets a failure reason.\n\n  Causes Failed() to return true on the client side.  \"reason\" will be\n  incorporated into the message returned by ErrorText().  If you find\n  you need to return machine-readable information about failures, you\n  should incorporate it into your response protocol buffer and should\n  NOT call SetFailed().\n  \"\"\"\n  raise NotImplementedError\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/service.html#client.ayon_hiero.vendor.google.protobuf.service.RpcController.StartCancel","title":"<code>StartCancel()</code>","text":"<p>Initiate cancellation.</p> <p>Advises the RPC system that the caller desires that the RPC call be canceled.  The RPC system may cancel it immediately, may wait awhile and then cancel it, or may not even cancel the call at all.  If the call is canceled, the \"done\" callback will still be called and the RpcController will indicate that the call failed at that time.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/service.py</code> <pre><code>def StartCancel(self):\n  \"\"\"Initiate cancellation.\n\n  Advises the RPC system that the caller desires that the RPC call be\n  canceled.  The RPC system may cancel it immediately, may wait awhile and\n  then cancel it, or may not even cancel the call at all.  If the call is\n  canceled, the \"done\" callback will still be called and the RpcController\n  will indicate that the call failed at that time.\n  \"\"\"\n  raise NotImplementedError\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/service.html#client.ayon_hiero.vendor.google.protobuf.service.RpcException","title":"<code>RpcException</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Exception raised on failed blocking RPC method call.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/service.py</code> <pre><code>class RpcException(Exception):\n  \"\"\"Exception raised on failed blocking RPC method call.\"\"\"\n  pass\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/service.html#client.ayon_hiero.vendor.google.protobuf.service.Service","title":"<code>Service</code>","text":"<p>               Bases: <code>object</code></p> <p>Abstract base interface for protocol-buffer-based RPC services.</p> <p>Services themselves are abstract classes (implemented either by servers or as stubs), but they subclass this base interface. The methods of this interface can be used to call the methods of the service without knowing its exact type at compile time (analogous to the Message interface).</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/service.py</code> <pre><code>class Service(object):\n\n  \"\"\"Abstract base interface for protocol-buffer-based RPC services.\n\n  Services themselves are abstract classes (implemented either by servers or as\n  stubs), but they subclass this base interface. The methods of this\n  interface can be used to call the methods of the service without knowing\n  its exact type at compile time (analogous to the Message interface).\n  \"\"\"\n\n  def GetDescriptor():\n    \"\"\"Retrieves this service's descriptor.\"\"\"\n    raise NotImplementedError\n\n  def CallMethod(self, method_descriptor, rpc_controller,\n                 request, done):\n    \"\"\"Calls a method of the service specified by method_descriptor.\n\n    If \"done\" is None then the call is blocking and the response\n    message will be returned directly.  Otherwise the call is asynchronous\n    and \"done\" will later be called with the response value.\n\n    In the blocking case, RpcException will be raised on error.\n\n    Preconditions:\n\n    * method_descriptor.service == GetDescriptor\n    * request is of the exact same classes as returned by\n      GetRequestClass(method).\n    * After the call has started, the request must not be modified.\n    * \"rpc_controller\" is of the correct type for the RPC implementation being\n      used by this Service.  For stubs, the \"correct type\" depends on the\n      RpcChannel which the stub is using.\n\n    Postconditions:\n\n    * \"done\" will be called when the method is complete.  This may be\n      before CallMethod() returns or it may be at some point in the future.\n    * If the RPC failed, the response value passed to \"done\" will be None.\n      Further details about the failure can be found by querying the\n      RpcController.\n    \"\"\"\n    raise NotImplementedError\n\n  def GetRequestClass(self, method_descriptor):\n    \"\"\"Returns the class of the request message for the specified method.\n\n    CallMethod() requires that the request is of a particular subclass of\n    Message. GetRequestClass() gets the default instance of this required\n    type.\n\n    Example:\n      method = service.GetDescriptor().FindMethodByName(\"Foo\")\n      request = stub.GetRequestClass(method)()\n      request.ParseFromString(input)\n      service.CallMethod(method, request, callback)\n    \"\"\"\n    raise NotImplementedError\n\n  def GetResponseClass(self, method_descriptor):\n    \"\"\"Returns the class of the response message for the specified method.\n\n    This method isn't really needed, as the RpcChannel's CallMethod constructs\n    the response protocol message. It's provided anyway in case it is useful\n    for the caller to know the response type in advance.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/service.html#client.ayon_hiero.vendor.google.protobuf.service.Service.CallMethod","title":"<code>CallMethod(method_descriptor, rpc_controller, request, done)</code>","text":"<p>Calls a method of the service specified by method_descriptor.</p> <p>If \"done\" is None then the call is blocking and the response message will be returned directly.  Otherwise the call is asynchronous and \"done\" will later be called with the response value.</p> <p>In the blocking case, RpcException will be raised on error.</p> <p>Preconditions:</p> <ul> <li>method_descriptor.service == GetDescriptor</li> <li>request is of the exact same classes as returned by   GetRequestClass(method).</li> <li>After the call has started, the request must not be modified.</li> <li>\"rpc_controller\" is of the correct type for the RPC implementation being   used by this Service.  For stubs, the \"correct type\" depends on the   RpcChannel which the stub is using.</li> </ul> <p>Postconditions:</p> <ul> <li>\"done\" will be called when the method is complete.  This may be   before CallMethod() returns or it may be at some point in the future.</li> <li>If the RPC failed, the response value passed to \"done\" will be None.   Further details about the failure can be found by querying the   RpcController.</li> </ul> Source code in <code>client/ayon_hiero/vendor/google/protobuf/service.py</code> <pre><code>def CallMethod(self, method_descriptor, rpc_controller,\n               request, done):\n  \"\"\"Calls a method of the service specified by method_descriptor.\n\n  If \"done\" is None then the call is blocking and the response\n  message will be returned directly.  Otherwise the call is asynchronous\n  and \"done\" will later be called with the response value.\n\n  In the blocking case, RpcException will be raised on error.\n\n  Preconditions:\n\n  * method_descriptor.service == GetDescriptor\n  * request is of the exact same classes as returned by\n    GetRequestClass(method).\n  * After the call has started, the request must not be modified.\n  * \"rpc_controller\" is of the correct type for the RPC implementation being\n    used by this Service.  For stubs, the \"correct type\" depends on the\n    RpcChannel which the stub is using.\n\n  Postconditions:\n\n  * \"done\" will be called when the method is complete.  This may be\n    before CallMethod() returns or it may be at some point in the future.\n  * If the RPC failed, the response value passed to \"done\" will be None.\n    Further details about the failure can be found by querying the\n    RpcController.\n  \"\"\"\n  raise NotImplementedError\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/service.html#client.ayon_hiero.vendor.google.protobuf.service.Service.GetDescriptor","title":"<code>GetDescriptor()</code>","text":"<p>Retrieves this service's descriptor.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/service.py</code> <pre><code>def GetDescriptor():\n  \"\"\"Retrieves this service's descriptor.\"\"\"\n  raise NotImplementedError\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/service.html#client.ayon_hiero.vendor.google.protobuf.service.Service.GetRequestClass","title":"<code>GetRequestClass(method_descriptor)</code>","text":"<p>Returns the class of the request message for the specified method.</p> <p>CallMethod() requires that the request is of a particular subclass of Message. GetRequestClass() gets the default instance of this required type.</p> Example <p>method = service.GetDescriptor().FindMethodByName(\"Foo\") request = stub.GetRequestClass(method)() request.ParseFromString(input) service.CallMethod(method, request, callback)</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/service.py</code> <pre><code>def GetRequestClass(self, method_descriptor):\n  \"\"\"Returns the class of the request message for the specified method.\n\n  CallMethod() requires that the request is of a particular subclass of\n  Message. GetRequestClass() gets the default instance of this required\n  type.\n\n  Example:\n    method = service.GetDescriptor().FindMethodByName(\"Foo\")\n    request = stub.GetRequestClass(method)()\n    request.ParseFromString(input)\n    service.CallMethod(method, request, callback)\n  \"\"\"\n  raise NotImplementedError\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/service.html#client.ayon_hiero.vendor.google.protobuf.service.Service.GetResponseClass","title":"<code>GetResponseClass(method_descriptor)</code>","text":"<p>Returns the class of the response message for the specified method.</p> <p>This method isn't really needed, as the RpcChannel's CallMethod constructs the response protocol message. It's provided anyway in case it is useful for the caller to know the response type in advance.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/service.py</code> <pre><code>def GetResponseClass(self, method_descriptor):\n  \"\"\"Returns the class of the response message for the specified method.\n\n  This method isn't really needed, as the RpcChannel's CallMethod constructs\n  the response protocol message. It's provided anyway in case it is useful\n  for the caller to know the response type in advance.\n  \"\"\"\n  raise NotImplementedError\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/service_reflection.html","title":"service_reflection","text":"<p>Contains metaclasses used to create protocol service and service stub classes from ServiceDescriptor objects at runtime.</p> <p>The GeneratedServiceType and GeneratedServiceStubType metaclasses are used to inject all useful functionality into the classes output by the protocol compiler at compile-time.</p>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/service_reflection.html#client.ayon_hiero.vendor.google.protobuf.service_reflection.GeneratedServiceStubType","title":"<code>GeneratedServiceStubType</code>","text":"<p>               Bases: <code>GeneratedServiceType</code></p> <p>Metaclass for service stubs created at runtime from ServiceDescriptors.</p> <p>This class has similar responsibilities as GeneratedServiceType, except that it creates the service stub classes.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/service_reflection.py</code> <pre><code>class GeneratedServiceStubType(GeneratedServiceType):\n\n  \"\"\"Metaclass for service stubs created at runtime from ServiceDescriptors.\n\n  This class has similar responsibilities as GeneratedServiceType, except that\n  it creates the service stub classes.\n  \"\"\"\n\n  _DESCRIPTOR_KEY = 'DESCRIPTOR'\n\n  def __init__(cls, name, bases, dictionary):\n    \"\"\"Creates a message service stub class.\n\n    Args:\n      name: Name of the class (ignored, here).\n      bases: Base classes of the class being constructed.\n      dictionary: The class dictionary of the class being constructed.\n        dictionary[_DESCRIPTOR_KEY] must contain a ServiceDescriptor object\n        describing this protocol service type.\n    \"\"\"\n    super(GeneratedServiceStubType, cls).__init__(name, bases, dictionary)\n    # Don't do anything if this class doesn't have a descriptor. This happens\n    # when a service stub is subclassed.\n    if GeneratedServiceStubType._DESCRIPTOR_KEY not in dictionary:\n      return\n\n    descriptor = dictionary[GeneratedServiceStubType._DESCRIPTOR_KEY]\n    service_stub_builder = _ServiceStubBuilder(descriptor)\n    service_stub_builder.BuildServiceStub(cls)\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/service_reflection.html#client.ayon_hiero.vendor.google.protobuf.service_reflection.GeneratedServiceStubType.__init__","title":"<code>__init__(name, bases, dictionary)</code>","text":"<p>Creates a message service stub class.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <p>Name of the class (ignored, here).</p> required <code>bases</code> <p>Base classes of the class being constructed.</p> required <code>dictionary</code> <p>The class dictionary of the class being constructed. dictionary[_DESCRIPTOR_KEY] must contain a ServiceDescriptor object describing this protocol service type.</p> required Source code in <code>client/ayon_hiero/vendor/google/protobuf/service_reflection.py</code> <pre><code>def __init__(cls, name, bases, dictionary):\n  \"\"\"Creates a message service stub class.\n\n  Args:\n    name: Name of the class (ignored, here).\n    bases: Base classes of the class being constructed.\n    dictionary: The class dictionary of the class being constructed.\n      dictionary[_DESCRIPTOR_KEY] must contain a ServiceDescriptor object\n      describing this protocol service type.\n  \"\"\"\n  super(GeneratedServiceStubType, cls).__init__(name, bases, dictionary)\n  # Don't do anything if this class doesn't have a descriptor. This happens\n  # when a service stub is subclassed.\n  if GeneratedServiceStubType._DESCRIPTOR_KEY not in dictionary:\n    return\n\n  descriptor = dictionary[GeneratedServiceStubType._DESCRIPTOR_KEY]\n  service_stub_builder = _ServiceStubBuilder(descriptor)\n  service_stub_builder.BuildServiceStub(cls)\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/service_reflection.html#client.ayon_hiero.vendor.google.protobuf.service_reflection.GeneratedServiceType","title":"<code>GeneratedServiceType</code>","text":"<p>               Bases: <code>type</code></p> <p>Metaclass for service classes created at runtime from ServiceDescriptors.</p> <p>Implementations for all methods described in the Service class are added here by this class. We also create properties to allow getting/setting all fields in the protocol message.</p> <p>The protocol compiler currently uses this metaclass to create protocol service classes at runtime. Clients can also manually create their own classes at runtime, as in this example::</p> <p>mydescriptor = ServiceDescriptor(.....)   class MyProtoService(service.Service):     metaclass = GeneratedServiceType     DESCRIPTOR = mydescriptor   myservice_instance = MyProtoService()   # ...</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/service_reflection.py</code> <pre><code>class GeneratedServiceType(type):\n\n  \"\"\"Metaclass for service classes created at runtime from ServiceDescriptors.\n\n  Implementations for all methods described in the Service class are added here\n  by this class. We also create properties to allow getting/setting all fields\n  in the protocol message.\n\n  The protocol compiler currently uses this metaclass to create protocol service\n  classes at runtime. Clients can also manually create their own classes at\n  runtime, as in this example::\n\n    mydescriptor = ServiceDescriptor(.....)\n    class MyProtoService(service.Service):\n      __metaclass__ = GeneratedServiceType\n      DESCRIPTOR = mydescriptor\n    myservice_instance = MyProtoService()\n    # ...\n  \"\"\"\n\n  _DESCRIPTOR_KEY = 'DESCRIPTOR'\n\n  def __init__(cls, name, bases, dictionary):\n    \"\"\"Creates a message service class.\n\n    Args:\n      name: Name of the class (ignored, but required by the metaclass\n        protocol).\n      bases: Base classes of the class being constructed.\n      dictionary: The class dictionary of the class being constructed.\n        dictionary[_DESCRIPTOR_KEY] must contain a ServiceDescriptor object\n        describing this protocol service type.\n    \"\"\"\n    # Don't do anything if this class doesn't have a descriptor. This happens\n    # when a service class is subclassed.\n    if GeneratedServiceType._DESCRIPTOR_KEY not in dictionary:\n      return\n\n    descriptor = dictionary[GeneratedServiceType._DESCRIPTOR_KEY]\n    service_builder = _ServiceBuilder(descriptor)\n    service_builder.BuildService(cls)\n    cls.DESCRIPTOR = descriptor\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/service_reflection.html#client.ayon_hiero.vendor.google.protobuf.service_reflection.GeneratedServiceType.__init__","title":"<code>__init__(name, bases, dictionary)</code>","text":"<p>Creates a message service class.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <p>Name of the class (ignored, but required by the metaclass protocol).</p> required <code>bases</code> <p>Base classes of the class being constructed.</p> required <code>dictionary</code> <p>The class dictionary of the class being constructed. dictionary[_DESCRIPTOR_KEY] must contain a ServiceDescriptor object describing this protocol service type.</p> required Source code in <code>client/ayon_hiero/vendor/google/protobuf/service_reflection.py</code> <pre><code>def __init__(cls, name, bases, dictionary):\n  \"\"\"Creates a message service class.\n\n  Args:\n    name: Name of the class (ignored, but required by the metaclass\n      protocol).\n    bases: Base classes of the class being constructed.\n    dictionary: The class dictionary of the class being constructed.\n      dictionary[_DESCRIPTOR_KEY] must contain a ServiceDescriptor object\n      describing this protocol service type.\n  \"\"\"\n  # Don't do anything if this class doesn't have a descriptor. This happens\n  # when a service class is subclassed.\n  if GeneratedServiceType._DESCRIPTOR_KEY not in dictionary:\n    return\n\n  descriptor = dictionary[GeneratedServiceType._DESCRIPTOR_KEY]\n  service_builder = _ServiceBuilder(descriptor)\n  service_builder.BuildService(cls)\n  cls.DESCRIPTOR = descriptor\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/source_context_pb2.html","title":"source_context_pb2","text":"<p>Generated protocol buffer code.</p>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/struct_pb2.html","title":"struct_pb2","text":"<p>Generated protocol buffer code.</p>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/symbol_database.html","title":"symbol_database","text":"<p>A database of Python protocol buffer generated symbols.</p> <p>SymbolDatabase is the MessageFactory for messages generated at compile time, and makes it easy to create new instances of a registered type, given only the type's protocol buffer symbol name.</p> <p>Example usage::</p> <p>db = symbol_database.SymbolDatabase()</p> <p># Register symbols of interest, from one or multiple files.   db.RegisterFileDescriptor(my_proto_pb2.DESCRIPTOR)   db.RegisterMessage(my_proto_pb2.MyMessage)   db.RegisterEnumDescriptor(my_proto_pb2.MyEnum.DESCRIPTOR)</p> <p># The database can be used as a MessageFactory, to generate types based on   # their name:   types = db.GetMessages(['my_proto.proto'])   my_message_instance = types'MyMessage'</p> <p># The database's underlying descriptor pool can be queried, so it's not   # necessary to know a type's filename to be able to generate it:   filename = db.pool.FindFileContainingSymbol('MyMessage')   my_message_instance = db.GetMessages([filename])'MyMessage'</p> <p># This functionality is also provided directly via a convenience method:   my_message_instance = db.GetSymbol('MyMessage')()</p>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/symbol_database.html#client.ayon_hiero.vendor.google.protobuf.symbol_database.SymbolDatabase","title":"<code>SymbolDatabase</code>","text":"<p>               Bases: <code>MessageFactory</code></p> <p>A database of Python generated symbols.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/symbol_database.py</code> <pre><code>class SymbolDatabase(message_factory.MessageFactory):\n  \"\"\"A database of Python generated symbols.\"\"\"\n\n  def RegisterMessage(self, message):\n    \"\"\"Registers the given message type in the local database.\n\n    Calls to GetSymbol() and GetMessages() will return messages registered here.\n\n    Args:\n      message: A :class:`google.protobuf.message.Message` subclass (or\n        instance); its descriptor will be registered.\n\n    Returns:\n      The provided message.\n    \"\"\"\n\n    desc = message.DESCRIPTOR\n    self._classes[desc] = message\n    self.RegisterMessageDescriptor(desc)\n    return message\n\n  def RegisterMessageDescriptor(self, message_descriptor):\n    \"\"\"Registers the given message descriptor in the local database.\n\n    Args:\n      message_descriptor (Descriptor): the message descriptor to add.\n    \"\"\"\n    if api_implementation.Type() == 'python':\n      # pylint: disable=protected-access\n      self.pool._AddDescriptor(message_descriptor)\n\n  def RegisterEnumDescriptor(self, enum_descriptor):\n    \"\"\"Registers the given enum descriptor in the local database.\n\n    Args:\n      enum_descriptor (EnumDescriptor): The enum descriptor to register.\n\n    Returns:\n      EnumDescriptor: The provided descriptor.\n    \"\"\"\n    if api_implementation.Type() == 'python':\n      # pylint: disable=protected-access\n      self.pool._AddEnumDescriptor(enum_descriptor)\n    return enum_descriptor\n\n  def RegisterServiceDescriptor(self, service_descriptor):\n    \"\"\"Registers the given service descriptor in the local database.\n\n    Args:\n      service_descriptor (ServiceDescriptor): the service descriptor to\n        register.\n    \"\"\"\n    if api_implementation.Type() == 'python':\n      # pylint: disable=protected-access\n      self.pool._AddServiceDescriptor(service_descriptor)\n\n  def RegisterFileDescriptor(self, file_descriptor):\n    \"\"\"Registers the given file descriptor in the local database.\n\n    Args:\n      file_descriptor (FileDescriptor): The file descriptor to register.\n    \"\"\"\n    if api_implementation.Type() == 'python':\n      # pylint: disable=protected-access\n      self.pool._InternalAddFileDescriptor(file_descriptor)\n\n  def GetSymbol(self, symbol):\n    \"\"\"Tries to find a symbol in the local database.\n\n    Currently, this method only returns message.Message instances, however, if\n    may be extended in future to support other symbol types.\n\n    Args:\n      symbol (str): a protocol buffer symbol.\n\n    Returns:\n      A Python class corresponding to the symbol.\n\n    Raises:\n      KeyError: if the symbol could not be found.\n    \"\"\"\n\n    return self._classes[self.pool.FindMessageTypeByName(symbol)]\n\n  def GetMessages(self, files):\n    # TODO(amauryfa): Fix the differences with MessageFactory.\n    \"\"\"Gets all registered messages from a specified file.\n\n    Only messages already created and registered will be returned; (this is the\n    case for imported _pb2 modules)\n    But unlike MessageFactory, this version also returns already defined nested\n    messages, but does not register any message extensions.\n\n    Args:\n      files (list[str]): The file names to extract messages from.\n\n    Returns:\n      A dictionary mapping proto names to the message classes.\n\n    Raises:\n      KeyError: if a file could not be found.\n    \"\"\"\n\n    def _GetAllMessages(desc):\n      \"\"\"Walk a message Descriptor and recursively yields all message names.\"\"\"\n      yield desc\n      for msg_desc in desc.nested_types:\n        for nested_desc in _GetAllMessages(msg_desc):\n          yield nested_desc\n\n    result = {}\n    for file_name in files:\n      file_desc = self.pool.FindFileByName(file_name)\n      for msg_desc in file_desc.message_types_by_name.values():\n        for desc in _GetAllMessages(msg_desc):\n          try:\n            result[desc.full_name] = self._classes[desc]\n          except KeyError:\n            # This descriptor has no registered class, skip it.\n            pass\n    return result\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/symbol_database.html#client.ayon_hiero.vendor.google.protobuf.symbol_database.SymbolDatabase.GetMessages","title":"<code>GetMessages(files)</code>","text":"<p>Gets all registered messages from a specified file.</p> <p>Only messages already created and registered will be returned; (this is the case for imported _pb2 modules) But unlike MessageFactory, this version also returns already defined nested messages, but does not register any message extensions.</p> <p>Parameters:</p> Name Type Description Default <code>files</code> <code>list[str]</code> <p>The file names to extract messages from.</p> required <p>Returns:</p> Type Description <p>A dictionary mapping proto names to the message classes.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>if a file could not be found.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/symbol_database.py</code> <pre><code>def GetMessages(self, files):\n  # TODO(amauryfa): Fix the differences with MessageFactory.\n  \"\"\"Gets all registered messages from a specified file.\n\n  Only messages already created and registered will be returned; (this is the\n  case for imported _pb2 modules)\n  But unlike MessageFactory, this version also returns already defined nested\n  messages, but does not register any message extensions.\n\n  Args:\n    files (list[str]): The file names to extract messages from.\n\n  Returns:\n    A dictionary mapping proto names to the message classes.\n\n  Raises:\n    KeyError: if a file could not be found.\n  \"\"\"\n\n  def _GetAllMessages(desc):\n    \"\"\"Walk a message Descriptor and recursively yields all message names.\"\"\"\n    yield desc\n    for msg_desc in desc.nested_types:\n      for nested_desc in _GetAllMessages(msg_desc):\n        yield nested_desc\n\n  result = {}\n  for file_name in files:\n    file_desc = self.pool.FindFileByName(file_name)\n    for msg_desc in file_desc.message_types_by_name.values():\n      for desc in _GetAllMessages(msg_desc):\n        try:\n          result[desc.full_name] = self._classes[desc]\n        except KeyError:\n          # This descriptor has no registered class, skip it.\n          pass\n  return result\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/symbol_database.html#client.ayon_hiero.vendor.google.protobuf.symbol_database.SymbolDatabase.GetSymbol","title":"<code>GetSymbol(symbol)</code>","text":"<p>Tries to find a symbol in the local database.</p> <p>Currently, this method only returns message.Message instances, however, if may be extended in future to support other symbol types.</p> <p>Parameters:</p> Name Type Description Default <code>symbol</code> <code>str</code> <p>a protocol buffer symbol.</p> required <p>Returns:</p> Type Description <p>A Python class corresponding to the symbol.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>if the symbol could not be found.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/symbol_database.py</code> <pre><code>def GetSymbol(self, symbol):\n  \"\"\"Tries to find a symbol in the local database.\n\n  Currently, this method only returns message.Message instances, however, if\n  may be extended in future to support other symbol types.\n\n  Args:\n    symbol (str): a protocol buffer symbol.\n\n  Returns:\n    A Python class corresponding to the symbol.\n\n  Raises:\n    KeyError: if the symbol could not be found.\n  \"\"\"\n\n  return self._classes[self.pool.FindMessageTypeByName(symbol)]\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/symbol_database.html#client.ayon_hiero.vendor.google.protobuf.symbol_database.SymbolDatabase.RegisterEnumDescriptor","title":"<code>RegisterEnumDescriptor(enum_descriptor)</code>","text":"<p>Registers the given enum descriptor in the local database.</p> <p>Parameters:</p> Name Type Description Default <code>enum_descriptor</code> <code>EnumDescriptor</code> <p>The enum descriptor to register.</p> required <p>Returns:</p> Name Type Description <code>EnumDescriptor</code> <p>The provided descriptor.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/symbol_database.py</code> <pre><code>def RegisterEnumDescriptor(self, enum_descriptor):\n  \"\"\"Registers the given enum descriptor in the local database.\n\n  Args:\n    enum_descriptor (EnumDescriptor): The enum descriptor to register.\n\n  Returns:\n    EnumDescriptor: The provided descriptor.\n  \"\"\"\n  if api_implementation.Type() == 'python':\n    # pylint: disable=protected-access\n    self.pool._AddEnumDescriptor(enum_descriptor)\n  return enum_descriptor\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/symbol_database.html#client.ayon_hiero.vendor.google.protobuf.symbol_database.SymbolDatabase.RegisterFileDescriptor","title":"<code>RegisterFileDescriptor(file_descriptor)</code>","text":"<p>Registers the given file descriptor in the local database.</p> <p>Parameters:</p> Name Type Description Default <code>file_descriptor</code> <code>FileDescriptor</code> <p>The file descriptor to register.</p> required Source code in <code>client/ayon_hiero/vendor/google/protobuf/symbol_database.py</code> <pre><code>def RegisterFileDescriptor(self, file_descriptor):\n  \"\"\"Registers the given file descriptor in the local database.\n\n  Args:\n    file_descriptor (FileDescriptor): The file descriptor to register.\n  \"\"\"\n  if api_implementation.Type() == 'python':\n    # pylint: disable=protected-access\n    self.pool._InternalAddFileDescriptor(file_descriptor)\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/symbol_database.html#client.ayon_hiero.vendor.google.protobuf.symbol_database.SymbolDatabase.RegisterMessage","title":"<code>RegisterMessage(message)</code>","text":"<p>Registers the given message type in the local database.</p> <p>Calls to GetSymbol() and GetMessages() will return messages registered here.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <p>A :class:<code>google.protobuf.message.Message</code> subclass (or instance); its descriptor will be registered.</p> required <p>Returns:</p> Type Description <p>The provided message.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/symbol_database.py</code> <pre><code>def RegisterMessage(self, message):\n  \"\"\"Registers the given message type in the local database.\n\n  Calls to GetSymbol() and GetMessages() will return messages registered here.\n\n  Args:\n    message: A :class:`google.protobuf.message.Message` subclass (or\n      instance); its descriptor will be registered.\n\n  Returns:\n    The provided message.\n  \"\"\"\n\n  desc = message.DESCRIPTOR\n  self._classes[desc] = message\n  self.RegisterMessageDescriptor(desc)\n  return message\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/symbol_database.html#client.ayon_hiero.vendor.google.protobuf.symbol_database.SymbolDatabase.RegisterMessageDescriptor","title":"<code>RegisterMessageDescriptor(message_descriptor)</code>","text":"<p>Registers the given message descriptor in the local database.</p> <p>Parameters:</p> Name Type Description Default <code>message_descriptor</code> <code>Descriptor</code> <p>the message descriptor to add.</p> required Source code in <code>client/ayon_hiero/vendor/google/protobuf/symbol_database.py</code> <pre><code>def RegisterMessageDescriptor(self, message_descriptor):\n  \"\"\"Registers the given message descriptor in the local database.\n\n  Args:\n    message_descriptor (Descriptor): the message descriptor to add.\n  \"\"\"\n  if api_implementation.Type() == 'python':\n    # pylint: disable=protected-access\n    self.pool._AddDescriptor(message_descriptor)\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/symbol_database.html#client.ayon_hiero.vendor.google.protobuf.symbol_database.SymbolDatabase.RegisterServiceDescriptor","title":"<code>RegisterServiceDescriptor(service_descriptor)</code>","text":"<p>Registers the given service descriptor in the local database.</p> <p>Parameters:</p> Name Type Description Default <code>service_descriptor</code> <code>ServiceDescriptor</code> <p>the service descriptor to register.</p> required Source code in <code>client/ayon_hiero/vendor/google/protobuf/symbol_database.py</code> <pre><code>def RegisterServiceDescriptor(self, service_descriptor):\n  \"\"\"Registers the given service descriptor in the local database.\n\n  Args:\n    service_descriptor (ServiceDescriptor): the service descriptor to\n      register.\n  \"\"\"\n  if api_implementation.Type() == 'python':\n    # pylint: disable=protected-access\n    self.pool._AddServiceDescriptor(service_descriptor)\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/symbol_database.html#client.ayon_hiero.vendor.google.protobuf.symbol_database.Default","title":"<code>Default()</code>","text":"<p>Returns the default SymbolDatabase.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/symbol_database.py</code> <pre><code>def Default():\n  \"\"\"Returns the default SymbolDatabase.\"\"\"\n  return _DEFAULT\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/text_encoding.html","title":"text_encoding","text":"<p>Encoding related utilities.</p>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/text_encoding.html#client.ayon_hiero.vendor.google.protobuf.text_encoding.CEscape","title":"<code>CEscape(text, as_utf8)</code>","text":"<p>Escape a bytes string for use in an text protocol buffer.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <p>A byte string to be escaped.</p> required <code>as_utf8</code> <p>Specifies if result may contain non-ASCII characters.   In Python 3 this allows unescaped non-ASCII Unicode characters.   In Python 2 the return value will be valid UTF-8 rather than only ASCII.</p> required <p>Returns:   Escaped string (str).</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/text_encoding.py</code> <pre><code>def CEscape(text, as_utf8):\n  # type: (...) -&gt; str\n  \"\"\"Escape a bytes string for use in an text protocol buffer.\n\n  Args:\n    text: A byte string to be escaped.\n    as_utf8: Specifies if result may contain non-ASCII characters.\n        In Python 3 this allows unescaped non-ASCII Unicode characters.\n        In Python 2 the return value will be valid UTF-8 rather than only ASCII.\n  Returns:\n    Escaped string (str).\n  \"\"\"\n  # Python's text.encode() 'string_escape' or 'unicode_escape' codecs do not\n  # satisfy our needs; they encodes unprintable characters using two-digit hex\n  # escapes whereas our C++ unescaping function allows hex escapes to be any\n  # length.  So, \"\\0011\".encode('string_escape') ends up being \"\\\\x011\", which\n  # will be decoded in C++ as a single-character string with char code 0x11.\n  text_is_unicode = isinstance(text, str)\n  if as_utf8 and text_is_unicode:\n    # We're already unicode, no processing beyond control char escapes.\n    return text.translate(_cescape_chr_to_symbol_map)\n  ord_ = ord if text_is_unicode else lambda x: x  # bytes iterate as ints.\n  if as_utf8:\n    return ''.join(_cescape_unicode_to_str[ord_(c)] for c in text)\n  return ''.join(_cescape_byte_to_str[ord_(c)] for c in text)\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/text_encoding.html#client.ayon_hiero.vendor.google.protobuf.text_encoding.CUnescape","title":"<code>CUnescape(text)</code>","text":"<p>Unescape a text string with C-style escape sequences to UTF-8 bytes.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <p>The data to parse in a str.</p> required <p>Returns:   A byte string.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/text_encoding.py</code> <pre><code>def CUnescape(text):\n  # type: (str) -&gt; bytes\n  \"\"\"Unescape a text string with C-style escape sequences to UTF-8 bytes.\n\n  Args:\n    text: The data to parse in a str.\n  Returns:\n    A byte string.\n  \"\"\"\n\n  def ReplaceHex(m):\n    # Only replace the match if the number of leading back slashes is odd. i.e.\n    # the slash itself is not escaped.\n    if len(m.group(1)) &amp; 1:\n      return m.group(1) + 'x0' + m.group(2)\n    return m.group(0)\n\n  # This is required because the 'string_escape' encoding doesn't\n  # allow single-digit hex escapes (like '\\xf').\n  result = _CUNESCAPE_HEX.sub(ReplaceHex, text)\n\n  return (result.encode('utf-8')  # Make it bytes to allow decode.\n          .decode('unicode_escape')\n          # Make it bytes again to return the proper type.\n          .encode('raw_unicode_escape'))\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/text_format.html","title":"text_format","text":"<p>Contains routines for printing protocol messages in text format.</p> <p>Simple usage example::</p> <p># Create a proto object and serialize it to a text proto string.   message = my_proto_pb2.MyMessage(foo='bar')   text_proto = text_format.MessageToString(message)</p> <p># Parse a text proto string.   message = text_format.Parse(text_proto, my_proto_pb2.MyMessage())</p>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/text_format.html#client.ayon_hiero.vendor.google.protobuf.text_format.Error","title":"<code>Error</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Top-level module error for text_format.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/text_format.py</code> <pre><code>class Error(Exception):\n  \"\"\"Top-level module error for text_format.\"\"\"\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/text_format.html#client.ayon_hiero.vendor.google.protobuf.text_format.ParseError","title":"<code>ParseError</code>","text":"<p>               Bases: <code>Error</code></p> <p>Thrown in case of text parsing or tokenizing error.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/text_format.py</code> <pre><code>class ParseError(Error):\n  \"\"\"Thrown in case of text parsing or tokenizing error.\"\"\"\n\n  def __init__(self, message=None, line=None, column=None):\n    if message is not None and line is not None:\n      loc = str(line)\n      if column is not None:\n        loc += ':{0}'.format(column)\n      message = '{0} : {1}'.format(loc, message)\n    if message is not None:\n      super(ParseError, self).__init__(message)\n    else:\n      super(ParseError, self).__init__()\n    self._line = line\n    self._column = column\n\n  def GetLine(self):\n    return self._line\n\n  def GetColumn(self):\n    return self._column\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/text_format.html#client.ayon_hiero.vendor.google.protobuf.text_format.Tokenizer","title":"<code>Tokenizer</code>","text":"<p>               Bases: <code>object</code></p> <p>Protocol buffer text representation tokenizer.</p> <p>This class handles the lower level string parsing by splitting it into meaningful tokens.</p> <p>It was directly ported from the Java protocol buffer API.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/text_format.py</code> <pre><code>class Tokenizer(object):\n  \"\"\"Protocol buffer text representation tokenizer.\n\n  This class handles the lower level string parsing by splitting it into\n  meaningful tokens.\n\n  It was directly ported from the Java protocol buffer API.\n  \"\"\"\n\n  _WHITESPACE = re.compile(r'\\s+')\n  _COMMENT = re.compile(r'(\\s*#.*$)', re.MULTILINE)\n  _WHITESPACE_OR_COMMENT = re.compile(r'(\\s|(#.*$))+', re.MULTILINE)\n  _TOKEN = re.compile('|'.join([\n      r'[a-zA-Z_][0-9a-zA-Z_+-]*',  # an identifier\n      r'([0-9+-]|(\\.[0-9]))[0-9a-zA-Z_.+-]*',  # a number\n  ] + [  # quoted str for each quote mark\n      # Avoid backtracking! https://stackoverflow.com/a/844267\n      r'{qt}[^{qt}\\n\\\\]*((\\\\.)+[^{qt}\\n\\\\]*)*({qt}|\\\\?$)'.format(qt=mark)\n      for mark in _QUOTES\n  ]))\n\n  _IDENTIFIER = re.compile(r'[^\\d\\W]\\w*')\n  _IDENTIFIER_OR_NUMBER = re.compile(r'\\w+')\n\n  def __init__(self, lines, skip_comments=True):\n    self._position = 0\n    self._line = -1\n    self._column = 0\n    self._token_start = None\n    self.token = ''\n    self._lines = iter(lines)\n    self._current_line = ''\n    self._previous_line = 0\n    self._previous_column = 0\n    self._more_lines = True\n    self._skip_comments = skip_comments\n    self._whitespace_pattern = (skip_comments and self._WHITESPACE_OR_COMMENT\n                                or self._WHITESPACE)\n    self._SkipWhitespace()\n    self.NextToken()\n\n  def LookingAt(self, token):\n    return self.token == token\n\n  def AtEnd(self):\n    \"\"\"Checks the end of the text was reached.\n\n    Returns:\n      True iff the end was reached.\n    \"\"\"\n    return not self.token\n\n  def _PopLine(self):\n    while len(self._current_line) &lt;= self._column:\n      try:\n        self._current_line = next(self._lines)\n      except StopIteration:\n        self._current_line = ''\n        self._more_lines = False\n        return\n      else:\n        self._line += 1\n        self._column = 0\n\n  def _SkipWhitespace(self):\n    while True:\n      self._PopLine()\n      match = self._whitespace_pattern.match(self._current_line, self._column)\n      if not match:\n        break\n      length = len(match.group(0))\n      self._column += length\n\n  def TryConsume(self, token):\n    \"\"\"Tries to consume a given piece of text.\n\n    Args:\n      token: Text to consume.\n\n    Returns:\n      True iff the text was consumed.\n    \"\"\"\n    if self.token == token:\n      self.NextToken()\n      return True\n    return False\n\n  def Consume(self, token):\n    \"\"\"Consumes a piece of text.\n\n    Args:\n      token: Text to consume.\n\n    Raises:\n      ParseError: If the text couldn't be consumed.\n    \"\"\"\n    if not self.TryConsume(token):\n      raise self.ParseError('Expected \"%s\".' % token)\n\n  def ConsumeComment(self):\n    result = self.token\n    if not self._COMMENT.match(result):\n      raise self.ParseError('Expected comment.')\n    self.NextToken()\n    return result\n\n  def ConsumeCommentOrTrailingComment(self):\n    \"\"\"Consumes a comment, returns a 2-tuple (trailing bool, comment str).\"\"\"\n\n    # Tokenizer initializes _previous_line and _previous_column to 0. As the\n    # tokenizer starts, it looks like there is a previous token on the line.\n    just_started = self._line == 0 and self._column == 0\n\n    before_parsing = self._previous_line\n    comment = self.ConsumeComment()\n\n    # A trailing comment is a comment on the same line than the previous token.\n    trailing = (self._previous_line == before_parsing\n                and not just_started)\n\n    return trailing, comment\n\n  def TryConsumeIdentifier(self):\n    try:\n      self.ConsumeIdentifier()\n      return True\n    except ParseError:\n      return False\n\n  def ConsumeIdentifier(self):\n    \"\"\"Consumes protocol message field identifier.\n\n    Returns:\n      Identifier string.\n\n    Raises:\n      ParseError: If an identifier couldn't be consumed.\n    \"\"\"\n    result = self.token\n    if not self._IDENTIFIER.match(result):\n      raise self.ParseError('Expected identifier.')\n    self.NextToken()\n    return result\n\n  def TryConsumeIdentifierOrNumber(self):\n    try:\n      self.ConsumeIdentifierOrNumber()\n      return True\n    except ParseError:\n      return False\n\n  def ConsumeIdentifierOrNumber(self):\n    \"\"\"Consumes protocol message field identifier.\n\n    Returns:\n      Identifier string.\n\n    Raises:\n      ParseError: If an identifier couldn't be consumed.\n    \"\"\"\n    result = self.token\n    if not self._IDENTIFIER_OR_NUMBER.match(result):\n      raise self.ParseError('Expected identifier or number, got %s.' % result)\n    self.NextToken()\n    return result\n\n  def TryConsumeInteger(self):\n    try:\n      self.ConsumeInteger()\n      return True\n    except ParseError:\n      return False\n\n  def ConsumeInteger(self):\n    \"\"\"Consumes an integer number.\n\n    Returns:\n      The integer parsed.\n\n    Raises:\n      ParseError: If an integer couldn't be consumed.\n    \"\"\"\n    try:\n      result = _ParseAbstractInteger(self.token)\n    except ValueError as e:\n      raise self.ParseError(str(e))\n    self.NextToken()\n    return result\n\n  def TryConsumeFloat(self):\n    try:\n      self.ConsumeFloat()\n      return True\n    except ParseError:\n      return False\n\n  def ConsumeFloat(self):\n    \"\"\"Consumes an floating point number.\n\n    Returns:\n      The number parsed.\n\n    Raises:\n      ParseError: If a floating point number couldn't be consumed.\n    \"\"\"\n    try:\n      result = ParseFloat(self.token)\n    except ValueError as e:\n      raise self.ParseError(str(e))\n    self.NextToken()\n    return result\n\n  def ConsumeBool(self):\n    \"\"\"Consumes a boolean value.\n\n    Returns:\n      The bool parsed.\n\n    Raises:\n      ParseError: If a boolean value couldn't be consumed.\n    \"\"\"\n    try:\n      result = ParseBool(self.token)\n    except ValueError as e:\n      raise self.ParseError(str(e))\n    self.NextToken()\n    return result\n\n  def TryConsumeByteString(self):\n    try:\n      self.ConsumeByteString()\n      return True\n    except ParseError:\n      return False\n\n  def ConsumeString(self):\n    \"\"\"Consumes a string value.\n\n    Returns:\n      The string parsed.\n\n    Raises:\n      ParseError: If a string value couldn't be consumed.\n    \"\"\"\n    the_bytes = self.ConsumeByteString()\n    try:\n      return str(the_bytes, 'utf-8')\n    except UnicodeDecodeError as e:\n      raise self._StringParseError(e)\n\n  def ConsumeByteString(self):\n    \"\"\"Consumes a byte array value.\n\n    Returns:\n      The array parsed (as a string).\n\n    Raises:\n      ParseError: If a byte array value couldn't be consumed.\n    \"\"\"\n    the_list = [self._ConsumeSingleByteString()]\n    while self.token and self.token[0] in _QUOTES:\n      the_list.append(self._ConsumeSingleByteString())\n    return b''.join(the_list)\n\n  def _ConsumeSingleByteString(self):\n    \"\"\"Consume one token of a string literal.\n\n    String literals (whether bytes or text) can come in multiple adjacent\n    tokens which are automatically concatenated, like in C or Python.  This\n    method only consumes one token.\n\n    Returns:\n      The token parsed.\n    Raises:\n      ParseError: When the wrong format data is found.\n    \"\"\"\n    text = self.token\n    if len(text) &lt; 1 or text[0] not in _QUOTES:\n      raise self.ParseError('Expected string but found: %r' % (text,))\n\n    if len(text) &lt; 2 or text[-1] != text[0]:\n      raise self.ParseError('String missing ending quote: %r' % (text,))\n\n    try:\n      result = text_encoding.CUnescape(text[1:-1])\n    except ValueError as e:\n      raise self.ParseError(str(e))\n    self.NextToken()\n    return result\n\n  def ConsumeEnum(self, field):\n    try:\n      result = ParseEnum(field, self.token)\n    except ValueError as e:\n      raise self.ParseError(str(e))\n    self.NextToken()\n    return result\n\n  def ParseErrorPreviousToken(self, message):\n    \"\"\"Creates and *returns* a ParseError for the previously read token.\n\n    Args:\n      message: A message to set for the exception.\n\n    Returns:\n      A ParseError instance.\n    \"\"\"\n    return ParseError(message, self._previous_line + 1,\n                      self._previous_column + 1)\n\n  def ParseError(self, message):\n    \"\"\"Creates and *returns* a ParseError for the current token.\"\"\"\n    return ParseError('\\'' + self._current_line + '\\': ' + message,\n                      self._line + 1, self._column + 1)\n\n  def _StringParseError(self, e):\n    return self.ParseError('Couldn\\'t parse string: ' + str(e))\n\n  def NextToken(self):\n    \"\"\"Reads the next meaningful token.\"\"\"\n    self._previous_line = self._line\n    self._previous_column = self._column\n\n    self._column += len(self.token)\n    self._SkipWhitespace()\n\n    if not self._more_lines:\n      self.token = ''\n      return\n\n    match = self._TOKEN.match(self._current_line, self._column)\n    if not match and not self._skip_comments:\n      match = self._COMMENT.match(self._current_line, self._column)\n    if match:\n      token = match.group(0)\n      self.token = token\n    else:\n      self.token = self._current_line[self._column]\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/text_format.html#client.ayon_hiero.vendor.google.protobuf.text_format.Tokenizer.AtEnd","title":"<code>AtEnd()</code>","text":"<p>Checks the end of the text was reached.</p> <p>Returns:</p> Type Description <p>True iff the end was reached.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/text_format.py</code> <pre><code>def AtEnd(self):\n  \"\"\"Checks the end of the text was reached.\n\n  Returns:\n    True iff the end was reached.\n  \"\"\"\n  return not self.token\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/text_format.html#client.ayon_hiero.vendor.google.protobuf.text_format.Tokenizer.Consume","title":"<code>Consume(token)</code>","text":"<p>Consumes a piece of text.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <p>Text to consume.</p> required <p>Raises:</p> Type Description <code>ParseError</code> <p>If the text couldn't be consumed.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/text_format.py</code> <pre><code>def Consume(self, token):\n  \"\"\"Consumes a piece of text.\n\n  Args:\n    token: Text to consume.\n\n  Raises:\n    ParseError: If the text couldn't be consumed.\n  \"\"\"\n  if not self.TryConsume(token):\n    raise self.ParseError('Expected \"%s\".' % token)\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/text_format.html#client.ayon_hiero.vendor.google.protobuf.text_format.Tokenizer.ConsumeBool","title":"<code>ConsumeBool()</code>","text":"<p>Consumes a boolean value.</p> <p>Returns:</p> Type Description <p>The bool parsed.</p> <p>Raises:</p> Type Description <code>ParseError</code> <p>If a boolean value couldn't be consumed.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/text_format.py</code> <pre><code>def ConsumeBool(self):\n  \"\"\"Consumes a boolean value.\n\n  Returns:\n    The bool parsed.\n\n  Raises:\n    ParseError: If a boolean value couldn't be consumed.\n  \"\"\"\n  try:\n    result = ParseBool(self.token)\n  except ValueError as e:\n    raise self.ParseError(str(e))\n  self.NextToken()\n  return result\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/text_format.html#client.ayon_hiero.vendor.google.protobuf.text_format.Tokenizer.ConsumeByteString","title":"<code>ConsumeByteString()</code>","text":"<p>Consumes a byte array value.</p> <p>Returns:</p> Type Description <p>The array parsed (as a string).</p> <p>Raises:</p> Type Description <code>ParseError</code> <p>If a byte array value couldn't be consumed.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/text_format.py</code> <pre><code>def ConsumeByteString(self):\n  \"\"\"Consumes a byte array value.\n\n  Returns:\n    The array parsed (as a string).\n\n  Raises:\n    ParseError: If a byte array value couldn't be consumed.\n  \"\"\"\n  the_list = [self._ConsumeSingleByteString()]\n  while self.token and self.token[0] in _QUOTES:\n    the_list.append(self._ConsumeSingleByteString())\n  return b''.join(the_list)\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/text_format.html#client.ayon_hiero.vendor.google.protobuf.text_format.Tokenizer.ConsumeCommentOrTrailingComment","title":"<code>ConsumeCommentOrTrailingComment()</code>","text":"<p>Consumes a comment, returns a 2-tuple (trailing bool, comment str).</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/text_format.py</code> <pre><code>def ConsumeCommentOrTrailingComment(self):\n  \"\"\"Consumes a comment, returns a 2-tuple (trailing bool, comment str).\"\"\"\n\n  # Tokenizer initializes _previous_line and _previous_column to 0. As the\n  # tokenizer starts, it looks like there is a previous token on the line.\n  just_started = self._line == 0 and self._column == 0\n\n  before_parsing = self._previous_line\n  comment = self.ConsumeComment()\n\n  # A trailing comment is a comment on the same line than the previous token.\n  trailing = (self._previous_line == before_parsing\n              and not just_started)\n\n  return trailing, comment\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/text_format.html#client.ayon_hiero.vendor.google.protobuf.text_format.Tokenizer.ConsumeFloat","title":"<code>ConsumeFloat()</code>","text":"<p>Consumes an floating point number.</p> <p>Returns:</p> Type Description <p>The number parsed.</p> <p>Raises:</p> Type Description <code>ParseError</code> <p>If a floating point number couldn't be consumed.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/text_format.py</code> <pre><code>def ConsumeFloat(self):\n  \"\"\"Consumes an floating point number.\n\n  Returns:\n    The number parsed.\n\n  Raises:\n    ParseError: If a floating point number couldn't be consumed.\n  \"\"\"\n  try:\n    result = ParseFloat(self.token)\n  except ValueError as e:\n    raise self.ParseError(str(e))\n  self.NextToken()\n  return result\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/text_format.html#client.ayon_hiero.vendor.google.protobuf.text_format.Tokenizer.ConsumeIdentifier","title":"<code>ConsumeIdentifier()</code>","text":"<p>Consumes protocol message field identifier.</p> <p>Returns:</p> Type Description <p>Identifier string.</p> <p>Raises:</p> Type Description <code>ParseError</code> <p>If an identifier couldn't be consumed.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/text_format.py</code> <pre><code>def ConsumeIdentifier(self):\n  \"\"\"Consumes protocol message field identifier.\n\n  Returns:\n    Identifier string.\n\n  Raises:\n    ParseError: If an identifier couldn't be consumed.\n  \"\"\"\n  result = self.token\n  if not self._IDENTIFIER.match(result):\n    raise self.ParseError('Expected identifier.')\n  self.NextToken()\n  return result\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/text_format.html#client.ayon_hiero.vendor.google.protobuf.text_format.Tokenizer.ConsumeIdentifierOrNumber","title":"<code>ConsumeIdentifierOrNumber()</code>","text":"<p>Consumes protocol message field identifier.</p> <p>Returns:</p> Type Description <p>Identifier string.</p> <p>Raises:</p> Type Description <code>ParseError</code> <p>If an identifier couldn't be consumed.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/text_format.py</code> <pre><code>def ConsumeIdentifierOrNumber(self):\n  \"\"\"Consumes protocol message field identifier.\n\n  Returns:\n    Identifier string.\n\n  Raises:\n    ParseError: If an identifier couldn't be consumed.\n  \"\"\"\n  result = self.token\n  if not self._IDENTIFIER_OR_NUMBER.match(result):\n    raise self.ParseError('Expected identifier or number, got %s.' % result)\n  self.NextToken()\n  return result\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/text_format.html#client.ayon_hiero.vendor.google.protobuf.text_format.Tokenizer.ConsumeInteger","title":"<code>ConsumeInteger()</code>","text":"<p>Consumes an integer number.</p> <p>Returns:</p> Type Description <p>The integer parsed.</p> <p>Raises:</p> Type Description <code>ParseError</code> <p>If an integer couldn't be consumed.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/text_format.py</code> <pre><code>def ConsumeInteger(self):\n  \"\"\"Consumes an integer number.\n\n  Returns:\n    The integer parsed.\n\n  Raises:\n    ParseError: If an integer couldn't be consumed.\n  \"\"\"\n  try:\n    result = _ParseAbstractInteger(self.token)\n  except ValueError as e:\n    raise self.ParseError(str(e))\n  self.NextToken()\n  return result\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/text_format.html#client.ayon_hiero.vendor.google.protobuf.text_format.Tokenizer.ConsumeString","title":"<code>ConsumeString()</code>","text":"<p>Consumes a string value.</p> <p>Returns:</p> Type Description <p>The string parsed.</p> <p>Raises:</p> Type Description <code>ParseError</code> <p>If a string value couldn't be consumed.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/text_format.py</code> <pre><code>def ConsumeString(self):\n  \"\"\"Consumes a string value.\n\n  Returns:\n    The string parsed.\n\n  Raises:\n    ParseError: If a string value couldn't be consumed.\n  \"\"\"\n  the_bytes = self.ConsumeByteString()\n  try:\n    return str(the_bytes, 'utf-8')\n  except UnicodeDecodeError as e:\n    raise self._StringParseError(e)\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/text_format.html#client.ayon_hiero.vendor.google.protobuf.text_format.Tokenizer.NextToken","title":"<code>NextToken()</code>","text":"<p>Reads the next meaningful token.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/text_format.py</code> <pre><code>def NextToken(self):\n  \"\"\"Reads the next meaningful token.\"\"\"\n  self._previous_line = self._line\n  self._previous_column = self._column\n\n  self._column += len(self.token)\n  self._SkipWhitespace()\n\n  if not self._more_lines:\n    self.token = ''\n    return\n\n  match = self._TOKEN.match(self._current_line, self._column)\n  if not match and not self._skip_comments:\n    match = self._COMMENT.match(self._current_line, self._column)\n  if match:\n    token = match.group(0)\n    self.token = token\n  else:\n    self.token = self._current_line[self._column]\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/text_format.html#client.ayon_hiero.vendor.google.protobuf.text_format.Tokenizer.ParseError","title":"<code>ParseError(message)</code>","text":"<p>Creates and returns a ParseError for the current token.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/text_format.py</code> <pre><code>def ParseError(self, message):\n  \"\"\"Creates and *returns* a ParseError for the current token.\"\"\"\n  return ParseError('\\'' + self._current_line + '\\': ' + message,\n                    self._line + 1, self._column + 1)\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/text_format.html#client.ayon_hiero.vendor.google.protobuf.text_format.Tokenizer.ParseErrorPreviousToken","title":"<code>ParseErrorPreviousToken(message)</code>","text":"<p>Creates and returns a ParseError for the previously read token.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <p>A message to set for the exception.</p> required <p>Returns:</p> Type Description <p>A ParseError instance.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/text_format.py</code> <pre><code>def ParseErrorPreviousToken(self, message):\n  \"\"\"Creates and *returns* a ParseError for the previously read token.\n\n  Args:\n    message: A message to set for the exception.\n\n  Returns:\n    A ParseError instance.\n  \"\"\"\n  return ParseError(message, self._previous_line + 1,\n                    self._previous_column + 1)\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/text_format.html#client.ayon_hiero.vendor.google.protobuf.text_format.Tokenizer.TryConsume","title":"<code>TryConsume(token)</code>","text":"<p>Tries to consume a given piece of text.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <p>Text to consume.</p> required <p>Returns:</p> Type Description <p>True iff the text was consumed.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/text_format.py</code> <pre><code>def TryConsume(self, token):\n  \"\"\"Tries to consume a given piece of text.\n\n  Args:\n    token: Text to consume.\n\n  Returns:\n    True iff the text was consumed.\n  \"\"\"\n  if self.token == token:\n    self.NextToken()\n    return True\n  return False\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/text_format.html#client.ayon_hiero.vendor.google.protobuf.text_format.Merge","title":"<code>Merge(text, message, allow_unknown_extension=False, allow_field_number=False, descriptor_pool=None, allow_unknown_field=False)</code>","text":"<p>Parses a text representation of a protocol message into a message.</p> <p>Like Parse(), but allows repeated values for a non-repeated field, and uses the last one. This means any non-repeated, top-level fields specified in text replace those in the message.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>Message text representation.</p> required <code>message</code> <code>Message</code> <p>A protocol buffer message to merge into.</p> required <code>allow_unknown_extension</code> <p>if True, skip over missing extensions and keep parsing</p> <code>False</code> <code>allow_field_number</code> <p>if True, both field number and field name are allowed.</p> <code>False</code> <code>descriptor_pool</code> <code>DescriptorPool</code> <p>Descriptor pool used to resolve Any types.</p> <code>None</code> <code>allow_unknown_field</code> <p>if True, skip over unknown field and keep parsing. Avoid to use this option if possible. It may hide some errors (e.g. spelling error on field name)</p> <code>False</code> <p>Returns:</p> Name Type Description <code>Message</code> <p>The same message passed as argument.</p> <p>Raises:</p> Type Description <code>ParseError</code> <p>On text parsing problems.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/text_format.py</code> <pre><code>def Merge(text,\n          message,\n          allow_unknown_extension=False,\n          allow_field_number=False,\n          descriptor_pool=None,\n          allow_unknown_field=False):\n  \"\"\"Parses a text representation of a protocol message into a message.\n\n  Like Parse(), but allows repeated values for a non-repeated field, and uses\n  the last one. This means any non-repeated, top-level fields specified in text\n  replace those in the message.\n\n  Args:\n    text (str): Message text representation.\n    message (Message): A protocol buffer message to merge into.\n    allow_unknown_extension: if True, skip over missing extensions and keep\n      parsing\n    allow_field_number: if True, both field number and field name are allowed.\n    descriptor_pool (DescriptorPool): Descriptor pool used to resolve Any types.\n    allow_unknown_field: if True, skip over unknown field and keep\n      parsing. Avoid to use this option if possible. It may hide some\n      errors (e.g. spelling error on field name)\n\n  Returns:\n    Message: The same message passed as argument.\n\n  Raises:\n    ParseError: On text parsing problems.\n  \"\"\"\n  return MergeLines(\n      text.split(b'\\n' if isinstance(text, bytes) else u'\\n'),\n      message,\n      allow_unknown_extension,\n      allow_field_number,\n      descriptor_pool=descriptor_pool,\n      allow_unknown_field=allow_unknown_field)\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/text_format.html#client.ayon_hiero.vendor.google.protobuf.text_format.MergeLines","title":"<code>MergeLines(lines, message, allow_unknown_extension=False, allow_field_number=False, descriptor_pool=None, allow_unknown_field=False)</code>","text":"<p>Parses a text representation of a protocol message into a message.</p> <p>See Merge() for more details.</p> <p>Parameters:</p> Name Type Description Default <code>lines</code> <p>An iterable of lines of a message's text representation.</p> required <code>message</code> <p>A protocol buffer message to merge into.</p> required <code>allow_unknown_extension</code> <p>if True, skip over missing extensions and keep parsing</p> <code>False</code> <code>allow_field_number</code> <p>if True, both field number and field name are allowed.</p> <code>False</code> <code>descriptor_pool</code> <p>A DescriptorPool used to resolve Any types.</p> <code>None</code> <code>allow_unknown_field</code> <p>if True, skip over unknown field and keep parsing. Avoid to use this option if possible. It may hide some errors (e.g. spelling error on field name)</p> <code>False</code> <p>Returns:</p> Type Description <p>The same message passed as argument.</p> <p>Raises:</p> Type Description <code>ParseError</code> <p>On text parsing problems.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/text_format.py</code> <pre><code>def MergeLines(lines,\n               message,\n               allow_unknown_extension=False,\n               allow_field_number=False,\n               descriptor_pool=None,\n               allow_unknown_field=False):\n  \"\"\"Parses a text representation of a protocol message into a message.\n\n  See Merge() for more details.\n\n  Args:\n    lines: An iterable of lines of a message's text representation.\n    message: A protocol buffer message to merge into.\n    allow_unknown_extension: if True, skip over missing extensions and keep\n      parsing\n    allow_field_number: if True, both field number and field name are allowed.\n    descriptor_pool: A DescriptorPool used to resolve Any types.\n    allow_unknown_field: if True, skip over unknown field and keep\n      parsing. Avoid to use this option if possible. It may hide some\n      errors (e.g. spelling error on field name)\n\n  Returns:\n    The same message passed as argument.\n\n  Raises:\n    ParseError: On text parsing problems.\n  \"\"\"\n  parser = _Parser(allow_unknown_extension,\n                   allow_field_number,\n                   descriptor_pool=descriptor_pool,\n                   allow_unknown_field=allow_unknown_field)\n  return parser.MergeLines(lines, message)\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/text_format.html#client.ayon_hiero.vendor.google.protobuf.text_format.MessageToBytes","title":"<code>MessageToBytes(message, **kwargs)</code>","text":"<p>Convert protobuf message to encoded text format.  See MessageToString.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/text_format.py</code> <pre><code>def MessageToBytes(message, **kwargs):\n  # type: (...) -&gt; bytes\n  \"\"\"Convert protobuf message to encoded text format.  See MessageToString.\"\"\"\n  text = MessageToString(message, **kwargs)\n  if isinstance(text, bytes):\n    return text\n  codec = 'utf-8' if kwargs.get('as_utf8') else 'ascii'\n  return text.encode(codec)\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/text_format.html#client.ayon_hiero.vendor.google.protobuf.text_format.MessageToString","title":"<code>MessageToString(message, as_utf8=False, as_one_line=False, use_short_repeated_primitives=False, pointy_brackets=False, use_index_order=False, float_format=None, double_format=None, use_field_number=False, descriptor_pool=None, indent=0, message_formatter=None, print_unknown_fields=False, force_colon=False)</code>","text":"<p>Convert protobuf message to text format.</p> <p>Double values can be formatted compactly with 15 digits of precision (which is the most that IEEE 754 \"double\" can guarantee) using double_format='.15g'. To ensure that converting to text and back to a proto will result in an identical value, double_format='.17g' should be used.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <p>The protocol buffers message.</p> required <code>as_utf8</code> <p>Return unescaped Unicode for non-ASCII characters.   In Python 3 actual Unicode characters may appear as is in strings.   In Python 2 the return value will be valid UTF-8 rather than only ASCII.</p> <code>False</code> <code>as_one_line</code> <p>Don't introduce newlines between fields.</p> <code>False</code> <code>use_short_repeated_primitives</code> <p>Use short repeated format for primitives.</p> <code>False</code> <code>pointy_brackets</code> <p>If True, use angle brackets instead of curly braces for nesting.</p> <code>False</code> <code>use_index_order</code> <p>If True, fields of a proto message will be printed using the order defined in source code instead of the field number, extensions will be printed at the end of the message and their relative order is determined by the extension number. By default, use the field number order.</p> <code>False</code> <code>float_format</code> <code>str</code> <p>If set, use this to specify float field formatting (per the \"Format Specification Mini-Language\"); otherwise, shortest float that has same value in wire will be printed. Also affect double field if double_format is not set but float_format is set.</p> <code>None</code> <code>double_format</code> <code>str</code> <p>If set, use this to specify double field formatting (per the \"Format Specification Mini-Language\"); if it is not set but float_format is set, use float_format. Otherwise, use <code>str()</code></p> <code>None</code> <code>use_field_number</code> <p>If True, print field numbers instead of names.</p> <code>False</code> <code>descriptor_pool</code> <code>DescriptorPool</code> <p>Descriptor pool used to resolve Any types.</p> <code>None</code> <code>indent</code> <code>int</code> <p>The initial indent level, in terms of spaces, for pretty print.</p> <code>0</code> <code>message_formatter</code> <code>function(message, indent, as_one_line) -&gt; unicode|None</code> <p>Custom formatter for selected sub-messages (usually based on message type). Use to pretty print parts of the protobuf for easier diffing.</p> <code>None</code> <code>print_unknown_fields</code> <p>If True, unknown fields will be printed.</p> <code>False</code> <code>force_colon</code> <p>If set, a colon will be added after the field name even if the field is a proto message.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>str</code> <p>A string of the text formatted protocol buffer message.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/text_format.py</code> <pre><code>def MessageToString(\n    message,\n    as_utf8=False,\n    as_one_line=False,\n    use_short_repeated_primitives=False,\n    pointy_brackets=False,\n    use_index_order=False,\n    float_format=None,\n    double_format=None,\n    use_field_number=False,\n    descriptor_pool=None,\n    indent=0,\n    message_formatter=None,\n    print_unknown_fields=False,\n    force_colon=False):\n  # type: (...) -&gt; str\n  \"\"\"Convert protobuf message to text format.\n\n  Double values can be formatted compactly with 15 digits of\n  precision (which is the most that IEEE 754 \"double\" can guarantee)\n  using double_format='.15g'. To ensure that converting to text and back to a\n  proto will result in an identical value, double_format='.17g' should be used.\n\n  Args:\n    message: The protocol buffers message.\n    as_utf8: Return unescaped Unicode for non-ASCII characters.\n        In Python 3 actual Unicode characters may appear as is in strings.\n        In Python 2 the return value will be valid UTF-8 rather than only ASCII.\n    as_one_line: Don't introduce newlines between fields.\n    use_short_repeated_primitives: Use short repeated format for primitives.\n    pointy_brackets: If True, use angle brackets instead of curly braces for\n      nesting.\n    use_index_order: If True, fields of a proto message will be printed using\n      the order defined in source code instead of the field number, extensions\n      will be printed at the end of the message and their relative order is\n      determined by the extension number. By default, use the field number\n      order.\n    float_format (str): If set, use this to specify float field formatting\n      (per the \"Format Specification Mini-Language\"); otherwise, shortest float\n      that has same value in wire will be printed. Also affect double field\n      if double_format is not set but float_format is set.\n    double_format (str): If set, use this to specify double field formatting\n      (per the \"Format Specification Mini-Language\"); if it is not set but\n      float_format is set, use float_format. Otherwise, use ``str()``\n    use_field_number: If True, print field numbers instead of names.\n    descriptor_pool (DescriptorPool): Descriptor pool used to resolve Any types.\n    indent (int): The initial indent level, in terms of spaces, for pretty\n      print.\n    message_formatter (function(message, indent, as_one_line) -&gt; unicode|None):\n      Custom formatter for selected sub-messages (usually based on message\n      type). Use to pretty print parts of the protobuf for easier diffing.\n    print_unknown_fields: If True, unknown fields will be printed.\n    force_colon: If set, a colon will be added after the field name even if the\n      field is a proto message.\n\n  Returns:\n    str: A string of the text formatted protocol buffer message.\n  \"\"\"\n  out = TextWriter(as_utf8)\n  printer = _Printer(\n      out,\n      indent,\n      as_utf8,\n      as_one_line,\n      use_short_repeated_primitives,\n      pointy_brackets,\n      use_index_order,\n      float_format,\n      double_format,\n      use_field_number,\n      descriptor_pool,\n      message_formatter,\n      print_unknown_fields=print_unknown_fields,\n      force_colon=force_colon)\n  printer.PrintMessage(message)\n  result = out.getvalue()\n  out.close()\n  if as_one_line:\n    return result.rstrip()\n  return result\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/text_format.html#client.ayon_hiero.vendor.google.protobuf.text_format.Parse","title":"<code>Parse(text, message, allow_unknown_extension=False, allow_field_number=False, descriptor_pool=None, allow_unknown_field=False)</code>","text":"<p>Parses a text representation of a protocol message into a message.</p> <p>NOTE: for historical reasons this function does not clear the input message. This is different from what the binary msg.ParseFrom(...) does. If text contains a field already set in message, the value is appended if the field is repeated. Otherwise, an error is raised.</p> <p>Example::</p> <p>a = MyProto()   a.repeated_field.append('test')   b = MyProto()</p> <p># Repeated fields are combined   text_format.Parse(repr(a), b)   text_format.Parse(repr(a), b) # repeated_field contains [\"test\", \"test\"]</p> <p># Non-repeated fields cannot be overwritten   a.singular_field = 1   b.singular_field = 2   text_format.Parse(repr(a), b) # ParseError</p> <p># Binary version:   b.ParseFromString(a.SerializeToString()) # repeated_field is now \"test\"</p> <p>Caller is responsible for clearing the message as needed.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>Message text representation.</p> required <code>message</code> <code>Message</code> <p>A protocol buffer message to merge into.</p> required <code>allow_unknown_extension</code> <p>if True, skip over missing extensions and keep parsing</p> <code>False</code> <code>allow_field_number</code> <p>if True, both field number and field name are allowed.</p> <code>False</code> <code>descriptor_pool</code> <code>DescriptorPool</code> <p>Descriptor pool used to resolve Any types.</p> <code>None</code> <code>allow_unknown_field</code> <p>if True, skip over unknown field and keep parsing. Avoid to use this option if possible. It may hide some errors (e.g. spelling error on field name)</p> <code>False</code> <p>Returns:</p> Name Type Description <code>Message</code> <p>The same message passed as argument.</p> <p>Raises:</p> Type Description <code>ParseError</code> <p>On text parsing problems.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/text_format.py</code> <pre><code>def Parse(text,\n          message,\n          allow_unknown_extension=False,\n          allow_field_number=False,\n          descriptor_pool=None,\n          allow_unknown_field=False):\n  \"\"\"Parses a text representation of a protocol message into a message.\n\n  NOTE: for historical reasons this function does not clear the input\n  message. This is different from what the binary msg.ParseFrom(...) does.\n  If text contains a field already set in message, the value is appended if the\n  field is repeated. Otherwise, an error is raised.\n\n  Example::\n\n    a = MyProto()\n    a.repeated_field.append('test')\n    b = MyProto()\n\n    # Repeated fields are combined\n    text_format.Parse(repr(a), b)\n    text_format.Parse(repr(a), b) # repeated_field contains [\"test\", \"test\"]\n\n    # Non-repeated fields cannot be overwritten\n    a.singular_field = 1\n    b.singular_field = 2\n    text_format.Parse(repr(a), b) # ParseError\n\n    # Binary version:\n    b.ParseFromString(a.SerializeToString()) # repeated_field is now \"test\"\n\n  Caller is responsible for clearing the message as needed.\n\n  Args:\n    text (str): Message text representation.\n    message (Message): A protocol buffer message to merge into.\n    allow_unknown_extension: if True, skip over missing extensions and keep\n      parsing\n    allow_field_number: if True, both field number and field name are allowed.\n    descriptor_pool (DescriptorPool): Descriptor pool used to resolve Any types.\n    allow_unknown_field: if True, skip over unknown field and keep\n      parsing. Avoid to use this option if possible. It may hide some\n      errors (e.g. spelling error on field name)\n\n  Returns:\n    Message: The same message passed as argument.\n\n  Raises:\n    ParseError: On text parsing problems.\n  \"\"\"\n  return ParseLines(text.split(b'\\n' if isinstance(text, bytes) else u'\\n'),\n                    message,\n                    allow_unknown_extension,\n                    allow_field_number,\n                    descriptor_pool=descriptor_pool,\n                    allow_unknown_field=allow_unknown_field)\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/text_format.html#client.ayon_hiero.vendor.google.protobuf.text_format.ParseBool","title":"<code>ParseBool(text)</code>","text":"<p>Parse a boolean value.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <p>Text to parse.</p> required <p>Returns:</p> Type Description <p>Boolean values parsed</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If text is not a valid boolean.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/text_format.py</code> <pre><code>def ParseBool(text):\n  \"\"\"Parse a boolean value.\n\n  Args:\n    text: Text to parse.\n\n  Returns:\n    Boolean values parsed\n\n  Raises:\n    ValueError: If text is not a valid boolean.\n  \"\"\"\n  if text in ('true', 't', '1', 'True'):\n    return True\n  elif text in ('false', 'f', '0', 'False'):\n    return False\n  else:\n    raise ValueError('Expected \"true\" or \"false\".')\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/text_format.html#client.ayon_hiero.vendor.google.protobuf.text_format.ParseEnum","title":"<code>ParseEnum(field, value)</code>","text":"<p>Parse an enum value.</p> <p>The value can be specified by a number (the enum value), or by a string literal (the enum name).</p> <p>Parameters:</p> Name Type Description Default <code>field</code> <p>Enum field descriptor.</p> required <code>value</code> <p>String value.</p> required <p>Returns:</p> Type Description <p>Enum value number.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the enum value could not be parsed.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/text_format.py</code> <pre><code>def ParseEnum(field, value):\n  \"\"\"Parse an enum value.\n\n  The value can be specified by a number (the enum value), or by\n  a string literal (the enum name).\n\n  Args:\n    field: Enum field descriptor.\n    value: String value.\n\n  Returns:\n    Enum value number.\n\n  Raises:\n    ValueError: If the enum value could not be parsed.\n  \"\"\"\n  enum_descriptor = field.enum_type\n  try:\n    number = int(value, 0)\n  except ValueError:\n    # Identifier.\n    enum_value = enum_descriptor.values_by_name.get(value, None)\n    if enum_value is None:\n      raise ValueError('Enum type \"%s\" has no value named %s.' %\n                       (enum_descriptor.full_name, value))\n  else:\n    # Numeric value.\n    if hasattr(field.file, 'syntax'):\n      # Attribute is checked for compatibility.\n      if field.file.syntax == 'proto3':\n        # Proto3 accept numeric unknown enums.\n        return number\n    enum_value = enum_descriptor.values_by_number.get(number, None)\n    if enum_value is None:\n      raise ValueError('Enum type \"%s\" has no value with number %d.' %\n                       (enum_descriptor.full_name, number))\n  return enum_value.number\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/text_format.html#client.ayon_hiero.vendor.google.protobuf.text_format.ParseFloat","title":"<code>ParseFloat(text)</code>","text":"<p>Parse a floating point number.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <p>Text to parse.</p> required <p>Returns:</p> Type Description <p>The number parsed.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If a floating point number couldn't be parsed.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/text_format.py</code> <pre><code>def ParseFloat(text):\n  \"\"\"Parse a floating point number.\n\n  Args:\n    text: Text to parse.\n\n  Returns:\n    The number parsed.\n\n  Raises:\n    ValueError: If a floating point number couldn't be parsed.\n  \"\"\"\n  try:\n    # Assume Python compatible syntax.\n    return float(text)\n  except ValueError:\n    # Check alternative spellings.\n    if _FLOAT_INFINITY.match(text):\n      if text[0] == '-':\n        return float('-inf')\n      else:\n        return float('inf')\n    elif _FLOAT_NAN.match(text):\n      return float('nan')\n    else:\n      # assume '1.0f' format\n      try:\n        return float(text.rstrip('f'))\n      except ValueError:\n        raise ValueError('Couldn\\'t parse float: %s' % text)\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/text_format.html#client.ayon_hiero.vendor.google.protobuf.text_format.ParseInteger","title":"<code>ParseInteger(text, is_signed=False, is_long=False)</code>","text":"<p>Parses an integer.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <p>The text to parse.</p> required <code>is_signed</code> <p>True if a signed integer must be parsed.</p> <code>False</code> <code>is_long</code> <p>True if a long integer must be parsed.</p> <code>False</code> <p>Returns:</p> Type Description <p>The integer value.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>Thrown Iff the text is not a valid integer.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/text_format.py</code> <pre><code>def ParseInteger(text, is_signed=False, is_long=False):\n  \"\"\"Parses an integer.\n\n  Args:\n    text: The text to parse.\n    is_signed: True if a signed integer must be parsed.\n    is_long: True if a long integer must be parsed.\n\n  Returns:\n    The integer value.\n\n  Raises:\n    ValueError: Thrown Iff the text is not a valid integer.\n  \"\"\"\n  # Do the actual parsing. Exception handling is propagated to caller.\n  result = _ParseAbstractInteger(text)\n\n  # Check if the integer is sane. Exceptions handled by callers.\n  checker = _INTEGER_CHECKERS[2 * int(is_long) + int(is_signed)]\n  checker.CheckValue(result)\n  return result\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/text_format.html#client.ayon_hiero.vendor.google.protobuf.text_format.ParseLines","title":"<code>ParseLines(lines, message, allow_unknown_extension=False, allow_field_number=False, descriptor_pool=None, allow_unknown_field=False)</code>","text":"<p>Parses a text representation of a protocol message into a message.</p> <p>See Parse() for caveats.</p> <p>Parameters:</p> Name Type Description Default <code>lines</code> <p>An iterable of lines of a message's text representation.</p> required <code>message</code> <p>A protocol buffer message to merge into.</p> required <code>allow_unknown_extension</code> <p>if True, skip over missing extensions and keep parsing</p> <code>False</code> <code>allow_field_number</code> <p>if True, both field number and field name are allowed.</p> <code>False</code> <code>descriptor_pool</code> <p>A DescriptorPool used to resolve Any types.</p> <code>None</code> <code>allow_unknown_field</code> <p>if True, skip over unknown field and keep parsing. Avoid to use this option if possible. It may hide some errors (e.g. spelling error on field name)</p> <code>False</code> <p>Returns:</p> Type Description <p>The same message passed as argument.</p> <p>Raises:</p> Type Description <code>ParseError</code> <p>On text parsing problems.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/text_format.py</code> <pre><code>def ParseLines(lines,\n               message,\n               allow_unknown_extension=False,\n               allow_field_number=False,\n               descriptor_pool=None,\n               allow_unknown_field=False):\n  \"\"\"Parses a text representation of a protocol message into a message.\n\n  See Parse() for caveats.\n\n  Args:\n    lines: An iterable of lines of a message's text representation.\n    message: A protocol buffer message to merge into.\n    allow_unknown_extension: if True, skip over missing extensions and keep\n      parsing\n    allow_field_number: if True, both field number and field name are allowed.\n    descriptor_pool: A DescriptorPool used to resolve Any types.\n    allow_unknown_field: if True, skip over unknown field and keep\n      parsing. Avoid to use this option if possible. It may hide some\n      errors (e.g. spelling error on field name)\n\n  Returns:\n    The same message passed as argument.\n\n  Raises:\n    ParseError: On text parsing problems.\n  \"\"\"\n  parser = _Parser(allow_unknown_extension,\n                   allow_field_number,\n                   descriptor_pool=descriptor_pool,\n                   allow_unknown_field=allow_unknown_field)\n  return parser.ParseLines(lines, message)\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/text_format.html#client.ayon_hiero.vendor.google.protobuf.text_format.PrintField","title":"<code>PrintField(field, value, out, indent=0, as_utf8=False, as_one_line=False, use_short_repeated_primitives=False, pointy_brackets=False, use_index_order=False, float_format=None, double_format=None, message_formatter=None, print_unknown_fields=False, force_colon=False)</code>","text":"<p>Print a single field name/value pair.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/text_format.py</code> <pre><code>def PrintField(field,\n               value,\n               out,\n               indent=0,\n               as_utf8=False,\n               as_one_line=False,\n               use_short_repeated_primitives=False,\n               pointy_brackets=False,\n               use_index_order=False,\n               float_format=None,\n               double_format=None,\n               message_formatter=None,\n               print_unknown_fields=False,\n               force_colon=False):\n  \"\"\"Print a single field name/value pair.\"\"\"\n  printer = _Printer(out, indent, as_utf8, as_one_line,\n                     use_short_repeated_primitives, pointy_brackets,\n                     use_index_order, float_format, double_format,\n                     message_formatter=message_formatter,\n                     print_unknown_fields=print_unknown_fields,\n                     force_colon=force_colon)\n  printer.PrintField(field, value)\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/text_format.html#client.ayon_hiero.vendor.google.protobuf.text_format.PrintFieldValue","title":"<code>PrintFieldValue(field, value, out, indent=0, as_utf8=False, as_one_line=False, use_short_repeated_primitives=False, pointy_brackets=False, use_index_order=False, float_format=None, double_format=None, message_formatter=None, print_unknown_fields=False, force_colon=False)</code>","text":"<p>Print a single field value (not including name).</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/text_format.py</code> <pre><code>def PrintFieldValue(field,\n                    value,\n                    out,\n                    indent=0,\n                    as_utf8=False,\n                    as_one_line=False,\n                    use_short_repeated_primitives=False,\n                    pointy_brackets=False,\n                    use_index_order=False,\n                    float_format=None,\n                    double_format=None,\n                    message_formatter=None,\n                    print_unknown_fields=False,\n                    force_colon=False):\n  \"\"\"Print a single field value (not including name).\"\"\"\n  printer = _Printer(out, indent, as_utf8, as_one_line,\n                     use_short_repeated_primitives, pointy_brackets,\n                     use_index_order, float_format, double_format,\n                     message_formatter=message_formatter,\n                     print_unknown_fields=print_unknown_fields,\n                     force_colon=force_colon)\n  printer.PrintFieldValue(field, value)\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/timestamp_pb2.html","title":"timestamp_pb2","text":"<p>Generated protocol buffer code.</p>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/type_pb2.html","title":"type_pb2","text":"<p>Generated protocol buffer code.</p>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/wrappers_pb2.html","title":"wrappers_pb2","text":"<p>Generated protocol buffer code.</p>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/compiler/index.html","title":"compiler","text":""},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/compiler/plugin_pb2.html","title":"plugin_pb2","text":"<p>Generated protocol buffer code.</p>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/internal/index.html","title":"internal","text":""},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/internal/_parameterized.html","title":"_parameterized","text":"<p>Adds support for parameterized tests to Python's unittest TestCase class.</p> <p>A parameterized test is a method in a test case that is invoked with different argument tuples.</p> <p>A simple example:</p> <p>class AdditionExample(parameterized.TestCase):     @parameterized.parameters(        (1, 2, 3),        (4, 5, 9),        (1, 1, 3))     def testAddition(self, op1, op2, result):       self.assertEqual(result, op1 + op2)</p> <p>Each invocation is a separate test case and properly isolated just like a normal test method, with its own setUp/tearDown cycle. In the example above, there are three separate testcases, one of which will fail due to an assertion error (1 + 1 != 3).</p> <p>Parameters for individual test cases can be tuples (with positional parameters) or dictionaries (with named parameters):</p> <p>class AdditionExample(parameterized.TestCase):     @parameterized.parameters(        {'op1': 1, 'op2': 2, 'result': 3},        {'op1': 4, 'op2': 5, 'result': 9},     )     def testAddition(self, op1, op2, result):       self.assertEqual(result, op1 + op2)</p> <p>If a parameterized test fails, the error message will show the original test name (which is modified internally) and the arguments for the specific invocation, which are part of the string returned by the shortDescription() method on test cases.</p> <p>The id method of the test, used internally by the unittest framework, is also modified to show the arguments. To make sure that test names stay the same across several invocations, object representations like</p> <p>class Foo(object):   ...  pass repr(Foo())   '&lt;main.Foo object at 0x23d8610&gt;'</p> <p>are turned into '&lt;main.Foo&gt;'. For even more descriptive names, especially in test logs, you can use the named_parameters decorator. In this case, only tuples are supported, and the first parameters has to be a string (or an object that returns an apt name when converted via str()):</p> <p>class NamedExample(parameterized.TestCase):     @parameterized.named_parameters(        ('Normal', 'aa', 'aaa', True),        ('EmptyPrefix', '', 'abc', True),        ('BothEmpty', '', '', True))     def testStartsWith(self, prefix, string, result):       self.assertEqual(result, strings.startswith(prefix))</p> <p>Named tests also have the benefit that they can be run individually from the command line:</p> <p>$ testmodule.py NamedExample.testStartsWithNormal   .</p> <p>Ran 1 test in 0.000s</p> <p>OK</p>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/internal/_parameterized.html#client.ayon_hiero.vendor.google.protobuf.internal._parameterized--parameterized-classes","title":"Parameterized Classes","text":"<p>If invocation arguments are shared across test methods in a single TestCase class, instead of decorating all test methods individually, the class itself can be decorated:</p> <p>@parameterized.parameters(     (1, 2, 3)     (4, 5, 9))   class ArithmeticTest(parameterized.TestCase):     def testAdd(self, arg1, arg2, result):       self.assertEqual(arg1 + arg2, result)</p> <pre><code>def testSubtract(self, arg2, arg2, result):\n  self.assertEqual(result - arg1, arg2)\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/internal/_parameterized.html#client.ayon_hiero.vendor.google.protobuf.internal._parameterized--inputs-from-iterables","title":"Inputs from Iterables","text":"<p>If parameters should be shared across several test cases, or are dynamically created from other sources, a single non-tuple iterable can be passed into the decorator. This iterable will be used to obtain the test cases:</p> <p>class AdditionExample(parameterized.TestCase):     @parameterized.parameters(       c.op1, c.op2, c.result for c in testcases     )     def testAddition(self, op1, op2, result):       self.assertEqual(result, op1 + op2)</p>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/internal/_parameterized.html#client.ayon_hiero.vendor.google.protobuf.internal._parameterized--single-argument-test-methods","title":"Single-Argument Test Methods","text":"<p>If a test method takes only one argument, the single argument does not need to be wrapped into a tuple:</p> <p>class NegativeNumberExample(parameterized.TestCase):     @parameterized.parameters(        -1, -3, -4, -5     )     def testIsNegative(self, arg):       self.assertTrue(IsNegative(arg))</p>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/internal/_parameterized.html#client.ayon_hiero.vendor.google.protobuf.internal._parameterized.TestCase","title":"<code>TestCase</code>","text":"<p>               Bases: <code>TestCase</code></p> <p>Base class for test cases using the parameters decorator.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/internal/_parameterized.py</code> <pre><code>class TestCase(unittest.TestCase, metaclass=TestGeneratorMetaclass):\n  \"\"\"Base class for test cases using the parameters decorator.\"\"\"\n\n  def _OriginalName(self):\n    return self._testMethodName.split(_SEPARATOR)[0]\n\n  def __str__(self):\n    return '%s (%s)' % (self._OriginalName(), _StrClass(self.__class__))\n\n  def id(self):  # pylint: disable=invalid-name\n    \"\"\"Returns the descriptive ID of the test.\n\n    This is used internally by the unittesting framework to get a name\n    for the test to be used in reports.\n\n    Returns:\n      The test id.\n    \"\"\"\n    return '%s.%s%s' % (_StrClass(self.__class__),\n                        self._OriginalName(),\n                        self._id_suffix.get(self._testMethodName, ''))\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/internal/_parameterized.html#client.ayon_hiero.vendor.google.protobuf.internal._parameterized.TestCase.id","title":"<code>id()</code>","text":"<p>Returns the descriptive ID of the test.</p> <p>This is used internally by the unittesting framework to get a name for the test to be used in reports.</p> <p>Returns:</p> Type Description <p>The test id.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/internal/_parameterized.py</code> <pre><code>def id(self):  # pylint: disable=invalid-name\n  \"\"\"Returns the descriptive ID of the test.\n\n  This is used internally by the unittesting framework to get a name\n  for the test to be used in reports.\n\n  Returns:\n    The test id.\n  \"\"\"\n  return '%s.%s%s' % (_StrClass(self.__class__),\n                      self._OriginalName(),\n                      self._id_suffix.get(self._testMethodName, ''))\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/internal/_parameterized.html#client.ayon_hiero.vendor.google.protobuf.internal._parameterized.TestGeneratorMetaclass","title":"<code>TestGeneratorMetaclass</code>","text":"<p>               Bases: <code>type</code></p> <p>Metaclass for test cases with test generators.</p> <p>A test generator is an iterable in a testcase that produces callables. These callables must be single-argument methods. These methods are injected into the class namespace and the original iterable is removed. If the name of the iterable conforms to the test pattern, the injected methods will be picked up as tests by the unittest framework.</p> <p>In general, it is supposed to be used in conjunction with the parameters decorator.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/internal/_parameterized.py</code> <pre><code>class TestGeneratorMetaclass(type):\n  \"\"\"Metaclass for test cases with test generators.\n\n  A test generator is an iterable in a testcase that produces callables. These\n  callables must be single-argument methods. These methods are injected into\n  the class namespace and the original iterable is removed. If the name of the\n  iterable conforms to the test pattern, the injected methods will be picked\n  up as tests by the unittest framework.\n\n  In general, it is supposed to be used in conjunction with the\n  parameters decorator.\n  \"\"\"\n\n  def __new__(mcs, class_name, bases, dct):\n    dct['_id_suffix'] = id_suffix = {}\n    for name, obj in dct.copy().items():\n      if (name.startswith(unittest.TestLoader.testMethodPrefix) and\n          _NonStringIterable(obj)):\n        iterator = iter(obj)\n        dct.pop(name)\n        _UpdateClassDictForParamTestCase(dct, id_suffix, name, iterator)\n\n    return type.__new__(mcs, class_name, bases, dct)\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/internal/_parameterized.html#client.ayon_hiero.vendor.google.protobuf.internal._parameterized.CoopTestCase","title":"<code>CoopTestCase(other_base_class)</code>","text":"<p>Returns a new base class with a cooperative metaclass base.</p> <p>This enables the TestCase to be used in combination with other base classes that have custom metaclasses, such as mox.MoxTestBase.</p> <p>Only works with metaclasses that do not override type.new.</p> <p>Example:</p> <p>import google3   import mox</p> <p>from google3.testing.pybase import parameterized</p> <p>class ExampleTest(parameterized.CoopTestCase(mox.MoxTestBase)):     ...</p> <p>Parameters:</p> Name Type Description Default <code>other_base_class</code> <p>(class) A test case base class.</p> required <p>Returns:</p> Type Description <p>A new class object.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/internal/_parameterized.py</code> <pre><code>def CoopTestCase(other_base_class):\n  \"\"\"Returns a new base class with a cooperative metaclass base.\n\n  This enables the TestCase to be used in combination\n  with other base classes that have custom metaclasses, such as\n  mox.MoxTestBase.\n\n  Only works with metaclasses that do not override type.__new__.\n\n  Example:\n\n    import google3\n    import mox\n\n    from google3.testing.pybase import parameterized\n\n    class ExampleTest(parameterized.CoopTestCase(mox.MoxTestBase)):\n      ...\n\n  Args:\n    other_base_class: (class) A test case base class.\n\n  Returns:\n    A new class object.\n  \"\"\"\n  metaclass = type(\n      'CoopMetaclass',\n      (other_base_class.__metaclass__,\n       TestGeneratorMetaclass), {})\n  return metaclass(\n      'CoopTestCase',\n      (other_base_class, TestCase), {})\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/internal/_parameterized.html#client.ayon_hiero.vendor.google.protobuf.internal._parameterized.named_parameters","title":"<code>named_parameters(*testcases)</code>","text":"<p>A decorator for creating parameterized tests.</p> <p>See the module docstring for a usage example. The first element of each parameter tuple should be a string and will be appended to the name of the test method.</p> <p>Parameters:</p> Name Type Description Default <code>*testcases</code> <p>Parameters for the decorated method, either a single           iterable, or a list of tuples.</p> <code>()</code> <p>Returns:</p> Type Description <p>A test generator to be handled by TestGeneratorMetaclass.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/internal/_parameterized.py</code> <pre><code>def named_parameters(*testcases):  # pylint: disable=invalid-name\n  \"\"\"A decorator for creating parameterized tests.\n\n  See the module docstring for a usage example. The first element of\n  each parameter tuple should be a string and will be appended to the\n  name of the test method.\n\n  Args:\n    *testcases: Parameters for the decorated method, either a single\n                iterable, or a list of tuples.\n\n  Returns:\n     A test generator to be handled by TestGeneratorMetaclass.\n  \"\"\"\n  return _ParameterDecorator(_FIRST_ARG, testcases)\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/internal/_parameterized.html#client.ayon_hiero.vendor.google.protobuf.internal._parameterized.parameters","title":"<code>parameters(*testcases)</code>","text":"<p>A decorator for creating parameterized tests.</p> <p>See the module docstring for a usage example. Args:   *testcases: Parameters for the decorated method, either a single               iterable, or a list of tuples/dicts/objects (for tests               with only one argument).</p> <p>Returns:</p> Type Description <p>A test generator to be handled by TestGeneratorMetaclass.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/internal/_parameterized.py</code> <pre><code>def parameters(*testcases):  # pylint: disable=invalid-name\n  \"\"\"A decorator for creating parameterized tests.\n\n  See the module docstring for a usage example.\n  Args:\n    *testcases: Parameters for the decorated method, either a single\n                iterable, or a list of tuples/dicts/objects (for tests\n                with only one argument).\n\n  Returns:\n     A test generator to be handled by TestGeneratorMetaclass.\n  \"\"\"\n  return _ParameterDecorator(_ARGUMENT_REPR, testcases)\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/internal/api_implementation.html","title":"api_implementation","text":"<p>Determine which implementation of the protobuf API is used in this process.</p>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/internal/builder.html","title":"builder","text":"<p>Builds descriptors, message classes and services for generated _pb2.py.</p> <p>This file is only called in python generated _pb2.py files. It builds descriptors, message classes and services that users can directly use in generated code.</p>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/internal/builder.html#client.ayon_hiero.vendor.google.protobuf.internal.builder.BuildMessageAndEnumDescriptors","title":"<code>BuildMessageAndEnumDescriptors(file_des, module)</code>","text":"<p>Builds message and enum descriptors.</p> <p>Parameters:</p> Name Type Description Default <code>file_des</code> <p>FileDescriptor of the .proto file</p> required <code>module</code> <p>Generated _pb2 module</p> required Source code in <code>client/ayon_hiero/vendor/google/protobuf/internal/builder.py</code> <pre><code>def BuildMessageAndEnumDescriptors(file_des, module):\n  \"\"\"Builds message and enum descriptors.\n\n  Args:\n    file_des: FileDescriptor of the .proto file\n    module: Generated _pb2 module\n  \"\"\"\n\n  def BuildNestedDescriptors(msg_des, prefix):\n    for (name, nested_msg) in msg_des.nested_types_by_name.items():\n      module_name = prefix + name.upper()\n      module[module_name] = nested_msg\n      BuildNestedDescriptors(nested_msg, module_name + '_')\n    for enum_des in msg_des.enum_types:\n      module[prefix + enum_des.name.upper()] = enum_des\n\n  for (name, msg_des) in file_des.message_types_by_name.items():\n    module_name = '_' + name.upper()\n    module[module_name] = msg_des\n    BuildNestedDescriptors(msg_des, module_name + '_')\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/internal/builder.html#client.ayon_hiero.vendor.google.protobuf.internal.builder.BuildServices","title":"<code>BuildServices(file_des, module_name, module)</code>","text":"<p>Builds services classes and services stub class.</p> <p>Parameters:</p> Name Type Description Default <code>file_des</code> <p>FileDescriptor of the .proto file</p> required <code>module_name</code> <p>str, the name of generated _pb2 module</p> required <code>module</code> <p>Generated _pb2 module</p> required Source code in <code>client/ayon_hiero/vendor/google/protobuf/internal/builder.py</code> <pre><code>def BuildServices(file_des, module_name, module):\n  \"\"\"Builds services classes and services stub class.\n\n  Args:\n    file_des: FileDescriptor of the .proto file\n    module_name: str, the name of generated _pb2 module\n    module: Generated _pb2 module\n  \"\"\"\n  # pylint: disable=g-import-not-at-top\n  from google.protobuf import service as _service\n  from google.protobuf import service_reflection\n  # pylint: enable=g-import-not-at-top\n  for (name, service) in file_des.services_by_name.items():\n    module[name] = service_reflection.GeneratedServiceType(\n        name, (_service.Service,),\n        dict(DESCRIPTOR=service, __module__=module_name))\n    stub_name = name + '_Stub'\n    module[stub_name] = service_reflection.GeneratedServiceStubType(\n        stub_name, (module[name],),\n        dict(DESCRIPTOR=service, __module__=module_name))\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/internal/builder.html#client.ayon_hiero.vendor.google.protobuf.internal.builder.BuildTopDescriptorsAndMessages","title":"<code>BuildTopDescriptorsAndMessages(file_des, module_name, module)</code>","text":"<p>Builds top level descriptors and message classes.</p> <p>Parameters:</p> Name Type Description Default <code>file_des</code> <p>FileDescriptor of the .proto file</p> required <code>module_name</code> <p>str, the name of generated _pb2 module</p> required <code>module</code> <p>Generated _pb2 module</p> required Source code in <code>client/ayon_hiero/vendor/google/protobuf/internal/builder.py</code> <pre><code>def BuildTopDescriptorsAndMessages(file_des, module_name, module):\n  \"\"\"Builds top level descriptors and message classes.\n\n  Args:\n    file_des: FileDescriptor of the .proto file\n    module_name: str, the name of generated _pb2 module\n    module: Generated _pb2 module\n  \"\"\"\n\n  def BuildMessage(msg_des):\n    create_dict = {}\n    for (name, nested_msg) in msg_des.nested_types_by_name.items():\n      create_dict[name] = BuildMessage(nested_msg)\n    create_dict['DESCRIPTOR'] = msg_des\n    create_dict['__module__'] = module_name\n    message_class = _reflection.GeneratedProtocolMessageType(\n        msg_des.name, (_message.Message,), create_dict)\n    _sym_db.RegisterMessage(message_class)\n    return message_class\n\n  # top level enums\n  for (name, enum_des) in file_des.enum_types_by_name.items():\n    module['_' + name.upper()] = enum_des\n    module[name] = enum_type_wrapper.EnumTypeWrapper(enum_des)\n    for enum_value in enum_des.values:\n      module[enum_value.name] = enum_value.number\n\n  # top level extensions\n  for (name, extension_des) in file_des.extensions_by_name.items():\n    module[name.upper() + '_FIELD_NUMBER'] = extension_des.number\n    module[name] = extension_des\n\n  # services\n  for (name, service) in file_des.services_by_name.items():\n    module['_' + name.upper()] = service\n\n  # Build messages.\n  for (name, msg_des) in file_des.message_types_by_name.items():\n    module[name] = BuildMessage(msg_des)\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/internal/containers.html","title":"containers","text":"<p>Contains container classes to represent different protocol buffer types.</p> <p>This file defines container classes which represent categories of protocol buffer field types which need extra maintenance. Currently these categories are:</p> <ul> <li>Repeated scalar fields - These are all repeated fields which aren't     composite (e.g. they are of simple types like int32, string, etc).</li> <li>Repeated composite fields - Repeated fields which are composite. This     includes groups and nested messages.</li> </ul>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/internal/containers.html#client.ayon_hiero.vendor.google.protobuf.internal.containers.BaseContainer","title":"<code>BaseContainer</code>","text":"<p>               Bases: <code>Sequence[_T]</code></p> <p>Base container class.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/internal/containers.py</code> <pre><code>class BaseContainer(Sequence[_T]):\n  \"\"\"Base container class.\"\"\"\n\n  # Minimizes memory usage and disallows assignment to other attributes.\n  __slots__ = ['_message_listener', '_values']\n\n  def __init__(self, message_listener: Any) -&gt; None:\n    \"\"\"\n    Args:\n      message_listener: A MessageListener implementation.\n        The RepeatedScalarFieldContainer will call this object's\n        Modified() method when it is modified.\n    \"\"\"\n    self._message_listener = message_listener\n    self._values = []\n\n  @overload\n  def __getitem__(self, key: int) -&gt; _T:\n    ...\n\n  @overload\n  def __getitem__(self, key: slice) -&gt; List[_T]:\n    ...\n\n  def __getitem__(self, key):\n    \"\"\"Retrieves item by the specified key.\"\"\"\n    return self._values[key]\n\n  def __len__(self) -&gt; int:\n    \"\"\"Returns the number of elements in the container.\"\"\"\n    return len(self._values)\n\n  def __ne__(self, other: Any) -&gt; bool:\n    \"\"\"Checks if another instance isn't equal to this one.\"\"\"\n    # The concrete classes should define __eq__.\n    return not self == other\n\n  __hash__ = None\n\n  def __repr__(self) -&gt; str:\n    return repr(self._values)\n\n  def sort(self, *args, **kwargs) -&gt; None:\n    # Continue to support the old sort_function keyword argument.\n    # This is expected to be a rare occurrence, so use LBYL to avoid\n    # the overhead of actually catching KeyError.\n    if 'sort_function' in kwargs:\n      kwargs['cmp'] = kwargs.pop('sort_function')\n    self._values.sort(*args, **kwargs)\n\n  def reverse(self) -&gt; None:\n    self._values.reverse()\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/internal/containers.html#client.ayon_hiero.vendor.google.protobuf.internal.containers.BaseContainer.__getitem__","title":"<code>__getitem__(key)</code>","text":"<pre><code>__getitem__(key: int) -&gt; _T\n</code></pre><pre><code>__getitem__(key: slice) -&gt; List[_T]\n</code></pre> <p>Retrieves item by the specified key.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/internal/containers.py</code> <pre><code>def __getitem__(self, key):\n  \"\"\"Retrieves item by the specified key.\"\"\"\n  return self._values[key]\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/internal/containers.html#client.ayon_hiero.vendor.google.protobuf.internal.containers.BaseContainer.__init__","title":"<code>__init__(message_listener)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>message_listener</code> <code>Any</code> <p>A MessageListener implementation. The RepeatedScalarFieldContainer will call this object's Modified() method when it is modified.</p> required Source code in <code>client/ayon_hiero/vendor/google/protobuf/internal/containers.py</code> <pre><code>def __init__(self, message_listener: Any) -&gt; None:\n  \"\"\"\n  Args:\n    message_listener: A MessageListener implementation.\n      The RepeatedScalarFieldContainer will call this object's\n      Modified() method when it is modified.\n  \"\"\"\n  self._message_listener = message_listener\n  self._values = []\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/internal/containers.html#client.ayon_hiero.vendor.google.protobuf.internal.containers.BaseContainer.__len__","title":"<code>__len__()</code>","text":"<p>Returns the number of elements in the container.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/internal/containers.py</code> <pre><code>def __len__(self) -&gt; int:\n  \"\"\"Returns the number of elements in the container.\"\"\"\n  return len(self._values)\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/internal/containers.html#client.ayon_hiero.vendor.google.protobuf.internal.containers.BaseContainer.__ne__","title":"<code>__ne__(other)</code>","text":"<p>Checks if another instance isn't equal to this one.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/internal/containers.py</code> <pre><code>def __ne__(self, other: Any) -&gt; bool:\n  \"\"\"Checks if another instance isn't equal to this one.\"\"\"\n  # The concrete classes should define __eq__.\n  return not self == other\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/internal/containers.html#client.ayon_hiero.vendor.google.protobuf.internal.containers.MessageMap","title":"<code>MessageMap</code>","text":"<p>               Bases: <code>MutableMapping[_K, _V]</code></p> <p>Simple, type-checked, dict-like container for with submessage values.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/internal/containers.py</code> <pre><code>class MessageMap(MutableMapping[_K, _V]):\n  \"\"\"Simple, type-checked, dict-like container for with submessage values.\"\"\"\n\n  # Disallows assignment to other attributes.\n  __slots__ = ['_key_checker', '_values', '_message_listener',\n               '_message_descriptor', '_entry_descriptor']\n\n  def __init__(\n      self,\n      message_listener: Any,\n      message_descriptor: Any,\n      key_checker: Any,\n      entry_descriptor: Any,\n  ) -&gt; None:\n    \"\"\"\n    Args:\n      message_listener: A MessageListener implementation.\n        The ScalarMap will call this object's Modified() method when it\n        is modified.\n      key_checker: A type_checkers.ValueChecker instance to run on keys\n        inserted into this container.\n      value_checker: A type_checkers.ValueChecker instance to run on values\n        inserted into this container.\n      entry_descriptor: The MessageDescriptor of a map entry: key and value.\n    \"\"\"\n    self._message_listener = message_listener\n    self._message_descriptor = message_descriptor\n    self._key_checker = key_checker\n    self._entry_descriptor = entry_descriptor\n    self._values = {}\n\n  def __getitem__(self, key: _K) -&gt; _V:\n    key = self._key_checker.CheckValue(key)\n    try:\n      return self._values[key]\n    except KeyError:\n      new_element = self._message_descriptor._concrete_class()\n      new_element._SetListener(self._message_listener)\n      self._values[key] = new_element\n      self._message_listener.Modified()\n      return new_element\n\n  def get_or_create(self, key: _K) -&gt; _V:\n    \"\"\"get_or_create() is an alias for getitem (ie. map[key]).\n\n    Args:\n      key: The key to get or create in the map.\n\n    This is useful in cases where you want to be explicit that the call is\n    mutating the map.  This can avoid lint errors for statements like this\n    that otherwise would appear to be pointless statements:\n\n      msg.my_map[key]\n    \"\"\"\n    return self[key]\n\n  @overload\n  def get(self, key: _K) -&gt; Optional[_V]:\n    ...\n\n  @overload\n  def get(self, key: _K, default: _T) -&gt; Union[_V, _T]:\n    ...\n\n  # We need to override this explicitly, because our defaultdict-like behavior\n  # will make the default implementation (from our base class) always insert\n  # the key.\n  def get(self, key, default=None):\n    if key in self:\n      return self[key]\n    else:\n      return default\n\n  def __contains__(self, item: _K) -&gt; bool:\n    item = self._key_checker.CheckValue(item)\n    return item in self._values\n\n  def __setitem__(self, key: _K, value: _V) -&gt; NoReturn:\n    raise ValueError('May not set values directly, call my_map[key].foo = 5')\n\n  def __delitem__(self, key: _K) -&gt; None:\n    key = self._key_checker.CheckValue(key)\n    del self._values[key]\n    self._message_listener.Modified()\n\n  def __len__(self) -&gt; int:\n    return len(self._values)\n\n  def __iter__(self) -&gt; Iterator[_K]:\n    return iter(self._values)\n\n  def __repr__(self) -&gt; str:\n    return repr(self._values)\n\n  def MergeFrom(self, other: 'MessageMap[_K, _V]') -&gt; None:\n    # pylint: disable=protected-access\n    for key in other._values:\n      # According to documentation: \"When parsing from the wire or when merging,\n      # if there are duplicate map keys the last key seen is used\".\n      if key in self:\n        del self[key]\n      self[key].CopyFrom(other[key])\n    # self._message_listener.Modified() not required here, because\n    # mutations to submessages already propagate.\n\n  def InvalidateIterators(self) -&gt; None:\n    # It appears that the only way to reliably invalidate iterators to\n    # self._values is to ensure that its size changes.\n    original = self._values\n    self._values = original.copy()\n    original[None] = None\n\n  # This is defined in the abstract base, but we can do it much more cheaply.\n  def clear(self) -&gt; None:\n    self._values.clear()\n    self._message_listener.Modified()\n\n  def GetEntryClass(self) -&gt; Any:\n    return self._entry_descriptor._concrete_class\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/internal/containers.html#client.ayon_hiero.vendor.google.protobuf.internal.containers.MessageMap.__init__","title":"<code>__init__(message_listener, message_descriptor, key_checker, entry_descriptor)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>message_listener</code> <code>Any</code> <p>A MessageListener implementation. The ScalarMap will call this object's Modified() method when it is modified.</p> required <code>key_checker</code> <code>Any</code> <p>A type_checkers.ValueChecker instance to run on keys inserted into this container.</p> required <code>value_checker</code> <p>A type_checkers.ValueChecker instance to run on values inserted into this container.</p> required <code>entry_descriptor</code> <code>Any</code> <p>The MessageDescriptor of a map entry: key and value.</p> required Source code in <code>client/ayon_hiero/vendor/google/protobuf/internal/containers.py</code> <pre><code>def __init__(\n    self,\n    message_listener: Any,\n    message_descriptor: Any,\n    key_checker: Any,\n    entry_descriptor: Any,\n) -&gt; None:\n  \"\"\"\n  Args:\n    message_listener: A MessageListener implementation.\n      The ScalarMap will call this object's Modified() method when it\n      is modified.\n    key_checker: A type_checkers.ValueChecker instance to run on keys\n      inserted into this container.\n    value_checker: A type_checkers.ValueChecker instance to run on values\n      inserted into this container.\n    entry_descriptor: The MessageDescriptor of a map entry: key and value.\n  \"\"\"\n  self._message_listener = message_listener\n  self._message_descriptor = message_descriptor\n  self._key_checker = key_checker\n  self._entry_descriptor = entry_descriptor\n  self._values = {}\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/internal/containers.html#client.ayon_hiero.vendor.google.protobuf.internal.containers.MessageMap.get_or_create","title":"<code>get_or_create(key)</code>","text":"<p>get_or_create() is an alias for getitem (ie. map[key]).</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>_K</code> <p>The key to get or create in the map.</p> required <p>This is useful in cases where you want to be explicit that the call is mutating the map.  This can avoid lint errors for statements like this that otherwise would appear to be pointless statements:</p> <p>msg.my_map[key]</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/internal/containers.py</code> <pre><code>def get_or_create(self, key: _K) -&gt; _V:\n  \"\"\"get_or_create() is an alias for getitem (ie. map[key]).\n\n  Args:\n    key: The key to get or create in the map.\n\n  This is useful in cases where you want to be explicit that the call is\n  mutating the map.  This can avoid lint errors for statements like this\n  that otherwise would appear to be pointless statements:\n\n    msg.my_map[key]\n  \"\"\"\n  return self[key]\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/internal/containers.html#client.ayon_hiero.vendor.google.protobuf.internal.containers.RepeatedCompositeFieldContainer","title":"<code>RepeatedCompositeFieldContainer</code>","text":"<p>               Bases: <code>BaseContainer[_T]</code>, <code>MutableSequence[_T]</code></p> <p>Simple, list-like container for holding repeated composite fields.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/internal/containers.py</code> <pre><code>class RepeatedCompositeFieldContainer(BaseContainer[_T], MutableSequence[_T]):\n  \"\"\"Simple, list-like container for holding repeated composite fields.\"\"\"\n\n  # Disallows assignment to other attributes.\n  __slots__ = ['_message_descriptor']\n\n  def __init__(self, message_listener: Any, message_descriptor: Any) -&gt; None:\n    \"\"\"\n    Note that we pass in a descriptor instead of the generated directly,\n    since at the time we construct a _RepeatedCompositeFieldContainer we\n    haven't yet necessarily initialized the type that will be contained in the\n    container.\n\n    Args:\n      message_listener: A MessageListener implementation.\n        The RepeatedCompositeFieldContainer will call this object's\n        Modified() method when it is modified.\n      message_descriptor: A Descriptor instance describing the protocol type\n        that should be present in this container.  We'll use the\n        _concrete_class field of this descriptor when the client calls add().\n    \"\"\"\n    super().__init__(message_listener)\n    self._message_descriptor = message_descriptor\n\n  def add(self, **kwargs: Any) -&gt; _T:\n    \"\"\"Adds a new element at the end of the list and returns it. Keyword\n    arguments may be used to initialize the element.\n    \"\"\"\n    new_element = self._message_descriptor._concrete_class(**kwargs)\n    new_element._SetListener(self._message_listener)\n    self._values.append(new_element)\n    if not self._message_listener.dirty:\n      self._message_listener.Modified()\n    return new_element\n\n  def append(self, value: _T) -&gt; None:\n    \"\"\"Appends one element by copying the message.\"\"\"\n    new_element = self._message_descriptor._concrete_class()\n    new_element._SetListener(self._message_listener)\n    new_element.CopyFrom(value)\n    self._values.append(new_element)\n    if not self._message_listener.dirty:\n      self._message_listener.Modified()\n\n  def insert(self, key: int, value: _T) -&gt; None:\n    \"\"\"Inserts the item at the specified position by copying.\"\"\"\n    new_element = self._message_descriptor._concrete_class()\n    new_element._SetListener(self._message_listener)\n    new_element.CopyFrom(value)\n    self._values.insert(key, new_element)\n    if not self._message_listener.dirty:\n      self._message_listener.Modified()\n\n  def extend(self, elem_seq: Iterable[_T]) -&gt; None:\n    \"\"\"Extends by appending the given sequence of elements of the same type\n\n    as this one, copying each individual message.\n    \"\"\"\n    message_class = self._message_descriptor._concrete_class\n    listener = self._message_listener\n    values = self._values\n    for message in elem_seq:\n      new_element = message_class()\n      new_element._SetListener(listener)\n      new_element.MergeFrom(message)\n      values.append(new_element)\n    listener.Modified()\n\n  def MergeFrom(\n      self,\n      other: Union['RepeatedCompositeFieldContainer[_T]', Iterable[_T]],\n  ) -&gt; None:\n    \"\"\"Appends the contents of another repeated field of the same type to this\n    one, copying each individual message.\n    \"\"\"\n    self.extend(other)\n\n  def remove(self, elem: _T) -&gt; None:\n    \"\"\"Removes an item from the list. Similar to list.remove().\"\"\"\n    self._values.remove(elem)\n    self._message_listener.Modified()\n\n  def pop(self, key: Optional[int] = -1) -&gt; _T:\n    \"\"\"Removes and returns an item at a given index. Similar to list.pop().\"\"\"\n    value = self._values[key]\n    self.__delitem__(key)\n    return value\n\n  @overload\n  def __setitem__(self, key: int, value: _T) -&gt; None:\n    ...\n\n  @overload\n  def __setitem__(self, key: slice, value: Iterable[_T]) -&gt; None:\n    ...\n\n  def __setitem__(self, key, value):\n    # This method is implemented to make RepeatedCompositeFieldContainer\n    # structurally compatible with typing.MutableSequence. It is\n    # otherwise unsupported and will always raise an error.\n    raise TypeError(\n        f'{self.__class__.__name__} object does not support item assignment')\n\n  def __delitem__(self, key: Union[int, slice]) -&gt; None:\n    \"\"\"Deletes the item at the specified position.\"\"\"\n    del self._values[key]\n    self._message_listener.Modified()\n\n  def __eq__(self, other: Any) -&gt; bool:\n    \"\"\"Compares the current instance with another one.\"\"\"\n    if self is other:\n      return True\n    if not isinstance(other, self.__class__):\n      raise TypeError('Can only compare repeated composite fields against '\n                      'other repeated composite fields.')\n    return self._values == other._values\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/internal/containers.html#client.ayon_hiero.vendor.google.protobuf.internal.containers.RepeatedCompositeFieldContainer.MergeFrom","title":"<code>MergeFrom(other)</code>","text":"<p>Appends the contents of another repeated field of the same type to this one, copying each individual message.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/internal/containers.py</code> <pre><code>def MergeFrom(\n    self,\n    other: Union['RepeatedCompositeFieldContainer[_T]', Iterable[_T]],\n) -&gt; None:\n  \"\"\"Appends the contents of another repeated field of the same type to this\n  one, copying each individual message.\n  \"\"\"\n  self.extend(other)\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/internal/containers.html#client.ayon_hiero.vendor.google.protobuf.internal.containers.RepeatedCompositeFieldContainer.__delitem__","title":"<code>__delitem__(key)</code>","text":"<p>Deletes the item at the specified position.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/internal/containers.py</code> <pre><code>def __delitem__(self, key: Union[int, slice]) -&gt; None:\n  \"\"\"Deletes the item at the specified position.\"\"\"\n  del self._values[key]\n  self._message_listener.Modified()\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/internal/containers.html#client.ayon_hiero.vendor.google.protobuf.internal.containers.RepeatedCompositeFieldContainer.__eq__","title":"<code>__eq__(other)</code>","text":"<p>Compares the current instance with another one.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/internal/containers.py</code> <pre><code>def __eq__(self, other: Any) -&gt; bool:\n  \"\"\"Compares the current instance with another one.\"\"\"\n  if self is other:\n    return True\n  if not isinstance(other, self.__class__):\n    raise TypeError('Can only compare repeated composite fields against '\n                    'other repeated composite fields.')\n  return self._values == other._values\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/internal/containers.html#client.ayon_hiero.vendor.google.protobuf.internal.containers.RepeatedCompositeFieldContainer.__init__","title":"<code>__init__(message_listener, message_descriptor)</code>","text":"<p>Note that we pass in a descriptor instead of the generated directly, since at the time we construct a _RepeatedCompositeFieldContainer we haven't yet necessarily initialized the type that will be contained in the container.</p> <p>Parameters:</p> Name Type Description Default <code>message_listener</code> <code>Any</code> <p>A MessageListener implementation. The RepeatedCompositeFieldContainer will call this object's Modified() method when it is modified.</p> required <code>message_descriptor</code> <code>Any</code> <p>A Descriptor instance describing the protocol type that should be present in this container.  We'll use the _concrete_class field of this descriptor when the client calls add().</p> required Source code in <code>client/ayon_hiero/vendor/google/protobuf/internal/containers.py</code> <pre><code>def __init__(self, message_listener: Any, message_descriptor: Any) -&gt; None:\n  \"\"\"\n  Note that we pass in a descriptor instead of the generated directly,\n  since at the time we construct a _RepeatedCompositeFieldContainer we\n  haven't yet necessarily initialized the type that will be contained in the\n  container.\n\n  Args:\n    message_listener: A MessageListener implementation.\n      The RepeatedCompositeFieldContainer will call this object's\n      Modified() method when it is modified.\n    message_descriptor: A Descriptor instance describing the protocol type\n      that should be present in this container.  We'll use the\n      _concrete_class field of this descriptor when the client calls add().\n  \"\"\"\n  super().__init__(message_listener)\n  self._message_descriptor = message_descriptor\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/internal/containers.html#client.ayon_hiero.vendor.google.protobuf.internal.containers.RepeatedCompositeFieldContainer.add","title":"<code>add(**kwargs)</code>","text":"<p>Adds a new element at the end of the list and returns it. Keyword arguments may be used to initialize the element.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/internal/containers.py</code> <pre><code>def add(self, **kwargs: Any) -&gt; _T:\n  \"\"\"Adds a new element at the end of the list and returns it. Keyword\n  arguments may be used to initialize the element.\n  \"\"\"\n  new_element = self._message_descriptor._concrete_class(**kwargs)\n  new_element._SetListener(self._message_listener)\n  self._values.append(new_element)\n  if not self._message_listener.dirty:\n    self._message_listener.Modified()\n  return new_element\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/internal/containers.html#client.ayon_hiero.vendor.google.protobuf.internal.containers.RepeatedCompositeFieldContainer.append","title":"<code>append(value)</code>","text":"<p>Appends one element by copying the message.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/internal/containers.py</code> <pre><code>def append(self, value: _T) -&gt; None:\n  \"\"\"Appends one element by copying the message.\"\"\"\n  new_element = self._message_descriptor._concrete_class()\n  new_element._SetListener(self._message_listener)\n  new_element.CopyFrom(value)\n  self._values.append(new_element)\n  if not self._message_listener.dirty:\n    self._message_listener.Modified()\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/internal/containers.html#client.ayon_hiero.vendor.google.protobuf.internal.containers.RepeatedCompositeFieldContainer.extend","title":"<code>extend(elem_seq)</code>","text":"<p>Extends by appending the given sequence of elements of the same type</p> <p>as this one, copying each individual message.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/internal/containers.py</code> <pre><code>def extend(self, elem_seq: Iterable[_T]) -&gt; None:\n  \"\"\"Extends by appending the given sequence of elements of the same type\n\n  as this one, copying each individual message.\n  \"\"\"\n  message_class = self._message_descriptor._concrete_class\n  listener = self._message_listener\n  values = self._values\n  for message in elem_seq:\n    new_element = message_class()\n    new_element._SetListener(listener)\n    new_element.MergeFrom(message)\n    values.append(new_element)\n  listener.Modified()\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/internal/containers.html#client.ayon_hiero.vendor.google.protobuf.internal.containers.RepeatedCompositeFieldContainer.insert","title":"<code>insert(key, value)</code>","text":"<p>Inserts the item at the specified position by copying.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/internal/containers.py</code> <pre><code>def insert(self, key: int, value: _T) -&gt; None:\n  \"\"\"Inserts the item at the specified position by copying.\"\"\"\n  new_element = self._message_descriptor._concrete_class()\n  new_element._SetListener(self._message_listener)\n  new_element.CopyFrom(value)\n  self._values.insert(key, new_element)\n  if not self._message_listener.dirty:\n    self._message_listener.Modified()\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/internal/containers.html#client.ayon_hiero.vendor.google.protobuf.internal.containers.RepeatedCompositeFieldContainer.pop","title":"<code>pop(key=-1)</code>","text":"<p>Removes and returns an item at a given index. Similar to list.pop().</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/internal/containers.py</code> <pre><code>def pop(self, key: Optional[int] = -1) -&gt; _T:\n  \"\"\"Removes and returns an item at a given index. Similar to list.pop().\"\"\"\n  value = self._values[key]\n  self.__delitem__(key)\n  return value\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/internal/containers.html#client.ayon_hiero.vendor.google.protobuf.internal.containers.RepeatedCompositeFieldContainer.remove","title":"<code>remove(elem)</code>","text":"<p>Removes an item from the list. Similar to list.remove().</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/internal/containers.py</code> <pre><code>def remove(self, elem: _T) -&gt; None:\n  \"\"\"Removes an item from the list. Similar to list.remove().\"\"\"\n  self._values.remove(elem)\n  self._message_listener.Modified()\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/internal/containers.html#client.ayon_hiero.vendor.google.protobuf.internal.containers.RepeatedScalarFieldContainer","title":"<code>RepeatedScalarFieldContainer</code>","text":"<p>               Bases: <code>BaseContainer[_T]</code>, <code>MutableSequence[_T]</code></p> <p>Simple, type-checked, list-like container for holding repeated scalars.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/internal/containers.py</code> <pre><code>class RepeatedScalarFieldContainer(BaseContainer[_T], MutableSequence[_T]):\n  \"\"\"Simple, type-checked, list-like container for holding repeated scalars.\"\"\"\n\n  # Disallows assignment to other attributes.\n  __slots__ = ['_type_checker']\n\n  def __init__(\n      self,\n      message_listener: Any,\n      type_checker: Any,\n  ) -&gt; None:\n    \"\"\"Args:\n\n      message_listener: A MessageListener implementation. The\n      RepeatedScalarFieldContainer will call this object's Modified() method\n      when it is modified.\n      type_checker: A type_checkers.ValueChecker instance to run on elements\n      inserted into this container.\n    \"\"\"\n    super().__init__(message_listener)\n    self._type_checker = type_checker\n\n  def append(self, value: _T) -&gt; None:\n    \"\"\"Appends an item to the list. Similar to list.append().\"\"\"\n    self._values.append(self._type_checker.CheckValue(value))\n    if not self._message_listener.dirty:\n      self._message_listener.Modified()\n\n  def insert(self, key: int, value: _T) -&gt; None:\n    \"\"\"Inserts the item at the specified position. Similar to list.insert().\"\"\"\n    self._values.insert(key, self._type_checker.CheckValue(value))\n    if not self._message_listener.dirty:\n      self._message_listener.Modified()\n\n  def extend(self, elem_seq: Iterable[_T]) -&gt; None:\n    \"\"\"Extends by appending the given iterable. Similar to list.extend().\"\"\"\n    if elem_seq is None:\n      return\n    try:\n      elem_seq_iter = iter(elem_seq)\n    except TypeError:\n      if not elem_seq:\n        # silently ignore falsy inputs :-/.\n        # TODO(ptucker): Deprecate this behavior. b/18413862\n        return\n      raise\n\n    new_values = [self._type_checker.CheckValue(elem) for elem in elem_seq_iter]\n    if new_values:\n      self._values.extend(new_values)\n    self._message_listener.Modified()\n\n  def MergeFrom(\n      self,\n      other: Union['RepeatedScalarFieldContainer[_T]', Iterable[_T]],\n  ) -&gt; None:\n    \"\"\"Appends the contents of another repeated field of the same type to this\n    one. We do not check the types of the individual fields.\n    \"\"\"\n    self._values.extend(other)\n    self._message_listener.Modified()\n\n  def remove(self, elem: _T):\n    \"\"\"Removes an item from the list. Similar to list.remove().\"\"\"\n    self._values.remove(elem)\n    self._message_listener.Modified()\n\n  def pop(self, key: Optional[int] = -1) -&gt; _T:\n    \"\"\"Removes and returns an item at a given index. Similar to list.pop().\"\"\"\n    value = self._values[key]\n    self.__delitem__(key)\n    return value\n\n  @overload\n  def __setitem__(self, key: int, value: _T) -&gt; None:\n    ...\n\n  @overload\n  def __setitem__(self, key: slice, value: Iterable[_T]) -&gt; None:\n    ...\n\n  def __setitem__(self, key, value) -&gt; None:\n    \"\"\"Sets the item on the specified position.\"\"\"\n    if isinstance(key, slice):\n      if key.step is not None:\n        raise ValueError('Extended slices not supported')\n      self._values[key] = map(self._type_checker.CheckValue, value)\n      self._message_listener.Modified()\n    else:\n      self._values[key] = self._type_checker.CheckValue(value)\n      self._message_listener.Modified()\n\n  def __delitem__(self, key: Union[int, slice]) -&gt; None:\n    \"\"\"Deletes the item at the specified position.\"\"\"\n    del self._values[key]\n    self._message_listener.Modified()\n\n  def __eq__(self, other: Any) -&gt; bool:\n    \"\"\"Compares the current instance with another one.\"\"\"\n    if self is other:\n      return True\n    # Special case for the same type which should be common and fast.\n    if isinstance(other, self.__class__):\n      return other._values == self._values\n    # We are presumably comparing against some other sequence type.\n    return other == self._values\n\n  def __deepcopy__(\n      self,\n      unused_memo: Any = None,\n  ) -&gt; 'RepeatedScalarFieldContainer[_T]':\n    clone = RepeatedScalarFieldContainer(\n        copy.deepcopy(self._message_listener), self._type_checker)\n    clone.MergeFrom(self)\n    return clone\n\n  def __reduce__(self, **kwargs) -&gt; NoReturn:\n    raise pickle.PickleError(\n        \"Can't pickle repeated scalar fields, convert to list first\")\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/internal/containers.html#client.ayon_hiero.vendor.google.protobuf.internal.containers.RepeatedScalarFieldContainer.MergeFrom","title":"<code>MergeFrom(other)</code>","text":"<p>Appends the contents of another repeated field of the same type to this one. We do not check the types of the individual fields.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/internal/containers.py</code> <pre><code>def MergeFrom(\n    self,\n    other: Union['RepeatedScalarFieldContainer[_T]', Iterable[_T]],\n) -&gt; None:\n  \"\"\"Appends the contents of another repeated field of the same type to this\n  one. We do not check the types of the individual fields.\n  \"\"\"\n  self._values.extend(other)\n  self._message_listener.Modified()\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/internal/containers.html#client.ayon_hiero.vendor.google.protobuf.internal.containers.RepeatedScalarFieldContainer.__delitem__","title":"<code>__delitem__(key)</code>","text":"<p>Deletes the item at the specified position.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/internal/containers.py</code> <pre><code>def __delitem__(self, key: Union[int, slice]) -&gt; None:\n  \"\"\"Deletes the item at the specified position.\"\"\"\n  del self._values[key]\n  self._message_listener.Modified()\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/internal/containers.html#client.ayon_hiero.vendor.google.protobuf.internal.containers.RepeatedScalarFieldContainer.__eq__","title":"<code>__eq__(other)</code>","text":"<p>Compares the current instance with another one.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/internal/containers.py</code> <pre><code>def __eq__(self, other: Any) -&gt; bool:\n  \"\"\"Compares the current instance with another one.\"\"\"\n  if self is other:\n    return True\n  # Special case for the same type which should be common and fast.\n  if isinstance(other, self.__class__):\n    return other._values == self._values\n  # We are presumably comparing against some other sequence type.\n  return other == self._values\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/internal/containers.html#client.ayon_hiero.vendor.google.protobuf.internal.containers.RepeatedScalarFieldContainer.__init__","title":"<code>__init__(message_listener, type_checker)</code>","text":"<p>Args:</p> <p>message_listener: A MessageListener implementation. The RepeatedScalarFieldContainer will call this object's Modified() method when it is modified. type_checker: A type_checkers.ValueChecker instance to run on elements inserted into this container.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/internal/containers.py</code> <pre><code>def __init__(\n    self,\n    message_listener: Any,\n    type_checker: Any,\n) -&gt; None:\n  \"\"\"Args:\n\n    message_listener: A MessageListener implementation. The\n    RepeatedScalarFieldContainer will call this object's Modified() method\n    when it is modified.\n    type_checker: A type_checkers.ValueChecker instance to run on elements\n    inserted into this container.\n  \"\"\"\n  super().__init__(message_listener)\n  self._type_checker = type_checker\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/internal/containers.html#client.ayon_hiero.vendor.google.protobuf.internal.containers.RepeatedScalarFieldContainer.__setitem__","title":"<code>__setitem__(key, value)</code>","text":"<pre><code>__setitem__(key: int, value: _T) -&gt; None\n</code></pre><pre><code>__setitem__(key: slice, value: Iterable[_T]) -&gt; None\n</code></pre> <p>Sets the item on the specified position.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/internal/containers.py</code> <pre><code>def __setitem__(self, key, value) -&gt; None:\n  \"\"\"Sets the item on the specified position.\"\"\"\n  if isinstance(key, slice):\n    if key.step is not None:\n      raise ValueError('Extended slices not supported')\n    self._values[key] = map(self._type_checker.CheckValue, value)\n    self._message_listener.Modified()\n  else:\n    self._values[key] = self._type_checker.CheckValue(value)\n    self._message_listener.Modified()\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/internal/containers.html#client.ayon_hiero.vendor.google.protobuf.internal.containers.RepeatedScalarFieldContainer.append","title":"<code>append(value)</code>","text":"<p>Appends an item to the list. Similar to list.append().</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/internal/containers.py</code> <pre><code>def append(self, value: _T) -&gt; None:\n  \"\"\"Appends an item to the list. Similar to list.append().\"\"\"\n  self._values.append(self._type_checker.CheckValue(value))\n  if not self._message_listener.dirty:\n    self._message_listener.Modified()\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/internal/containers.html#client.ayon_hiero.vendor.google.protobuf.internal.containers.RepeatedScalarFieldContainer.extend","title":"<code>extend(elem_seq)</code>","text":"<p>Extends by appending the given iterable. Similar to list.extend().</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/internal/containers.py</code> <pre><code>def extend(self, elem_seq: Iterable[_T]) -&gt; None:\n  \"\"\"Extends by appending the given iterable. Similar to list.extend().\"\"\"\n  if elem_seq is None:\n    return\n  try:\n    elem_seq_iter = iter(elem_seq)\n  except TypeError:\n    if not elem_seq:\n      # silently ignore falsy inputs :-/.\n      # TODO(ptucker): Deprecate this behavior. b/18413862\n      return\n    raise\n\n  new_values = [self._type_checker.CheckValue(elem) for elem in elem_seq_iter]\n  if new_values:\n    self._values.extend(new_values)\n  self._message_listener.Modified()\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/internal/containers.html#client.ayon_hiero.vendor.google.protobuf.internal.containers.RepeatedScalarFieldContainer.insert","title":"<code>insert(key, value)</code>","text":"<p>Inserts the item at the specified position. Similar to list.insert().</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/internal/containers.py</code> <pre><code>def insert(self, key: int, value: _T) -&gt; None:\n  \"\"\"Inserts the item at the specified position. Similar to list.insert().\"\"\"\n  self._values.insert(key, self._type_checker.CheckValue(value))\n  if not self._message_listener.dirty:\n    self._message_listener.Modified()\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/internal/containers.html#client.ayon_hiero.vendor.google.protobuf.internal.containers.RepeatedScalarFieldContainer.pop","title":"<code>pop(key=-1)</code>","text":"<p>Removes and returns an item at a given index. Similar to list.pop().</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/internal/containers.py</code> <pre><code>def pop(self, key: Optional[int] = -1) -&gt; _T:\n  \"\"\"Removes and returns an item at a given index. Similar to list.pop().\"\"\"\n  value = self._values[key]\n  self.__delitem__(key)\n  return value\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/internal/containers.html#client.ayon_hiero.vendor.google.protobuf.internal.containers.RepeatedScalarFieldContainer.remove","title":"<code>remove(elem)</code>","text":"<p>Removes an item from the list. Similar to list.remove().</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/internal/containers.py</code> <pre><code>def remove(self, elem: _T):\n  \"\"\"Removes an item from the list. Similar to list.remove().\"\"\"\n  self._values.remove(elem)\n  self._message_listener.Modified()\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/internal/containers.html#client.ayon_hiero.vendor.google.protobuf.internal.containers.ScalarMap","title":"<code>ScalarMap</code>","text":"<p>               Bases: <code>MutableMapping[_K, _V]</code></p> <p>Simple, type-checked, dict-like container for holding repeated scalars.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/internal/containers.py</code> <pre><code>class ScalarMap(MutableMapping[_K, _V]):\n  \"\"\"Simple, type-checked, dict-like container for holding repeated scalars.\"\"\"\n\n  # Disallows assignment to other attributes.\n  __slots__ = ['_key_checker', '_value_checker', '_values', '_message_listener',\n               '_entry_descriptor']\n\n  def __init__(\n      self,\n      message_listener: Any,\n      key_checker: Any,\n      value_checker: Any,\n      entry_descriptor: Any,\n  ) -&gt; None:\n    \"\"\"\n    Args:\n      message_listener: A MessageListener implementation.\n        The ScalarMap will call this object's Modified() method when it\n        is modified.\n      key_checker: A type_checkers.ValueChecker instance to run on keys\n        inserted into this container.\n      value_checker: A type_checkers.ValueChecker instance to run on values\n        inserted into this container.\n      entry_descriptor: The MessageDescriptor of a map entry: key and value.\n    \"\"\"\n    self._message_listener = message_listener\n    self._key_checker = key_checker\n    self._value_checker = value_checker\n    self._entry_descriptor = entry_descriptor\n    self._values = {}\n\n  def __getitem__(self, key: _K) -&gt; _V:\n    try:\n      return self._values[key]\n    except KeyError:\n      key = self._key_checker.CheckValue(key)\n      val = self._value_checker.DefaultValue()\n      self._values[key] = val\n      return val\n\n  def __contains__(self, item: _K) -&gt; bool:\n    # We check the key's type to match the strong-typing flavor of the API.\n    # Also this makes it easier to match the behavior of the C++ implementation.\n    self._key_checker.CheckValue(item)\n    return item in self._values\n\n  @overload\n  def get(self, key: _K) -&gt; Optional[_V]:\n    ...\n\n  @overload\n  def get(self, key: _K, default: _T) -&gt; Union[_V, _T]:\n    ...\n\n  # We need to override this explicitly, because our defaultdict-like behavior\n  # will make the default implementation (from our base class) always insert\n  # the key.\n  def get(self, key, default=None):\n    if key in self:\n      return self[key]\n    else:\n      return default\n\n  def __setitem__(self, key: _K, value: _V) -&gt; _T:\n    checked_key = self._key_checker.CheckValue(key)\n    checked_value = self._value_checker.CheckValue(value)\n    self._values[checked_key] = checked_value\n    self._message_listener.Modified()\n\n  def __delitem__(self, key: _K) -&gt; None:\n    del self._values[key]\n    self._message_listener.Modified()\n\n  def __len__(self) -&gt; int:\n    return len(self._values)\n\n  def __iter__(self) -&gt; Iterator[_K]:\n    return iter(self._values)\n\n  def __repr__(self) -&gt; str:\n    return repr(self._values)\n\n  def MergeFrom(self, other: 'ScalarMap[_K, _V]') -&gt; None:\n    self._values.update(other._values)\n    self._message_listener.Modified()\n\n  def InvalidateIterators(self) -&gt; None:\n    # It appears that the only way to reliably invalidate iterators to\n    # self._values is to ensure that its size changes.\n    original = self._values\n    self._values = original.copy()\n    original[None] = None\n\n  # This is defined in the abstract base, but we can do it much more cheaply.\n  def clear(self) -&gt; None:\n    self._values.clear()\n    self._message_listener.Modified()\n\n  def GetEntryClass(self) -&gt; Any:\n    return self._entry_descriptor._concrete_class\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/internal/containers.html#client.ayon_hiero.vendor.google.protobuf.internal.containers.ScalarMap.__init__","title":"<code>__init__(message_listener, key_checker, value_checker, entry_descriptor)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>message_listener</code> <code>Any</code> <p>A MessageListener implementation. The ScalarMap will call this object's Modified() method when it is modified.</p> required <code>key_checker</code> <code>Any</code> <p>A type_checkers.ValueChecker instance to run on keys inserted into this container.</p> required <code>value_checker</code> <code>Any</code> <p>A type_checkers.ValueChecker instance to run on values inserted into this container.</p> required <code>entry_descriptor</code> <code>Any</code> <p>The MessageDescriptor of a map entry: key and value.</p> required Source code in <code>client/ayon_hiero/vendor/google/protobuf/internal/containers.py</code> <pre><code>def __init__(\n    self,\n    message_listener: Any,\n    key_checker: Any,\n    value_checker: Any,\n    entry_descriptor: Any,\n) -&gt; None:\n  \"\"\"\n  Args:\n    message_listener: A MessageListener implementation.\n      The ScalarMap will call this object's Modified() method when it\n      is modified.\n    key_checker: A type_checkers.ValueChecker instance to run on keys\n      inserted into this container.\n    value_checker: A type_checkers.ValueChecker instance to run on values\n      inserted into this container.\n    entry_descriptor: The MessageDescriptor of a map entry: key and value.\n  \"\"\"\n  self._message_listener = message_listener\n  self._key_checker = key_checker\n  self._value_checker = value_checker\n  self._entry_descriptor = entry_descriptor\n  self._values = {}\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/internal/containers.html#client.ayon_hiero.vendor.google.protobuf.internal.containers.UnknownFieldSet","title":"<code>UnknownFieldSet</code>","text":"<p>UnknownField container</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/internal/containers.py</code> <pre><code>class UnknownFieldSet:\n  \"\"\"UnknownField container\"\"\"\n\n  # Disallows assignment to other attributes.\n  __slots__ = ['_values']\n\n  def __init__(self):\n    self._values = []\n\n  def __getitem__(self, index):\n    if self._values is None:\n      raise ValueError('UnknownFields does not exist. '\n                       'The parent message might be cleared.')\n    size = len(self._values)\n    if index &lt; 0:\n      index += size\n    if index &lt; 0 or index &gt;= size:\n      raise IndexError('index %d out of range'.index)\n\n    return UnknownFieldRef(self, index)\n\n  def _internal_get(self, index):\n    return self._values[index]\n\n  def __len__(self):\n    if self._values is None:\n      raise ValueError('UnknownFields does not exist. '\n                       'The parent message might be cleared.')\n    return len(self._values)\n\n  def _add(self, field_number, wire_type, data):\n    unknown_field = _UnknownField(field_number, wire_type, data)\n    self._values.append(unknown_field)\n    return unknown_field\n\n  def __iter__(self):\n    for i in range(len(self)):\n      yield UnknownFieldRef(self, i)\n\n  def _extend(self, other):\n    if other is None:\n      return\n    # pylint: disable=protected-access\n    self._values.extend(other._values)\n\n  def __eq__(self, other):\n    if self is other:\n      return True\n    # Sort unknown fields because their order shouldn't\n    # affect equality test.\n    values = list(self._values)\n    if other is None:\n      return not values\n    values.sort()\n    # pylint: disable=protected-access\n    other_values = sorted(other._values)\n    return values == other_values\n\n  def _clear(self):\n    for value in self._values:\n      # pylint: disable=protected-access\n      if isinstance(value._data, UnknownFieldSet):\n        value._data._clear()  # pylint: disable=protected-access\n    self._values = None\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/internal/decoder.html","title":"decoder","text":"<p>Code for decoding protocol buffer primitives.</p> <p>This code is very similar to encoder.py -- read the docs for that module first.</p> <p>A \"decoder\" is a function with the signature:   Decode(buffer, pos, end, message, field_dict) The arguments are:   buffer:     The string containing the encoded message.   pos:        The current position in the string.   end:        The position in the string where the current message ends.  May be               less than len(buffer) if we're reading a sub-message.   message:    The message object into which we're parsing.   field_dict: message._fields (avoids a hashtable lookup). The decoder reads the field and stores it into field_dict, returning the new buffer position.  A decoder for a repeated field may proactively decode all of the elements of that field, if they appear consecutively.</p> Note that decoders may throw any of the following <p>IndexError:  Indicates a truncated message. struct.error:  Unpacking of a fixed-width field failed. message.DecodeError:  Other errors.</p> <p>Decoders are expected to raise an exception if they are called with pos &gt; end. This allows callers to be lax about bounds checking:  it's fineto read past \"end\" as long as you are sure that someone else will notice and throw an exception later on.</p> <p>Something up the call stack is expected to catch IndexError and struct.error and convert them to message.DecodeError.</p> Decoders are constructed using decoder constructors with the signature <p>MakeDecoder(field_number, is_repeated, is_packed, key, new_default)</p> <p>The arguments are:   field_number:  The field number of the field we want to decode.   is_repeated:   Is the field a repeated field? (bool)   is_packed:     Is the field a packed field? (bool)   key:           The key to use when looking up the field within field_dict.                  (This is actually the FieldDescriptor but nothing in this                  file should depend on that.)   new_default:   A function which takes a message object as a parameter and                  returns a new instance of the default value for this field.                  (This is called for repeated fields and sub-messages, when an                  instance does not already exist.)</p> <p>As with encoders, we define a decoder constructor for every type of field. Then, for every field of every message class we construct an actual decoder. That decoder goes into a dict indexed by tag, so when we decode a message we repeatedly read a tag, look up the corresponding decoder, and invoke it.</p>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/internal/decoder.html#client.ayon_hiero.vendor.google.protobuf.internal.decoder.BytesDecoder","title":"<code>BytesDecoder(field_number, is_repeated, is_packed, key, new_default, clear_if_default=False)</code>","text":"<p>Returns a decoder for a bytes field.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/internal/decoder.py</code> <pre><code>def BytesDecoder(field_number, is_repeated, is_packed, key, new_default,\n                 clear_if_default=False):\n  \"\"\"Returns a decoder for a bytes field.\"\"\"\n\n  local_DecodeVarint = _DecodeVarint\n\n  assert not is_packed\n  if is_repeated:\n    tag_bytes = encoder.TagBytes(field_number,\n                                 wire_format.WIRETYPE_LENGTH_DELIMITED)\n    tag_len = len(tag_bytes)\n    def DecodeRepeatedField(buffer, pos, end, message, field_dict):\n      value = field_dict.get(key)\n      if value is None:\n        value = field_dict.setdefault(key, new_default(message))\n      while 1:\n        (size, pos) = local_DecodeVarint(buffer, pos)\n        new_pos = pos + size\n        if new_pos &gt; end:\n          raise _DecodeError('Truncated string.')\n        value.append(buffer[pos:new_pos].tobytes())\n        # Predict that the next tag is another copy of the same repeated field.\n        pos = new_pos + tag_len\n        if buffer[new_pos:pos] != tag_bytes or new_pos == end:\n          # Prediction failed.  Return.\n          return new_pos\n    return DecodeRepeatedField\n  else:\n    def DecodeField(buffer, pos, end, message, field_dict):\n      (size, pos) = local_DecodeVarint(buffer, pos)\n      new_pos = pos + size\n      if new_pos &gt; end:\n        raise _DecodeError('Truncated string.')\n      if clear_if_default and not size:\n        field_dict.pop(key, None)\n      else:\n        field_dict[key] = buffer[pos:new_pos].tobytes()\n      return new_pos\n    return DecodeField\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/internal/decoder.html#client.ayon_hiero.vendor.google.protobuf.internal.decoder.EnumDecoder","title":"<code>EnumDecoder(field_number, is_repeated, is_packed, key, new_default, clear_if_default=False)</code>","text":"<p>Returns a decoder for enum field.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/internal/decoder.py</code> <pre><code>def EnumDecoder(field_number, is_repeated, is_packed, key, new_default,\n                clear_if_default=False):\n  \"\"\"Returns a decoder for enum field.\"\"\"\n  enum_type = key.enum_type\n  if is_packed:\n    local_DecodeVarint = _DecodeVarint\n    def DecodePackedField(buffer, pos, end, message, field_dict):\n      \"\"\"Decode serialized packed enum to its value and a new position.\n\n      Args:\n        buffer: memoryview of the serialized bytes.\n        pos: int, position in the memory view to start at.\n        end: int, end position of serialized data\n        message: Message object to store unknown fields in\n        field_dict: Map[Descriptor, Any] to store decoded values in.\n\n      Returns:\n        int, new position in serialized data.\n      \"\"\"\n      value = field_dict.get(key)\n      if value is None:\n        value = field_dict.setdefault(key, new_default(message))\n      (endpoint, pos) = local_DecodeVarint(buffer, pos)\n      endpoint += pos\n      if endpoint &gt; end:\n        raise _DecodeError('Truncated message.')\n      while pos &lt; endpoint:\n        value_start_pos = pos\n        (element, pos) = _DecodeSignedVarint32(buffer, pos)\n        # pylint: disable=protected-access\n        if element in enum_type.values_by_number:\n          value.append(element)\n        else:\n          if not message._unknown_fields:\n            message._unknown_fields = []\n          tag_bytes = encoder.TagBytes(field_number,\n                                       wire_format.WIRETYPE_VARINT)\n\n          message._unknown_fields.append(\n              (tag_bytes, buffer[value_start_pos:pos].tobytes()))\n          if message._unknown_field_set is None:\n            message._unknown_field_set = containers.UnknownFieldSet()\n          message._unknown_field_set._add(\n              field_number, wire_format.WIRETYPE_VARINT, element)\n          # pylint: enable=protected-access\n      if pos &gt; endpoint:\n        if element in enum_type.values_by_number:\n          del value[-1]   # Discard corrupt value.\n        else:\n          del message._unknown_fields[-1]\n          # pylint: disable=protected-access\n          del message._unknown_field_set._values[-1]\n          # pylint: enable=protected-access\n        raise _DecodeError('Packed element was truncated.')\n      return pos\n    return DecodePackedField\n  elif is_repeated:\n    tag_bytes = encoder.TagBytes(field_number, wire_format.WIRETYPE_VARINT)\n    tag_len = len(tag_bytes)\n    def DecodeRepeatedField(buffer, pos, end, message, field_dict):\n      \"\"\"Decode serialized repeated enum to its value and a new position.\n\n      Args:\n        buffer: memoryview of the serialized bytes.\n        pos: int, position in the memory view to start at.\n        end: int, end position of serialized data\n        message: Message object to store unknown fields in\n        field_dict: Map[Descriptor, Any] to store decoded values in.\n\n      Returns:\n        int, new position in serialized data.\n      \"\"\"\n      value = field_dict.get(key)\n      if value is None:\n        value = field_dict.setdefault(key, new_default(message))\n      while 1:\n        (element, new_pos) = _DecodeSignedVarint32(buffer, pos)\n        # pylint: disable=protected-access\n        if element in enum_type.values_by_number:\n          value.append(element)\n        else:\n          if not message._unknown_fields:\n            message._unknown_fields = []\n          message._unknown_fields.append(\n              (tag_bytes, buffer[pos:new_pos].tobytes()))\n          if message._unknown_field_set is None:\n            message._unknown_field_set = containers.UnknownFieldSet()\n          message._unknown_field_set._add(\n              field_number, wire_format.WIRETYPE_VARINT, element)\n        # pylint: enable=protected-access\n        # Predict that the next tag is another copy of the same repeated\n        # field.\n        pos = new_pos + tag_len\n        if buffer[new_pos:pos] != tag_bytes or new_pos &gt;= end:\n          # Prediction failed.  Return.\n          if new_pos &gt; end:\n            raise _DecodeError('Truncated message.')\n          return new_pos\n    return DecodeRepeatedField\n  else:\n    def DecodeField(buffer, pos, end, message, field_dict):\n      \"\"\"Decode serialized repeated enum to its value and a new position.\n\n      Args:\n        buffer: memoryview of the serialized bytes.\n        pos: int, position in the memory view to start at.\n        end: int, end position of serialized data\n        message: Message object to store unknown fields in\n        field_dict: Map[Descriptor, Any] to store decoded values in.\n\n      Returns:\n        int, new position in serialized data.\n      \"\"\"\n      value_start_pos = pos\n      (enum_value, pos) = _DecodeSignedVarint32(buffer, pos)\n      if pos &gt; end:\n        raise _DecodeError('Truncated message.')\n      if clear_if_default and not enum_value:\n        field_dict.pop(key, None)\n        return pos\n      # pylint: disable=protected-access\n      if enum_value in enum_type.values_by_number:\n        field_dict[key] = enum_value\n      else:\n        if not message._unknown_fields:\n          message._unknown_fields = []\n        tag_bytes = encoder.TagBytes(field_number,\n                                     wire_format.WIRETYPE_VARINT)\n        message._unknown_fields.append(\n            (tag_bytes, buffer[value_start_pos:pos].tobytes()))\n        if message._unknown_field_set is None:\n          message._unknown_field_set = containers.UnknownFieldSet()\n        message._unknown_field_set._add(\n            field_number, wire_format.WIRETYPE_VARINT, enum_value)\n        # pylint: enable=protected-access\n      return pos\n    return DecodeField\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/internal/decoder.html#client.ayon_hiero.vendor.google.protobuf.internal.decoder.GroupDecoder","title":"<code>GroupDecoder(field_number, is_repeated, is_packed, key, new_default)</code>","text":"<p>Returns a decoder for a group field.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/internal/decoder.py</code> <pre><code>def GroupDecoder(field_number, is_repeated, is_packed, key, new_default):\n  \"\"\"Returns a decoder for a group field.\"\"\"\n\n  end_tag_bytes = encoder.TagBytes(field_number,\n                                   wire_format.WIRETYPE_END_GROUP)\n  end_tag_len = len(end_tag_bytes)\n\n  assert not is_packed\n  if is_repeated:\n    tag_bytes = encoder.TagBytes(field_number,\n                                 wire_format.WIRETYPE_START_GROUP)\n    tag_len = len(tag_bytes)\n    def DecodeRepeatedField(buffer, pos, end, message, field_dict):\n      value = field_dict.get(key)\n      if value is None:\n        value = field_dict.setdefault(key, new_default(message))\n      while 1:\n        value = field_dict.get(key)\n        if value is None:\n          value = field_dict.setdefault(key, new_default(message))\n        # Read sub-message.\n        pos = value.add()._InternalParse(buffer, pos, end)\n        # Read end tag.\n        new_pos = pos+end_tag_len\n        if buffer[pos:new_pos] != end_tag_bytes or new_pos &gt; end:\n          raise _DecodeError('Missing group end tag.')\n        # Predict that the next tag is another copy of the same repeated field.\n        pos = new_pos + tag_len\n        if buffer[new_pos:pos] != tag_bytes or new_pos == end:\n          # Prediction failed.  Return.\n          return new_pos\n    return DecodeRepeatedField\n  else:\n    def DecodeField(buffer, pos, end, message, field_dict):\n      value = field_dict.get(key)\n      if value is None:\n        value = field_dict.setdefault(key, new_default(message))\n      # Read sub-message.\n      pos = value._InternalParse(buffer, pos, end)\n      # Read end tag.\n      new_pos = pos+end_tag_len\n      if buffer[pos:new_pos] != end_tag_bytes or new_pos &gt; end:\n        raise _DecodeError('Missing group end tag.')\n      return new_pos\n    return DecodeField\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/internal/decoder.html#client.ayon_hiero.vendor.google.protobuf.internal.decoder.MapDecoder","title":"<code>MapDecoder(field_descriptor, new_default, is_message_map)</code>","text":"<p>Returns a decoder for a map field.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/internal/decoder.py</code> <pre><code>def MapDecoder(field_descriptor, new_default, is_message_map):\n  \"\"\"Returns a decoder for a map field.\"\"\"\n\n  key = field_descriptor\n  tag_bytes = encoder.TagBytes(field_descriptor.number,\n                               wire_format.WIRETYPE_LENGTH_DELIMITED)\n  tag_len = len(tag_bytes)\n  local_DecodeVarint = _DecodeVarint\n  # Can't read _concrete_class yet; might not be initialized.\n  message_type = field_descriptor.message_type\n\n  def DecodeMap(buffer, pos, end, message, field_dict):\n    submsg = message_type._concrete_class()\n    value = field_dict.get(key)\n    if value is None:\n      value = field_dict.setdefault(key, new_default(message))\n    while 1:\n      # Read length.\n      (size, pos) = local_DecodeVarint(buffer, pos)\n      new_pos = pos + size\n      if new_pos &gt; end:\n        raise _DecodeError('Truncated message.')\n      # Read sub-message.\n      submsg.Clear()\n      if submsg._InternalParse(buffer, pos, new_pos) != new_pos:\n        # The only reason _InternalParse would return early is if it\n        # encountered an end-group tag.\n        raise _DecodeError('Unexpected end-group tag.')\n\n      if is_message_map:\n        value[submsg.key].CopyFrom(submsg.value)\n      else:\n        value[submsg.key] = submsg.value\n\n      # Predict that the next tag is another copy of the same repeated field.\n      pos = new_pos + tag_len\n      if buffer[new_pos:pos] != tag_bytes or new_pos == end:\n        # Prediction failed.  Return.\n        return new_pos\n\n  return DecodeMap\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/internal/decoder.html#client.ayon_hiero.vendor.google.protobuf.internal.decoder.MessageDecoder","title":"<code>MessageDecoder(field_number, is_repeated, is_packed, key, new_default)</code>","text":"<p>Returns a decoder for a message field.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/internal/decoder.py</code> <pre><code>def MessageDecoder(field_number, is_repeated, is_packed, key, new_default):\n  \"\"\"Returns a decoder for a message field.\"\"\"\n\n  local_DecodeVarint = _DecodeVarint\n\n  assert not is_packed\n  if is_repeated:\n    tag_bytes = encoder.TagBytes(field_number,\n                                 wire_format.WIRETYPE_LENGTH_DELIMITED)\n    tag_len = len(tag_bytes)\n    def DecodeRepeatedField(buffer, pos, end, message, field_dict):\n      value = field_dict.get(key)\n      if value is None:\n        value = field_dict.setdefault(key, new_default(message))\n      while 1:\n        # Read length.\n        (size, pos) = local_DecodeVarint(buffer, pos)\n        new_pos = pos + size\n        if new_pos &gt; end:\n          raise _DecodeError('Truncated message.')\n        # Read sub-message.\n        if value.add()._InternalParse(buffer, pos, new_pos) != new_pos:\n          # The only reason _InternalParse would return early is if it\n          # encountered an end-group tag.\n          raise _DecodeError('Unexpected end-group tag.')\n        # Predict that the next tag is another copy of the same repeated field.\n        pos = new_pos + tag_len\n        if buffer[new_pos:pos] != tag_bytes or new_pos == end:\n          # Prediction failed.  Return.\n          return new_pos\n    return DecodeRepeatedField\n  else:\n    def DecodeField(buffer, pos, end, message, field_dict):\n      value = field_dict.get(key)\n      if value is None:\n        value = field_dict.setdefault(key, new_default(message))\n      # Read length.\n      (size, pos) = local_DecodeVarint(buffer, pos)\n      new_pos = pos + size\n      if new_pos &gt; end:\n        raise _DecodeError('Truncated message.')\n      # Read sub-message.\n      if value._InternalParse(buffer, pos, new_pos) != new_pos:\n        # The only reason _InternalParse would return early is if it encountered\n        # an end-group tag.\n        raise _DecodeError('Unexpected end-group tag.')\n      return new_pos\n    return DecodeField\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/internal/decoder.html#client.ayon_hiero.vendor.google.protobuf.internal.decoder.MessageSetItemDecoder","title":"<code>MessageSetItemDecoder(descriptor)</code>","text":"<p>Returns a decoder for a MessageSet item.</p> <p>The parameter is the message Descriptor.</p> The message set message looks like this <p>message MessageSet {   repeated group Item = 1 {     required int32 type_id = 2;     required string message = 3;   } }</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/internal/decoder.py</code> <pre><code>def MessageSetItemDecoder(descriptor):\n  \"\"\"Returns a decoder for a MessageSet item.\n\n  The parameter is the message Descriptor.\n\n  The message set message looks like this:\n    message MessageSet {\n      repeated group Item = 1 {\n        required int32 type_id = 2;\n        required string message = 3;\n      }\n    }\n  \"\"\"\n\n  type_id_tag_bytes = encoder.TagBytes(2, wire_format.WIRETYPE_VARINT)\n  message_tag_bytes = encoder.TagBytes(3, wire_format.WIRETYPE_LENGTH_DELIMITED)\n  item_end_tag_bytes = encoder.TagBytes(1, wire_format.WIRETYPE_END_GROUP)\n\n  local_ReadTag = ReadTag\n  local_DecodeVarint = _DecodeVarint\n  local_SkipField = SkipField\n\n  def DecodeItem(buffer, pos, end, message, field_dict):\n    \"\"\"Decode serialized message set to its value and new position.\n\n    Args:\n      buffer: memoryview of the serialized bytes.\n      pos: int, position in the memory view to start at.\n      end: int, end position of serialized data\n      message: Message object to store unknown fields in\n      field_dict: Map[Descriptor, Any] to store decoded values in.\n\n    Returns:\n      int, new position in serialized data.\n    \"\"\"\n    message_set_item_start = pos\n    type_id = -1\n    message_start = -1\n    message_end = -1\n\n    # Technically, type_id and message can appear in any order, so we need\n    # a little loop here.\n    while 1:\n      (tag_bytes, pos) = local_ReadTag(buffer, pos)\n      if tag_bytes == type_id_tag_bytes:\n        (type_id, pos) = local_DecodeVarint(buffer, pos)\n      elif tag_bytes == message_tag_bytes:\n        (size, message_start) = local_DecodeVarint(buffer, pos)\n        pos = message_end = message_start + size\n      elif tag_bytes == item_end_tag_bytes:\n        break\n      else:\n        pos = SkipField(buffer, pos, end, tag_bytes)\n        if pos == -1:\n          raise _DecodeError('Missing group end tag.')\n\n    if pos &gt; end:\n      raise _DecodeError('Truncated message.')\n\n    if type_id == -1:\n      raise _DecodeError('MessageSet item missing type_id.')\n    if message_start == -1:\n      raise _DecodeError('MessageSet item missing message.')\n\n    extension = message.Extensions._FindExtensionByNumber(type_id)\n    # pylint: disable=protected-access\n    if extension is not None:\n      value = field_dict.get(extension)\n      if value is None:\n        message_type = extension.message_type\n        if not hasattr(message_type, '_concrete_class'):\n          # pylint: disable=protected-access\n          message._FACTORY.GetPrototype(message_type)\n        value = field_dict.setdefault(\n            extension, message_type._concrete_class())\n      if value._InternalParse(buffer, message_start,message_end) != message_end:\n        # The only reason _InternalParse would return early is if it encountered\n        # an end-group tag.\n        raise _DecodeError('Unexpected end-group tag.')\n    else:\n      if not message._unknown_fields:\n        message._unknown_fields = []\n      message._unknown_fields.append(\n          (MESSAGE_SET_ITEM_TAG, buffer[message_set_item_start:pos].tobytes()))\n      if message._unknown_field_set is None:\n        message._unknown_field_set = containers.UnknownFieldSet()\n      message._unknown_field_set._add(\n          type_id,\n          wire_format.WIRETYPE_LENGTH_DELIMITED,\n          buffer[message_start:message_end].tobytes())\n      # pylint: enable=protected-access\n\n    return pos\n\n  return DecodeItem\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/internal/decoder.html#client.ayon_hiero.vendor.google.protobuf.internal.decoder.ReadTag","title":"<code>ReadTag(buffer, pos)</code>","text":"<p>Read a tag from the memoryview, and return a (tag_bytes, new_pos) tuple.</p> <p>We return the raw bytes of the tag rather than decoding them.  The raw bytes can then be used to look up the proper decoder.  This effectively allows us to trade some work that would be done in pure-python (decoding a varint) for work that is done in C (searching for a byte string in a hash table). In a low-level language it would be much cheaper to decode the varint and use that, but not in Python.</p> <p>Parameters:</p> Name Type Description Default <code>buffer</code> <p>memoryview object of the encoded bytes</p> required <code>pos</code> <p>int of the current position to start from</p> required <p>Returns:</p> Type Description <p>Tuple[bytes, int] of the tag data and new position.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/internal/decoder.py</code> <pre><code>def ReadTag(buffer, pos):\n  \"\"\"Read a tag from the memoryview, and return a (tag_bytes, new_pos) tuple.\n\n  We return the raw bytes of the tag rather than decoding them.  The raw\n  bytes can then be used to look up the proper decoder.  This effectively allows\n  us to trade some work that would be done in pure-python (decoding a varint)\n  for work that is done in C (searching for a byte string in a hash table).\n  In a low-level language it would be much cheaper to decode the varint and\n  use that, but not in Python.\n\n  Args:\n    buffer: memoryview object of the encoded bytes\n    pos: int of the current position to start from\n\n  Returns:\n    Tuple[bytes, int] of the tag data and new position.\n  \"\"\"\n  start = pos\n  while buffer[pos] &amp; 0x80:\n    pos += 1\n  pos += 1\n\n  tag_bytes = buffer[start:pos].tobytes()\n  return tag_bytes, pos\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/internal/decoder.html#client.ayon_hiero.vendor.google.protobuf.internal.decoder.StringDecoder","title":"<code>StringDecoder(field_number, is_repeated, is_packed, key, new_default, clear_if_default=False)</code>","text":"<p>Returns a decoder for a string field.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/internal/decoder.py</code> <pre><code>def StringDecoder(field_number, is_repeated, is_packed, key, new_default,\n                  clear_if_default=False):\n  \"\"\"Returns a decoder for a string field.\"\"\"\n\n  local_DecodeVarint = _DecodeVarint\n\n  def _ConvertToUnicode(memview):\n    \"\"\"Convert byte to unicode.\"\"\"\n    byte_str = memview.tobytes()\n    try:\n      value = str(byte_str, 'utf-8')\n    except UnicodeDecodeError as e:\n      # add more information to the error message and re-raise it.\n      e.reason = '%s in field: %s' % (e, key.full_name)\n      raise\n\n    return value\n\n  assert not is_packed\n  if is_repeated:\n    tag_bytes = encoder.TagBytes(field_number,\n                                 wire_format.WIRETYPE_LENGTH_DELIMITED)\n    tag_len = len(tag_bytes)\n    def DecodeRepeatedField(buffer, pos, end, message, field_dict):\n      value = field_dict.get(key)\n      if value is None:\n        value = field_dict.setdefault(key, new_default(message))\n      while 1:\n        (size, pos) = local_DecodeVarint(buffer, pos)\n        new_pos = pos + size\n        if new_pos &gt; end:\n          raise _DecodeError('Truncated string.')\n        value.append(_ConvertToUnicode(buffer[pos:new_pos]))\n        # Predict that the next tag is another copy of the same repeated field.\n        pos = new_pos + tag_len\n        if buffer[new_pos:pos] != tag_bytes or new_pos == end:\n          # Prediction failed.  Return.\n          return new_pos\n    return DecodeRepeatedField\n  else:\n    def DecodeField(buffer, pos, end, message, field_dict):\n      (size, pos) = local_DecodeVarint(buffer, pos)\n      new_pos = pos + size\n      if new_pos &gt; end:\n        raise _DecodeError('Truncated string.')\n      if clear_if_default and not size:\n        field_dict.pop(key, None)\n      else:\n        field_dict[key] = _ConvertToUnicode(buffer[pos:new_pos])\n      return new_pos\n    return DecodeField\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/internal/encoder.html","title":"encoder","text":"<p>Code for encoding protocol message primitives.</p> <p>Contains the logic for encoding every logical protocol field type into one of the 5 physical wire types.</p> <p>This code is designed to push the Python interpreter's performance to the limits.</p> <p>The basic idea is that at startup time, for every field (i.e. every FieldDescriptor) we construct two functions:  a \"sizer\" and an \"encoder\".  The sizer takes a value of this field's type and computes its byte size.  The encoder takes a writer function and a value.  It encodes the value into byte strings and invokes the writer function to write those strings.  Typically the writer function is the write() method of a BytesIO.</p> <p>We try to do as much work as possible when constructing the writer and the sizer rather than when calling them.  In particular: * We copy any needed global functions to local variables, so that we do not need   to do costly global table lookups at runtime. * Similarly, we try to do any attribute lookups at startup time if possible. * Every field's tag is encoded to bytes at startup, since it can't change at   runtime. * Whatever component of the field size we can compute at startup, we do. * We avoid sharing code if doing so would make the code slower and not sharing   does not burden us too much.  For example, encoders for repeated fields do   not just call the encoders for singular fields in a loop because this would   add an extra function call overhead for every loop iteration; instead, we   manually inline the single-value encoder into the loop. * If a Python function lacks a return statement, Python actually generates   instructions to pop the result of the last statement off the stack, push   None onto the stack, and then return that.  If we really don't care what   value is returned, then we can save two instructions by returning the   result of the last statement.  It looks funny but it helps. * We assume that type and bounds checking has happened at a higher level.</p>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/internal/encoder.html#client.ayon_hiero.vendor.google.protobuf.internal.encoder.BoolEncoder","title":"<code>BoolEncoder(field_number, is_repeated, is_packed)</code>","text":"<p>Returns an encoder for a boolean field.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/internal/encoder.py</code> <pre><code>def BoolEncoder(field_number, is_repeated, is_packed):\n  \"\"\"Returns an encoder for a boolean field.\"\"\"\n\n  false_byte = b'\\x00'\n  true_byte = b'\\x01'\n  if is_packed:\n    tag_bytes = TagBytes(field_number, wire_format.WIRETYPE_LENGTH_DELIMITED)\n    local_EncodeVarint = _EncodeVarint\n    def EncodePackedField(write, value, deterministic):\n      write(tag_bytes)\n      local_EncodeVarint(write, len(value), deterministic)\n      for element in value:\n        if element:\n          write(true_byte)\n        else:\n          write(false_byte)\n    return EncodePackedField\n  elif is_repeated:\n    tag_bytes = TagBytes(field_number, wire_format.WIRETYPE_VARINT)\n    def EncodeRepeatedField(write, value, unused_deterministic=None):\n      for element in value:\n        write(tag_bytes)\n        if element:\n          write(true_byte)\n        else:\n          write(false_byte)\n    return EncodeRepeatedField\n  else:\n    tag_bytes = TagBytes(field_number, wire_format.WIRETYPE_VARINT)\n    def EncodeField(write, value, unused_deterministic=None):\n      write(tag_bytes)\n      if value:\n        return write(true_byte)\n      return write(false_byte)\n    return EncodeField\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/internal/encoder.html#client.ayon_hiero.vendor.google.protobuf.internal.encoder.BytesEncoder","title":"<code>BytesEncoder(field_number, is_repeated, is_packed)</code>","text":"<p>Returns an encoder for a bytes field.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/internal/encoder.py</code> <pre><code>def BytesEncoder(field_number, is_repeated, is_packed):\n  \"\"\"Returns an encoder for a bytes field.\"\"\"\n\n  tag = TagBytes(field_number, wire_format.WIRETYPE_LENGTH_DELIMITED)\n  local_EncodeVarint = _EncodeVarint\n  local_len = len\n  assert not is_packed\n  if is_repeated:\n    def EncodeRepeatedField(write, value, deterministic):\n      for element in value:\n        write(tag)\n        local_EncodeVarint(write, local_len(element), deterministic)\n        write(element)\n    return EncodeRepeatedField\n  else:\n    def EncodeField(write, value, deterministic):\n      write(tag)\n      local_EncodeVarint(write, local_len(value), deterministic)\n      return write(value)\n    return EncodeField\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/internal/encoder.html#client.ayon_hiero.vendor.google.protobuf.internal.encoder.BytesSizer","title":"<code>BytesSizer(field_number, is_repeated, is_packed)</code>","text":"<p>Returns a sizer for a bytes field.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/internal/encoder.py</code> <pre><code>def BytesSizer(field_number, is_repeated, is_packed):\n  \"\"\"Returns a sizer for a bytes field.\"\"\"\n\n  tag_size = _TagSize(field_number)\n  local_VarintSize = _VarintSize\n  local_len = len\n  assert not is_packed\n  if is_repeated:\n    def RepeatedFieldSize(value):\n      result = tag_size * len(value)\n      for element in value:\n        l = local_len(element)\n        result += local_VarintSize(l) + l\n      return result\n    return RepeatedFieldSize\n  else:\n    def FieldSize(value):\n      l = local_len(value)\n      return tag_size + local_VarintSize(l) + l\n    return FieldSize\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/internal/encoder.html#client.ayon_hiero.vendor.google.protobuf.internal.encoder.GroupEncoder","title":"<code>GroupEncoder(field_number, is_repeated, is_packed)</code>","text":"<p>Returns an encoder for a group field.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/internal/encoder.py</code> <pre><code>def GroupEncoder(field_number, is_repeated, is_packed):\n  \"\"\"Returns an encoder for a group field.\"\"\"\n\n  start_tag = TagBytes(field_number, wire_format.WIRETYPE_START_GROUP)\n  end_tag = TagBytes(field_number, wire_format.WIRETYPE_END_GROUP)\n  assert not is_packed\n  if is_repeated:\n    def EncodeRepeatedField(write, value, deterministic):\n      for element in value:\n        write(start_tag)\n        element._InternalSerialize(write, deterministic)\n        write(end_tag)\n    return EncodeRepeatedField\n  else:\n    def EncodeField(write, value, deterministic):\n      write(start_tag)\n      value._InternalSerialize(write, deterministic)\n      return write(end_tag)\n    return EncodeField\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/internal/encoder.html#client.ayon_hiero.vendor.google.protobuf.internal.encoder.GroupSizer","title":"<code>GroupSizer(field_number, is_repeated, is_packed)</code>","text":"<p>Returns a sizer for a group field.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/internal/encoder.py</code> <pre><code>def GroupSizer(field_number, is_repeated, is_packed):\n  \"\"\"Returns a sizer for a group field.\"\"\"\n\n  tag_size = _TagSize(field_number) * 2\n  assert not is_packed\n  if is_repeated:\n    def RepeatedFieldSize(value):\n      result = tag_size * len(value)\n      for element in value:\n        result += element.ByteSize()\n      return result\n    return RepeatedFieldSize\n  else:\n    def FieldSize(value):\n      return tag_size + value.ByteSize()\n    return FieldSize\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/internal/encoder.html#client.ayon_hiero.vendor.google.protobuf.internal.encoder.MapEncoder","title":"<code>MapEncoder(field_descriptor)</code>","text":"<p>Encoder for extensions of MessageSet.</p> Maps always have a wire format like this <p>message MapEntry {   key_type key = 1;   value_type value = 2; } repeated MapEntry map = N;</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/internal/encoder.py</code> <pre><code>def MapEncoder(field_descriptor):\n  \"\"\"Encoder for extensions of MessageSet.\n\n  Maps always have a wire format like this:\n    message MapEntry {\n      key_type key = 1;\n      value_type value = 2;\n    }\n    repeated MapEntry map = N;\n  \"\"\"\n  # Can't look at field_descriptor.message_type._concrete_class because it may\n  # not have been initialized yet.\n  message_type = field_descriptor.message_type\n  encode_message = MessageEncoder(field_descriptor.number, False, False)\n\n  def EncodeField(write, value, deterministic):\n    value_keys = sorted(value.keys()) if deterministic else value\n    for key in value_keys:\n      entry_msg = message_type._concrete_class(key=key, value=value[key])\n      encode_message(write, entry_msg, deterministic)\n\n  return EncodeField\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/internal/encoder.html#client.ayon_hiero.vendor.google.protobuf.internal.encoder.MapSizer","title":"<code>MapSizer(field_descriptor, is_message_map)</code>","text":"<p>Returns a sizer for a map field.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/internal/encoder.py</code> <pre><code>def MapSizer(field_descriptor, is_message_map):\n  \"\"\"Returns a sizer for a map field.\"\"\"\n\n  # Can't look at field_descriptor.message_type._concrete_class because it may\n  # not have been initialized yet.\n  message_type = field_descriptor.message_type\n  message_sizer = MessageSizer(field_descriptor.number, False, False)\n\n  def FieldSize(map_value):\n    total = 0\n    for key in map_value:\n      value = map_value[key]\n      # It's wasteful to create the messages and throw them away one second\n      # later since we'll do the same for the actual encode.  But there's not an\n      # obvious way to avoid this within the current design without tons of code\n      # duplication. For message map, value.ByteSize() should be called to\n      # update the status.\n      entry_msg = message_type._concrete_class(key=key, value=value)\n      total += message_sizer(entry_msg)\n      if is_message_map:\n        value.ByteSize()\n    return total\n\n  return FieldSize\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/internal/encoder.html#client.ayon_hiero.vendor.google.protobuf.internal.encoder.MessageEncoder","title":"<code>MessageEncoder(field_number, is_repeated, is_packed)</code>","text":"<p>Returns an encoder for a message field.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/internal/encoder.py</code> <pre><code>def MessageEncoder(field_number, is_repeated, is_packed):\n  \"\"\"Returns an encoder for a message field.\"\"\"\n\n  tag = TagBytes(field_number, wire_format.WIRETYPE_LENGTH_DELIMITED)\n  local_EncodeVarint = _EncodeVarint\n  assert not is_packed\n  if is_repeated:\n    def EncodeRepeatedField(write, value, deterministic):\n      for element in value:\n        write(tag)\n        local_EncodeVarint(write, element.ByteSize(), deterministic)\n        element._InternalSerialize(write, deterministic)\n    return EncodeRepeatedField\n  else:\n    def EncodeField(write, value, deterministic):\n      write(tag)\n      local_EncodeVarint(write, value.ByteSize(), deterministic)\n      return value._InternalSerialize(write, deterministic)\n    return EncodeField\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/internal/encoder.html#client.ayon_hiero.vendor.google.protobuf.internal.encoder.MessageSetItemEncoder","title":"<code>MessageSetItemEncoder(field_number)</code>","text":"<p>Encoder for extensions of MessageSet.</p> The message set message looks like this <p>message MessageSet {   repeated group Item = 1 {     required int32 type_id = 2;     required string message = 3;   } }</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/internal/encoder.py</code> <pre><code>def MessageSetItemEncoder(field_number):\n  \"\"\"Encoder for extensions of MessageSet.\n\n  The message set message looks like this:\n    message MessageSet {\n      repeated group Item = 1 {\n        required int32 type_id = 2;\n        required string message = 3;\n      }\n    }\n  \"\"\"\n  start_bytes = b\"\".join([\n      TagBytes(1, wire_format.WIRETYPE_START_GROUP),\n      TagBytes(2, wire_format.WIRETYPE_VARINT),\n      _VarintBytes(field_number),\n      TagBytes(3, wire_format.WIRETYPE_LENGTH_DELIMITED)])\n  end_bytes = TagBytes(1, wire_format.WIRETYPE_END_GROUP)\n  local_EncodeVarint = _EncodeVarint\n\n  def EncodeField(write, value, deterministic):\n    write(start_bytes)\n    local_EncodeVarint(write, value.ByteSize(), deterministic)\n    value._InternalSerialize(write, deterministic)\n    return write(end_bytes)\n\n  return EncodeField\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/internal/encoder.html#client.ayon_hiero.vendor.google.protobuf.internal.encoder.MessageSetItemSizer","title":"<code>MessageSetItemSizer(field_number)</code>","text":"<p>Returns a sizer for extensions of MessageSet.</p> The message set message looks like this <p>message MessageSet {   repeated group Item = 1 {     required int32 type_id = 2;     required string message = 3;   } }</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/internal/encoder.py</code> <pre><code>def MessageSetItemSizer(field_number):\n  \"\"\"Returns a sizer for extensions of MessageSet.\n\n  The message set message looks like this:\n    message MessageSet {\n      repeated group Item = 1 {\n        required int32 type_id = 2;\n        required string message = 3;\n      }\n    }\n  \"\"\"\n  static_size = (_TagSize(1) * 2 + _TagSize(2) + _VarintSize(field_number) +\n                 _TagSize(3))\n  local_VarintSize = _VarintSize\n\n  def FieldSize(value):\n    l = value.ByteSize()\n    return static_size + local_VarintSize(l) + l\n\n  return FieldSize\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/internal/encoder.html#client.ayon_hiero.vendor.google.protobuf.internal.encoder.MessageSizer","title":"<code>MessageSizer(field_number, is_repeated, is_packed)</code>","text":"<p>Returns a sizer for a message field.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/internal/encoder.py</code> <pre><code>def MessageSizer(field_number, is_repeated, is_packed):\n  \"\"\"Returns a sizer for a message field.\"\"\"\n\n  tag_size = _TagSize(field_number)\n  local_VarintSize = _VarintSize\n  assert not is_packed\n  if is_repeated:\n    def RepeatedFieldSize(value):\n      result = tag_size * len(value)\n      for element in value:\n        l = element.ByteSize()\n        result += local_VarintSize(l) + l\n      return result\n    return RepeatedFieldSize\n  else:\n    def FieldSize(value):\n      l = value.ByteSize()\n      return tag_size + local_VarintSize(l) + l\n    return FieldSize\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/internal/encoder.html#client.ayon_hiero.vendor.google.protobuf.internal.encoder.StringEncoder","title":"<code>StringEncoder(field_number, is_repeated, is_packed)</code>","text":"<p>Returns an encoder for a string field.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/internal/encoder.py</code> <pre><code>def StringEncoder(field_number, is_repeated, is_packed):\n  \"\"\"Returns an encoder for a string field.\"\"\"\n\n  tag = TagBytes(field_number, wire_format.WIRETYPE_LENGTH_DELIMITED)\n  local_EncodeVarint = _EncodeVarint\n  local_len = len\n  assert not is_packed\n  if is_repeated:\n    def EncodeRepeatedField(write, value, deterministic):\n      for element in value:\n        encoded = element.encode('utf-8')\n        write(tag)\n        local_EncodeVarint(write, local_len(encoded), deterministic)\n        write(encoded)\n    return EncodeRepeatedField\n  else:\n    def EncodeField(write, value, deterministic):\n      encoded = value.encode('utf-8')\n      write(tag)\n      local_EncodeVarint(write, local_len(encoded), deterministic)\n      return write(encoded)\n    return EncodeField\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/internal/encoder.html#client.ayon_hiero.vendor.google.protobuf.internal.encoder.StringSizer","title":"<code>StringSizer(field_number, is_repeated, is_packed)</code>","text":"<p>Returns a sizer for a string field.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/internal/encoder.py</code> <pre><code>def StringSizer(field_number, is_repeated, is_packed):\n  \"\"\"Returns a sizer for a string field.\"\"\"\n\n  tag_size = _TagSize(field_number)\n  local_VarintSize = _VarintSize\n  local_len = len\n  assert not is_packed\n  if is_repeated:\n    def RepeatedFieldSize(value):\n      result = tag_size * len(value)\n      for element in value:\n        l = local_len(element.encode('utf-8'))\n        result += local_VarintSize(l) + l\n      return result\n    return RepeatedFieldSize\n  else:\n    def FieldSize(value):\n      l = local_len(value.encode('utf-8'))\n      return tag_size + local_VarintSize(l) + l\n    return FieldSize\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/internal/encoder.html#client.ayon_hiero.vendor.google.protobuf.internal.encoder.TagBytes","title":"<code>TagBytes(field_number, wire_type)</code>","text":"<p>Encode the given tag and return the bytes.  Only called at startup.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/internal/encoder.py</code> <pre><code>def TagBytes(field_number, wire_type):\n  \"\"\"Encode the given tag and return the bytes.  Only called at startup.\"\"\"\n\n  return bytes(_VarintBytes(wire_format.PackTag(field_number, wire_type)))\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/internal/enum_type_wrapper.html","title":"enum_type_wrapper","text":"<p>A simple wrapper around enum types to expose utility functions.</p> <p>Instances are created as properties with the same name as the enum they wrap on proto classes.  For usage, see:   reflection_test.py</p>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/internal/enum_type_wrapper.html#client.ayon_hiero.vendor.google.protobuf.internal.enum_type_wrapper.EnumTypeWrapper","title":"<code>EnumTypeWrapper</code>","text":"<p>               Bases: <code>object</code></p> <p>A utility for finding the names of enum values.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/internal/enum_type_wrapper.py</code> <pre><code>class EnumTypeWrapper(object):\n  \"\"\"A utility for finding the names of enum values.\"\"\"\n\n  DESCRIPTOR = None\n\n  # This is a type alias, which mypy typing stubs can type as\n  # a genericized parameter constrained to an int, allowing subclasses\n  # to be typed with more constraint in .pyi stubs\n  # Eg.\n  # def MyGeneratedEnum(Message):\n  #   ValueType = NewType('ValueType', int)\n  #   def Name(self, number: MyGeneratedEnum.ValueType) -&gt; str\n  ValueType = int\n\n  def __init__(self, enum_type):\n    \"\"\"Inits EnumTypeWrapper with an EnumDescriptor.\"\"\"\n    self._enum_type = enum_type\n    self.DESCRIPTOR = enum_type  # pylint: disable=invalid-name\n\n  def Name(self, number):  # pylint: disable=invalid-name\n    \"\"\"Returns a string containing the name of an enum value.\"\"\"\n    try:\n      return self._enum_type.values_by_number[number].name\n    except KeyError:\n      pass  # fall out to break exception chaining\n\n    if not isinstance(number, int):\n      raise TypeError(\n          'Enum value for {} must be an int, but got {} {!r}.'.format(\n              self._enum_type.name, type(number), number))\n    else:\n      # repr here to handle the odd case when you pass in a boolean.\n      raise ValueError('Enum {} has no name defined for value {!r}'.format(\n          self._enum_type.name, number))\n\n  def Value(self, name):  # pylint: disable=invalid-name\n    \"\"\"Returns the value corresponding to the given enum name.\"\"\"\n    try:\n      return self._enum_type.values_by_name[name].number\n    except KeyError:\n      pass  # fall out to break exception chaining\n    raise ValueError('Enum {} has no value defined for name {!r}'.format(\n        self._enum_type.name, name))\n\n  def keys(self):\n    \"\"\"Return a list of the string names in the enum.\n\n    Returns:\n      A list of strs, in the order they were defined in the .proto file.\n    \"\"\"\n\n    return [value_descriptor.name\n            for value_descriptor in self._enum_type.values]\n\n  def values(self):\n    \"\"\"Return a list of the integer values in the enum.\n\n    Returns:\n      A list of ints, in the order they were defined in the .proto file.\n    \"\"\"\n\n    return [value_descriptor.number\n            for value_descriptor in self._enum_type.values]\n\n  def items(self):\n    \"\"\"Return a list of the (name, value) pairs of the enum.\n\n    Returns:\n      A list of (str, int) pairs, in the order they were defined\n      in the .proto file.\n    \"\"\"\n    return [(value_descriptor.name, value_descriptor.number)\n            for value_descriptor in self._enum_type.values]\n\n  def __getattr__(self, name):\n    \"\"\"Returns the value corresponding to the given enum name.\"\"\"\n    try:\n      return super(\n          EnumTypeWrapper,\n          self).__getattribute__('_enum_type').values_by_name[name].number\n    except KeyError:\n      pass  # fall out to break exception chaining\n    raise AttributeError('Enum {} has no value defined for name {!r}'.format(\n        self._enum_type.name, name))\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/internal/enum_type_wrapper.html#client.ayon_hiero.vendor.google.protobuf.internal.enum_type_wrapper.EnumTypeWrapper.Name","title":"<code>Name(number)</code>","text":"<p>Returns a string containing the name of an enum value.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/internal/enum_type_wrapper.py</code> <pre><code>def Name(self, number):  # pylint: disable=invalid-name\n  \"\"\"Returns a string containing the name of an enum value.\"\"\"\n  try:\n    return self._enum_type.values_by_number[number].name\n  except KeyError:\n    pass  # fall out to break exception chaining\n\n  if not isinstance(number, int):\n    raise TypeError(\n        'Enum value for {} must be an int, but got {} {!r}.'.format(\n            self._enum_type.name, type(number), number))\n  else:\n    # repr here to handle the odd case when you pass in a boolean.\n    raise ValueError('Enum {} has no name defined for value {!r}'.format(\n        self._enum_type.name, number))\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/internal/enum_type_wrapper.html#client.ayon_hiero.vendor.google.protobuf.internal.enum_type_wrapper.EnumTypeWrapper.Value","title":"<code>Value(name)</code>","text":"<p>Returns the value corresponding to the given enum name.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/internal/enum_type_wrapper.py</code> <pre><code>def Value(self, name):  # pylint: disable=invalid-name\n  \"\"\"Returns the value corresponding to the given enum name.\"\"\"\n  try:\n    return self._enum_type.values_by_name[name].number\n  except KeyError:\n    pass  # fall out to break exception chaining\n  raise ValueError('Enum {} has no value defined for name {!r}'.format(\n      self._enum_type.name, name))\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/internal/enum_type_wrapper.html#client.ayon_hiero.vendor.google.protobuf.internal.enum_type_wrapper.EnumTypeWrapper.__getattr__","title":"<code>__getattr__(name)</code>","text":"<p>Returns the value corresponding to the given enum name.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/internal/enum_type_wrapper.py</code> <pre><code>def __getattr__(self, name):\n  \"\"\"Returns the value corresponding to the given enum name.\"\"\"\n  try:\n    return super(\n        EnumTypeWrapper,\n        self).__getattribute__('_enum_type').values_by_name[name].number\n  except KeyError:\n    pass  # fall out to break exception chaining\n  raise AttributeError('Enum {} has no value defined for name {!r}'.format(\n      self._enum_type.name, name))\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/internal/enum_type_wrapper.html#client.ayon_hiero.vendor.google.protobuf.internal.enum_type_wrapper.EnumTypeWrapper.__init__","title":"<code>__init__(enum_type)</code>","text":"<p>Inits EnumTypeWrapper with an EnumDescriptor.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/internal/enum_type_wrapper.py</code> <pre><code>def __init__(self, enum_type):\n  \"\"\"Inits EnumTypeWrapper with an EnumDescriptor.\"\"\"\n  self._enum_type = enum_type\n  self.DESCRIPTOR = enum_type  # pylint: disable=invalid-name\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/internal/enum_type_wrapper.html#client.ayon_hiero.vendor.google.protobuf.internal.enum_type_wrapper.EnumTypeWrapper.items","title":"<code>items()</code>","text":"<p>Return a list of the (name, value) pairs of the enum.</p> <p>Returns:</p> Type Description <p>A list of (str, int) pairs, in the order they were defined</p> <p>in the .proto file.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/internal/enum_type_wrapper.py</code> <pre><code>def items(self):\n  \"\"\"Return a list of the (name, value) pairs of the enum.\n\n  Returns:\n    A list of (str, int) pairs, in the order they were defined\n    in the .proto file.\n  \"\"\"\n  return [(value_descriptor.name, value_descriptor.number)\n          for value_descriptor in self._enum_type.values]\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/internal/enum_type_wrapper.html#client.ayon_hiero.vendor.google.protobuf.internal.enum_type_wrapper.EnumTypeWrapper.keys","title":"<code>keys()</code>","text":"<p>Return a list of the string names in the enum.</p> <p>Returns:</p> Type Description <p>A list of strs, in the order they were defined in the .proto file.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/internal/enum_type_wrapper.py</code> <pre><code>def keys(self):\n  \"\"\"Return a list of the string names in the enum.\n\n  Returns:\n    A list of strs, in the order they were defined in the .proto file.\n  \"\"\"\n\n  return [value_descriptor.name\n          for value_descriptor in self._enum_type.values]\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/internal/enum_type_wrapper.html#client.ayon_hiero.vendor.google.protobuf.internal.enum_type_wrapper.EnumTypeWrapper.values","title":"<code>values()</code>","text":"<p>Return a list of the integer values in the enum.</p> <p>Returns:</p> Type Description <p>A list of ints, in the order they were defined in the .proto file.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/internal/enum_type_wrapper.py</code> <pre><code>def values(self):\n  \"\"\"Return a list of the integer values in the enum.\n\n  Returns:\n    A list of ints, in the order they were defined in the .proto file.\n  \"\"\"\n\n  return [value_descriptor.number\n          for value_descriptor in self._enum_type.values]\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/internal/extension_dict.html","title":"extension_dict","text":"<p>Contains _ExtensionDict class to represent extensions.</p>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/internal/message_listener.html","title":"message_listener","text":"<p>Defines a listener interface for observing certain state transitions on Message objects.</p> <p>Also defines a null implementation of this interface.</p>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/internal/message_listener.html#client.ayon_hiero.vendor.google.protobuf.internal.message_listener.MessageListener","title":"<code>MessageListener</code>","text":"<p>               Bases: <code>object</code></p> <p>Listens for modifications made to a message.  Meant to be registered via Message._SetListener().</p> <p>Attributes:</p> Name Type Description <code>dirty</code> <p>If True, then calling Modified() would be a no-op.  This can be       used to avoid these calls entirely in the common case.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/internal/message_listener.py</code> <pre><code>class MessageListener(object):\n\n  \"\"\"Listens for modifications made to a message.  Meant to be registered via\n  Message._SetListener().\n\n  Attributes:\n    dirty:  If True, then calling Modified() would be a no-op.  This can be\n            used to avoid these calls entirely in the common case.\n  \"\"\"\n\n  def Modified(self):\n    \"\"\"Called every time the message is modified in such a way that the parent\n    message may need to be updated.  This currently means either:\n    (a) The message was modified for the first time, so the parent message\n        should henceforth mark the message as present.\n    (b) The message's cached byte size became dirty -- i.e. the message was\n        modified for the first time after a previous call to ByteSize().\n        Therefore the parent should also mark its byte size as dirty.\n    Note that (a) implies (b), since new objects start out with a client cached\n    size (zero).  However, we document (a) explicitly because it is important.\n\n    Modified() will *only* be called in response to one of these two events --\n    not every time the sub-message is modified.\n\n    Note that if the listener's |dirty| attribute is true, then calling\n    Modified at the moment would be a no-op, so it can be skipped.  Performance-\n    sensitive callers should check this attribute directly before calling since\n    it will be true most of the time.\n    \"\"\"\n\n    raise NotImplementedError\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/internal/message_listener.html#client.ayon_hiero.vendor.google.protobuf.internal.message_listener.MessageListener.Modified","title":"<code>Modified()</code>","text":"<p>Called every time the message is modified in such a way that the parent message may need to be updated.  This currently means either: (a) The message was modified for the first time, so the parent message     should henceforth mark the message as present. (b) The message's cached byte size became dirty -- i.e. the message was     modified for the first time after a previous call to ByteSize().     Therefore the parent should also mark its byte size as dirty. Note that (a) implies (b), since new objects start out with a client cached size (zero).  However, we document (a) explicitly because it is important.</p> <p>Modified() will only be called in response to one of these two events -- not every time the sub-message is modified.</p> <p>Note that if the listener's |dirty| attribute is true, then calling Modified at the moment would be a no-op, so it can be skipped.  Performance- sensitive callers should check this attribute directly before calling since it will be true most of the time.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/internal/message_listener.py</code> <pre><code>def Modified(self):\n  \"\"\"Called every time the message is modified in such a way that the parent\n  message may need to be updated.  This currently means either:\n  (a) The message was modified for the first time, so the parent message\n      should henceforth mark the message as present.\n  (b) The message's cached byte size became dirty -- i.e. the message was\n      modified for the first time after a previous call to ByteSize().\n      Therefore the parent should also mark its byte size as dirty.\n  Note that (a) implies (b), since new objects start out with a client cached\n  size (zero).  However, we document (a) explicitly because it is important.\n\n  Modified() will *only* be called in response to one of these two events --\n  not every time the sub-message is modified.\n\n  Note that if the listener's |dirty| attribute is true, then calling\n  Modified at the moment would be a no-op, so it can be skipped.  Performance-\n  sensitive callers should check this attribute directly before calling since\n  it will be true most of the time.\n  \"\"\"\n\n  raise NotImplementedError\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/internal/message_listener.html#client.ayon_hiero.vendor.google.protobuf.internal.message_listener.NullMessageListener","title":"<code>NullMessageListener</code>","text":"<p>               Bases: <code>object</code></p> <p>No-op MessageListener implementation.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/internal/message_listener.py</code> <pre><code>class NullMessageListener(object):\n\n  \"\"\"No-op MessageListener implementation.\"\"\"\n\n  def Modified(self):\n    pass\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/internal/message_set_extensions_pb2.html","title":"message_set_extensions_pb2","text":"<p>Generated protocol buffer code.</p>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/internal/missing_enum_values_pb2.html","title":"missing_enum_values_pb2","text":"<p>Generated protocol buffer code.</p>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/internal/more_extensions_dynamic_pb2.html","title":"more_extensions_dynamic_pb2","text":"<p>Generated protocol buffer code.</p>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/internal/more_extensions_pb2.html","title":"more_extensions_pb2","text":"<p>Generated protocol buffer code.</p>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/internal/more_messages_pb2.html","title":"more_messages_pb2","text":"<p>Generated protocol buffer code.</p>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/internal/no_package_pb2.html","title":"no_package_pb2","text":"<p>Generated protocol buffer code.</p>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/internal/python_message.html","title":"python_message","text":"<p>Contains a metaclass and helper functions used to create protocol message classes from Descriptor objects at runtime.</p> <p>Recall that a metaclass is the \"type\" of a class. (A class is to a metaclass what an instance is to a class.)</p> <p>In this case, we use the GeneratedProtocolMessageType metaclass to inject all the useful functionality into the classes output by the protocol compiler at compile-time.</p> <p>The upshot of all this is that the real implementation details for ALL pure-Python protocol buffers are here in this file.</p>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/internal/python_message.html#client.ayon_hiero.vendor.google.protobuf.internal.python_message.GeneratedProtocolMessageType","title":"<code>GeneratedProtocolMessageType</code>","text":"<p>               Bases: <code>type</code></p> <p>Metaclass for protocol message classes created at runtime from Descriptors.</p> <p>We add implementations for all methods described in the Message class.  We also create properties to allow getting/setting all fields in the protocol message.  Finally, we create slots to prevent users from accidentally \"setting\" nonexistent fields in the protocol message, which then wouldn't get serialized / deserialized properly.</p> <p>The protocol compiler currently uses this metaclass to create protocol message classes at runtime.  Clients can also manually create their own classes at runtime, as in this example:</p> <p>mydescriptor = Descriptor(.....) factory = symbol_database.Default() factory.pool.AddDescriptor(mydescriptor) MyProtoClass = factory.GetPrototype(mydescriptor) myproto_instance = MyProtoClass() myproto.foo_field = 23 ...</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/internal/python_message.py</code> <pre><code>class GeneratedProtocolMessageType(type):\n\n  \"\"\"Metaclass for protocol message classes created at runtime from Descriptors.\n\n  We add implementations for all methods described in the Message class.  We\n  also create properties to allow getting/setting all fields in the protocol\n  message.  Finally, we create slots to prevent users from accidentally\n  \"setting\" nonexistent fields in the protocol message, which then wouldn't get\n  serialized / deserialized properly.\n\n  The protocol compiler currently uses this metaclass to create protocol\n  message classes at runtime.  Clients can also manually create their own\n  classes at runtime, as in this example:\n\n  mydescriptor = Descriptor(.....)\n  factory = symbol_database.Default()\n  factory.pool.AddDescriptor(mydescriptor)\n  MyProtoClass = factory.GetPrototype(mydescriptor)\n  myproto_instance = MyProtoClass()\n  myproto.foo_field = 23\n  ...\n  \"\"\"\n\n  # Must be consistent with the protocol-compiler code in\n  # proto2/compiler/internal/generator.*.\n  _DESCRIPTOR_KEY = 'DESCRIPTOR'\n\n  def __new__(cls, name, bases, dictionary):\n    \"\"\"Custom allocation for runtime-generated class types.\n\n    We override __new__ because this is apparently the only place\n    where we can meaningfully set __slots__ on the class we're creating(?).\n    (The interplay between metaclasses and slots is not very well-documented).\n\n    Args:\n      name: Name of the class (ignored, but required by the\n        metaclass protocol).\n      bases: Base classes of the class we're constructing.\n        (Should be message.Message).  We ignore this field, but\n        it's required by the metaclass protocol\n      dictionary: The class dictionary of the class we're\n        constructing.  dictionary[_DESCRIPTOR_KEY] must contain\n        a Descriptor object describing this protocol message\n        type.\n\n    Returns:\n      Newly-allocated class.\n\n    Raises:\n      RuntimeError: Generated code only work with python cpp extension.\n    \"\"\"\n    descriptor = dictionary[GeneratedProtocolMessageType._DESCRIPTOR_KEY]\n\n    if isinstance(descriptor, str):\n      raise RuntimeError('The generated code only work with python cpp '\n                         'extension, but it is using pure python runtime.')\n\n    # If a concrete class already exists for this descriptor, don't try to\n    # create another.  Doing so will break any messages that already exist with\n    # the existing class.\n    #\n    # The C++ implementation appears to have its own internal `PyMessageFactory`\n    # to achieve similar results.\n    #\n    # This most commonly happens in `text_format.py` when using descriptors from\n    # a custom pool; it calls symbol_database.Global().getPrototype() on a\n    # descriptor which already has an existing concrete class.\n    new_class = getattr(descriptor, '_concrete_class', None)\n    if new_class:\n      return new_class\n\n    if descriptor.full_name in well_known_types.WKTBASES:\n      bases += (well_known_types.WKTBASES[descriptor.full_name],)\n    _AddClassAttributesForNestedExtensions(descriptor, dictionary)\n    _AddSlots(descriptor, dictionary)\n\n    superclass = super(GeneratedProtocolMessageType, cls)\n    new_class = superclass.__new__(cls, name, bases, dictionary)\n    return new_class\n\n  def __init__(cls, name, bases, dictionary):\n    \"\"\"Here we perform the majority of our work on the class.\n    We add enum getters, an __init__ method, implementations\n    of all Message methods, and properties for all fields\n    in the protocol type.\n\n    Args:\n      name: Name of the class (ignored, but required by the\n        metaclass protocol).\n      bases: Base classes of the class we're constructing.\n        (Should be message.Message).  We ignore this field, but\n        it's required by the metaclass protocol\n      dictionary: The class dictionary of the class we're\n        constructing.  dictionary[_DESCRIPTOR_KEY] must contain\n        a Descriptor object describing this protocol message\n        type.\n    \"\"\"\n    descriptor = dictionary[GeneratedProtocolMessageType._DESCRIPTOR_KEY]\n\n    # If this is an _existing_ class looked up via `_concrete_class` in the\n    # __new__ method above, then we don't need to re-initialize anything.\n    existing_class = getattr(descriptor, '_concrete_class', None)\n    if existing_class:\n      assert existing_class is cls, (\n          'Duplicate `GeneratedProtocolMessageType` created for descriptor %r'\n          % (descriptor.full_name))\n      return\n\n    cls._decoders_by_tag = {}\n    if (descriptor.has_options and\n        descriptor.GetOptions().message_set_wire_format):\n      cls._decoders_by_tag[decoder.MESSAGE_SET_ITEM_TAG] = (\n          decoder.MessageSetItemDecoder(descriptor), None)\n\n    # Attach stuff to each FieldDescriptor for quick lookup later on.\n    for field in descriptor.fields:\n      _AttachFieldHelpers(cls, field)\n\n    descriptor._concrete_class = cls  # pylint: disable=protected-access\n    _AddEnumValues(descriptor, cls)\n    _AddInitMethod(descriptor, cls)\n    _AddPropertiesForFields(descriptor, cls)\n    _AddPropertiesForExtensions(descriptor, cls)\n    _AddStaticMethods(cls)\n    _AddMessageMethods(descriptor, cls)\n    _AddPrivateHelperMethods(descriptor, cls)\n\n    superclass = super(GeneratedProtocolMessageType, cls)\n    superclass.__init__(name, bases, dictionary)\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/internal/python_message.html#client.ayon_hiero.vendor.google.protobuf.internal.python_message.GeneratedProtocolMessageType.__init__","title":"<code>__init__(name, bases, dictionary)</code>","text":"<p>Here we perform the majority of our work on the class. We add enum getters, an init method, implementations of all Message methods, and properties for all fields in the protocol type.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <p>Name of the class (ignored, but required by the metaclass protocol).</p> required <code>bases</code> <p>Base classes of the class we're constructing. (Should be message.Message).  We ignore this field, but it's required by the metaclass protocol</p> required <code>dictionary</code> <p>The class dictionary of the class we're constructing.  dictionary[_DESCRIPTOR_KEY] must contain a Descriptor object describing this protocol message type.</p> required Source code in <code>client/ayon_hiero/vendor/google/protobuf/internal/python_message.py</code> <pre><code>def __init__(cls, name, bases, dictionary):\n  \"\"\"Here we perform the majority of our work on the class.\n  We add enum getters, an __init__ method, implementations\n  of all Message methods, and properties for all fields\n  in the protocol type.\n\n  Args:\n    name: Name of the class (ignored, but required by the\n      metaclass protocol).\n    bases: Base classes of the class we're constructing.\n      (Should be message.Message).  We ignore this field, but\n      it's required by the metaclass protocol\n    dictionary: The class dictionary of the class we're\n      constructing.  dictionary[_DESCRIPTOR_KEY] must contain\n      a Descriptor object describing this protocol message\n      type.\n  \"\"\"\n  descriptor = dictionary[GeneratedProtocolMessageType._DESCRIPTOR_KEY]\n\n  # If this is an _existing_ class looked up via `_concrete_class` in the\n  # __new__ method above, then we don't need to re-initialize anything.\n  existing_class = getattr(descriptor, '_concrete_class', None)\n  if existing_class:\n    assert existing_class is cls, (\n        'Duplicate `GeneratedProtocolMessageType` created for descriptor %r'\n        % (descriptor.full_name))\n    return\n\n  cls._decoders_by_tag = {}\n  if (descriptor.has_options and\n      descriptor.GetOptions().message_set_wire_format):\n    cls._decoders_by_tag[decoder.MESSAGE_SET_ITEM_TAG] = (\n        decoder.MessageSetItemDecoder(descriptor), None)\n\n  # Attach stuff to each FieldDescriptor for quick lookup later on.\n  for field in descriptor.fields:\n    _AttachFieldHelpers(cls, field)\n\n  descriptor._concrete_class = cls  # pylint: disable=protected-access\n  _AddEnumValues(descriptor, cls)\n  _AddInitMethod(descriptor, cls)\n  _AddPropertiesForFields(descriptor, cls)\n  _AddPropertiesForExtensions(descriptor, cls)\n  _AddStaticMethods(cls)\n  _AddMessageMethods(descriptor, cls)\n  _AddPrivateHelperMethods(descriptor, cls)\n\n  superclass = super(GeneratedProtocolMessageType, cls)\n  superclass.__init__(name, bases, dictionary)\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/internal/python_message.html#client.ayon_hiero.vendor.google.protobuf.internal.python_message.GeneratedProtocolMessageType.__new__","title":"<code>__new__(name, bases, dictionary)</code>","text":"<p>Custom allocation for runtime-generated class types.</p> <p>We override new because this is apparently the only place where we can meaningfully set slots on the class we're creating(?). (The interplay between metaclasses and slots is not very well-documented).</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <p>Name of the class (ignored, but required by the metaclass protocol).</p> required <code>bases</code> <p>Base classes of the class we're constructing. (Should be message.Message).  We ignore this field, but it's required by the metaclass protocol</p> required <code>dictionary</code> <p>The class dictionary of the class we're constructing.  dictionary[_DESCRIPTOR_KEY] must contain a Descriptor object describing this protocol message type.</p> required <p>Returns:</p> Type Description <p>Newly-allocated class.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>Generated code only work with python cpp extension.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/internal/python_message.py</code> <pre><code>def __new__(cls, name, bases, dictionary):\n  \"\"\"Custom allocation for runtime-generated class types.\n\n  We override __new__ because this is apparently the only place\n  where we can meaningfully set __slots__ on the class we're creating(?).\n  (The interplay between metaclasses and slots is not very well-documented).\n\n  Args:\n    name: Name of the class (ignored, but required by the\n      metaclass protocol).\n    bases: Base classes of the class we're constructing.\n      (Should be message.Message).  We ignore this field, but\n      it's required by the metaclass protocol\n    dictionary: The class dictionary of the class we're\n      constructing.  dictionary[_DESCRIPTOR_KEY] must contain\n      a Descriptor object describing this protocol message\n      type.\n\n  Returns:\n    Newly-allocated class.\n\n  Raises:\n    RuntimeError: Generated code only work with python cpp extension.\n  \"\"\"\n  descriptor = dictionary[GeneratedProtocolMessageType._DESCRIPTOR_KEY]\n\n  if isinstance(descriptor, str):\n    raise RuntimeError('The generated code only work with python cpp '\n                       'extension, but it is using pure python runtime.')\n\n  # If a concrete class already exists for this descriptor, don't try to\n  # create another.  Doing so will break any messages that already exist with\n  # the existing class.\n  #\n  # The C++ implementation appears to have its own internal `PyMessageFactory`\n  # to achieve similar results.\n  #\n  # This most commonly happens in `text_format.py` when using descriptors from\n  # a custom pool; it calls symbol_database.Global().getPrototype() on a\n  # descriptor which already has an existing concrete class.\n  new_class = getattr(descriptor, '_concrete_class', None)\n  if new_class:\n    return new_class\n\n  if descriptor.full_name in well_known_types.WKTBASES:\n    bases += (well_known_types.WKTBASES[descriptor.full_name],)\n  _AddClassAttributesForNestedExtensions(descriptor, dictionary)\n  _AddSlots(descriptor, dictionary)\n\n  superclass = super(GeneratedProtocolMessageType, cls)\n  new_class = superclass.__new__(cls, name, bases, dictionary)\n  return new_class\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/internal/type_checkers.html","title":"type_checkers","text":"<p>Provides type checking routines.</p> <p>This module defines type checking utilities in the forms of dictionaries:</p> <p>VALUE_CHECKERS: A dictionary of field types and a value validation object. TYPE_TO_BYTE_SIZE_FN: A dictionary with field types and a size computing   function. TYPE_TO_SERIALIZE_METHOD: A dictionary with field types and serialization   function. FIELD_TYPE_TO_WIRE_TYPE: A dictionary with field typed and their   corresponding wire types. TYPE_TO_DESERIALIZE_METHOD: A dictionary with field types and deserialization   function.</p>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/internal/type_checkers.html#client.ayon_hiero.vendor.google.protobuf.internal.type_checkers.BoolValueChecker","title":"<code>BoolValueChecker</code>","text":"<p>               Bases: <code>object</code></p> <p>Type checker used for bool fields.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/internal/type_checkers.py</code> <pre><code>class BoolValueChecker(object):\n  \"\"\"Type checker used for bool fields.\"\"\"\n\n  def CheckValue(self, proposed_value):\n    if not hasattr(proposed_value, '__index__') or (\n        type(proposed_value).__module__ == 'numpy' and\n        type(proposed_value).__name__ == 'ndarray'):\n      message = ('%.1024r has type %s, but expected one of: %s' %\n                 (proposed_value, type(proposed_value), (bool, int)))\n      raise TypeError(message)\n    return bool(proposed_value)\n\n  def DefaultValue(self):\n    return False\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/internal/type_checkers.html#client.ayon_hiero.vendor.google.protobuf.internal.type_checkers.DoubleValueChecker","title":"<code>DoubleValueChecker</code>","text":"<p>               Bases: <code>object</code></p> <p>Checker used for double fields.</p> <p>Performs type-check and range check.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/internal/type_checkers.py</code> <pre><code>class DoubleValueChecker(object):\n  \"\"\"Checker used for double fields.\n\n  Performs type-check and range check.\n  \"\"\"\n\n  def CheckValue(self, proposed_value):\n    \"\"\"Check and convert proposed_value to float.\"\"\"\n    if (not hasattr(proposed_value, '__float__') and\n        not hasattr(proposed_value, '__index__')) or (\n            type(proposed_value).__module__ == 'numpy' and\n            type(proposed_value).__name__ == 'ndarray'):\n      message = ('%.1024r has type %s, but expected one of: int, float' %\n                 (proposed_value, type(proposed_value)))\n      raise TypeError(message)\n    return float(proposed_value)\n\n  def DefaultValue(self):\n    return 0.0\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/internal/type_checkers.html#client.ayon_hiero.vendor.google.protobuf.internal.type_checkers.DoubleValueChecker.CheckValue","title":"<code>CheckValue(proposed_value)</code>","text":"<p>Check and convert proposed_value to float.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/internal/type_checkers.py</code> <pre><code>def CheckValue(self, proposed_value):\n  \"\"\"Check and convert proposed_value to float.\"\"\"\n  if (not hasattr(proposed_value, '__float__') and\n      not hasattr(proposed_value, '__index__')) or (\n          type(proposed_value).__module__ == 'numpy' and\n          type(proposed_value).__name__ == 'ndarray'):\n    message = ('%.1024r has type %s, but expected one of: int, float' %\n               (proposed_value, type(proposed_value)))\n    raise TypeError(message)\n  return float(proposed_value)\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/internal/type_checkers.html#client.ayon_hiero.vendor.google.protobuf.internal.type_checkers.EnumValueChecker","title":"<code>EnumValueChecker</code>","text":"<p>               Bases: <code>object</code></p> <p>Checker used for enum fields.  Performs type-check and range check.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/internal/type_checkers.py</code> <pre><code>class EnumValueChecker(object):\n\n  \"\"\"Checker used for enum fields.  Performs type-check and range check.\"\"\"\n\n  def __init__(self, enum_type):\n    self._enum_type = enum_type\n\n  def CheckValue(self, proposed_value):\n    if not isinstance(proposed_value, numbers.Integral):\n      message = ('%.1024r has type %s, but expected one of: %s' %\n                 (proposed_value, type(proposed_value), (int,)))\n      raise TypeError(message)\n    if int(proposed_value) not in self._enum_type.values_by_number:\n      raise ValueError('Unknown enum value: %d' % proposed_value)\n    return proposed_value\n\n  def DefaultValue(self):\n    return self._enum_type.values[0].number\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/internal/type_checkers.html#client.ayon_hiero.vendor.google.protobuf.internal.type_checkers.FloatValueChecker","title":"<code>FloatValueChecker</code>","text":"<p>               Bases: <code>DoubleValueChecker</code></p> <p>Checker used for float fields.</p> <p>Performs type-check and range check.</p> <p>Values exceeding a 32-bit float will be converted to inf/-inf.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/internal/type_checkers.py</code> <pre><code>class FloatValueChecker(DoubleValueChecker):\n  \"\"\"Checker used for float fields.\n\n  Performs type-check and range check.\n\n  Values exceeding a 32-bit float will be converted to inf/-inf.\n  \"\"\"\n\n  def CheckValue(self, proposed_value):\n    \"\"\"Check and convert proposed_value to float.\"\"\"\n    converted_value = super().CheckValue(proposed_value)\n    # This inf rounding matches the C++ proto SafeDoubleToFloat logic.\n    if converted_value &gt; _FLOAT_MAX:\n      return _INF\n    if converted_value &lt; _FLOAT_MIN:\n      return _NEG_INF\n\n    return TruncateToFourByteFloat(converted_value)\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/internal/type_checkers.html#client.ayon_hiero.vendor.google.protobuf.internal.type_checkers.FloatValueChecker.CheckValue","title":"<code>CheckValue(proposed_value)</code>","text":"<p>Check and convert proposed_value to float.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/internal/type_checkers.py</code> <pre><code>def CheckValue(self, proposed_value):\n  \"\"\"Check and convert proposed_value to float.\"\"\"\n  converted_value = super().CheckValue(proposed_value)\n  # This inf rounding matches the C++ proto SafeDoubleToFloat logic.\n  if converted_value &gt; _FLOAT_MAX:\n    return _INF\n  if converted_value &lt; _FLOAT_MIN:\n    return _NEG_INF\n\n  return TruncateToFourByteFloat(converted_value)\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/internal/type_checkers.html#client.ayon_hiero.vendor.google.protobuf.internal.type_checkers.IntValueChecker","title":"<code>IntValueChecker</code>","text":"<p>               Bases: <code>object</code></p> <p>Checker used for integer fields.  Performs type-check and range check.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/internal/type_checkers.py</code> <pre><code>class IntValueChecker(object):\n\n  \"\"\"Checker used for integer fields.  Performs type-check and range check.\"\"\"\n\n  def CheckValue(self, proposed_value):\n    if not hasattr(proposed_value, '__index__') or (\n        type(proposed_value).__module__ == 'numpy' and\n        type(proposed_value).__name__ == 'ndarray'):\n      message = ('%.1024r has type %s, but expected one of: %s' %\n                 (proposed_value, type(proposed_value), (int,)))\n      raise TypeError(message)\n\n    if not self._MIN &lt;= int(proposed_value) &lt;= self._MAX:\n      raise ValueError('Value out of range: %d' % proposed_value)\n    # We force all values to int to make alternate implementations where the\n    # distinction is more significant (e.g. the C++ implementation) simpler.\n    proposed_value = int(proposed_value)\n    return proposed_value\n\n  def DefaultValue(self):\n    return 0\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/internal/type_checkers.html#client.ayon_hiero.vendor.google.protobuf.internal.type_checkers.TypeChecker","title":"<code>TypeChecker</code>","text":"<p>               Bases: <code>object</code></p> <p>Type checker used to catch type errors as early as possible when the client is setting scalar fields in protocol messages.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/internal/type_checkers.py</code> <pre><code>class TypeChecker(object):\n\n  \"\"\"Type checker used to catch type errors as early as possible\n  when the client is setting scalar fields in protocol messages.\n  \"\"\"\n\n  def __init__(self, *acceptable_types):\n    self._acceptable_types = acceptable_types\n\n  def CheckValue(self, proposed_value):\n    \"\"\"Type check the provided value and return it.\n\n    The returned value might have been normalized to another type.\n    \"\"\"\n    if not isinstance(proposed_value, self._acceptable_types):\n      message = ('%.1024r has type %s, but expected one of: %s' %\n                 (proposed_value, type(proposed_value), self._acceptable_types))\n      raise TypeError(message)\n    return proposed_value\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/internal/type_checkers.html#client.ayon_hiero.vendor.google.protobuf.internal.type_checkers.TypeChecker.CheckValue","title":"<code>CheckValue(proposed_value)</code>","text":"<p>Type check the provided value and return it.</p> <p>The returned value might have been normalized to another type.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/internal/type_checkers.py</code> <pre><code>def CheckValue(self, proposed_value):\n  \"\"\"Type check the provided value and return it.\n\n  The returned value might have been normalized to another type.\n  \"\"\"\n  if not isinstance(proposed_value, self._acceptable_types):\n    message = ('%.1024r has type %s, but expected one of: %s' %\n               (proposed_value, type(proposed_value), self._acceptable_types))\n    raise TypeError(message)\n  return proposed_value\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/internal/type_checkers.html#client.ayon_hiero.vendor.google.protobuf.internal.type_checkers.UnicodeValueChecker","title":"<code>UnicodeValueChecker</code>","text":"<p>               Bases: <code>object</code></p> <p>Checker used for string fields.</p> <p>Always returns a unicode value, even if the input is of type str.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/internal/type_checkers.py</code> <pre><code>class UnicodeValueChecker(object):\n\n  \"\"\"Checker used for string fields.\n\n  Always returns a unicode value, even if the input is of type str.\n  \"\"\"\n\n  def CheckValue(self, proposed_value):\n    if not isinstance(proposed_value, (bytes, str)):\n      message = ('%.1024r has type %s, but expected one of: %s' %\n                 (proposed_value, type(proposed_value), (bytes, str)))\n      raise TypeError(message)\n\n    # If the value is of type 'bytes' make sure that it is valid UTF-8 data.\n    if isinstance(proposed_value, bytes):\n      try:\n        proposed_value = proposed_value.decode('utf-8')\n      except UnicodeDecodeError:\n        raise ValueError('%.1024r has type bytes, but isn\\'t valid UTF-8 '\n                         'encoding. Non-UTF-8 strings must be converted to '\n                         'unicode objects before being added.' %\n                         (proposed_value))\n    else:\n      try:\n        proposed_value.encode('utf8')\n      except UnicodeEncodeError:\n        raise ValueError('%.1024r isn\\'t a valid unicode string and '\n                         'can\\'t be encoded in UTF-8.'%\n                         (proposed_value))\n\n    return proposed_value\n\n  def DefaultValue(self):\n    return u\"\"\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/internal/type_checkers.html#client.ayon_hiero.vendor.google.protobuf.internal.type_checkers.GetTypeChecker","title":"<code>GetTypeChecker(field)</code>","text":"<p>Returns a type checker for a message field of the specified types.</p> <p>Parameters:</p> Name Type Description Default <code>field</code> <p>FieldDescriptor object for this field.</p> required <p>Returns:</p> Type Description <p>An instance of TypeChecker which can be used to verify the types</p> <p>of values assigned to a field of the specified type.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/internal/type_checkers.py</code> <pre><code>def GetTypeChecker(field):\n  \"\"\"Returns a type checker for a message field of the specified types.\n\n  Args:\n    field: FieldDescriptor object for this field.\n\n  Returns:\n    An instance of TypeChecker which can be used to verify the types\n    of values assigned to a field of the specified type.\n  \"\"\"\n  if (field.cpp_type == _FieldDescriptor.CPPTYPE_STRING and\n      field.type == _FieldDescriptor.TYPE_STRING):\n    return UnicodeValueChecker()\n  if field.cpp_type == _FieldDescriptor.CPPTYPE_ENUM:\n    if SupportsOpenEnums(field):\n      # When open enums are supported, any int32 can be assigned.\n      return _VALUE_CHECKERS[_FieldDescriptor.CPPTYPE_INT32]\n    else:\n      return EnumValueChecker(field.enum_type)\n  return _VALUE_CHECKERS[field.cpp_type]\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/internal/type_checkers.html#client.ayon_hiero.vendor.google.protobuf.internal.type_checkers.ToShortestFloat","title":"<code>ToShortestFloat(original)</code>","text":"<p>Returns the shortest float that has same value in wire.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/internal/type_checkers.py</code> <pre><code>def ToShortestFloat(original):\n  \"\"\"Returns the shortest float that has same value in wire.\"\"\"\n  # All 4 byte floats have between 6 and 9 significant digits, so we\n  # start with 6 as the lower bound.\n  # It has to be iterative because use '.9g' directly can not get rid\n  # of the noises for most values. For example if set a float_field=0.9\n  # use '.9g' will print 0.899999976.\n  precision = 6\n  rounded = float('{0:.{1}g}'.format(original, precision))\n  while TruncateToFourByteFloat(rounded) != original:\n    precision += 1\n    rounded = float('{0:.{1}g}'.format(original, precision))\n  return rounded\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/internal/well_known_types.html","title":"well_known_types","text":"<p>Contains well known classes.</p> This files defines well known classes which need extra maintenance including <ul> <li>Any</li> <li>Duration</li> <li>FieldMask</li> <li>Struct</li> <li>Timestamp</li> </ul>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/internal/well_known_types.html#client.ayon_hiero.vendor.google.protobuf.internal.well_known_types.Any","title":"<code>Any</code>","text":"<p>               Bases: <code>object</code></p> <p>Class for Any Message type.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/internal/well_known_types.py</code> <pre><code>class Any(object):\n  \"\"\"Class for Any Message type.\"\"\"\n\n  __slots__ = ()\n\n  def Pack(self, msg, type_url_prefix='type.googleapis.com/',\n           deterministic=None):\n    \"\"\"Packs the specified message into current Any message.\"\"\"\n    if len(type_url_prefix) &lt; 1 or type_url_prefix[-1] != '/':\n      self.type_url = '%s/%s' % (type_url_prefix, msg.DESCRIPTOR.full_name)\n    else:\n      self.type_url = '%s%s' % (type_url_prefix, msg.DESCRIPTOR.full_name)\n    self.value = msg.SerializeToString(deterministic=deterministic)\n\n  def Unpack(self, msg):\n    \"\"\"Unpacks the current Any message into specified message.\"\"\"\n    descriptor = msg.DESCRIPTOR\n    if not self.Is(descriptor):\n      return False\n    msg.ParseFromString(self.value)\n    return True\n\n  def TypeName(self):\n    \"\"\"Returns the protobuf type name of the inner message.\"\"\"\n    # Only last part is to be used: b/25630112\n    return self.type_url.split('/')[-1]\n\n  def Is(self, descriptor):\n    \"\"\"Checks if this Any represents the given protobuf type.\"\"\"\n    return '/' in self.type_url and self.TypeName() == descriptor.full_name\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/internal/well_known_types.html#client.ayon_hiero.vendor.google.protobuf.internal.well_known_types.Any.Is","title":"<code>Is(descriptor)</code>","text":"<p>Checks if this Any represents the given protobuf type.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/internal/well_known_types.py</code> <pre><code>def Is(self, descriptor):\n  \"\"\"Checks if this Any represents the given protobuf type.\"\"\"\n  return '/' in self.type_url and self.TypeName() == descriptor.full_name\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/internal/well_known_types.html#client.ayon_hiero.vendor.google.protobuf.internal.well_known_types.Any.Pack","title":"<code>Pack(msg, type_url_prefix='type.googleapis.com/', deterministic=None)</code>","text":"<p>Packs the specified message into current Any message.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/internal/well_known_types.py</code> <pre><code>def Pack(self, msg, type_url_prefix='type.googleapis.com/',\n         deterministic=None):\n  \"\"\"Packs the specified message into current Any message.\"\"\"\n  if len(type_url_prefix) &lt; 1 or type_url_prefix[-1] != '/':\n    self.type_url = '%s/%s' % (type_url_prefix, msg.DESCRIPTOR.full_name)\n  else:\n    self.type_url = '%s%s' % (type_url_prefix, msg.DESCRIPTOR.full_name)\n  self.value = msg.SerializeToString(deterministic=deterministic)\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/internal/well_known_types.html#client.ayon_hiero.vendor.google.protobuf.internal.well_known_types.Any.TypeName","title":"<code>TypeName()</code>","text":"<p>Returns the protobuf type name of the inner message.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/internal/well_known_types.py</code> <pre><code>def TypeName(self):\n  \"\"\"Returns the protobuf type name of the inner message.\"\"\"\n  # Only last part is to be used: b/25630112\n  return self.type_url.split('/')[-1]\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/internal/well_known_types.html#client.ayon_hiero.vendor.google.protobuf.internal.well_known_types.Any.Unpack","title":"<code>Unpack(msg)</code>","text":"<p>Unpacks the current Any message into specified message.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/internal/well_known_types.py</code> <pre><code>def Unpack(self, msg):\n  \"\"\"Unpacks the current Any message into specified message.\"\"\"\n  descriptor = msg.DESCRIPTOR\n  if not self.Is(descriptor):\n    return False\n  msg.ParseFromString(self.value)\n  return True\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/internal/well_known_types.html#client.ayon_hiero.vendor.google.protobuf.internal.well_known_types.Duration","title":"<code>Duration</code>","text":"<p>               Bases: <code>object</code></p> <p>Class for Duration message type.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/internal/well_known_types.py</code> <pre><code>class Duration(object):\n  \"\"\"Class for Duration message type.\"\"\"\n\n  __slots__ = ()\n\n  def ToJsonString(self):\n    \"\"\"Converts Duration to string format.\n\n    Returns:\n      A string converted from self. The string format will contains\n      3, 6, or 9 fractional digits depending on the precision required to\n      represent the exact Duration value. For example: \"1s\", \"1.010s\",\n      \"1.000000100s\", \"-3.100s\"\n    \"\"\"\n    _CheckDurationValid(self.seconds, self.nanos)\n    if self.seconds &lt; 0 or self.nanos &lt; 0:\n      result = '-'\n      seconds = - self.seconds + int((0 - self.nanos) // 1e9)\n      nanos = (0 - self.nanos) % 1e9\n    else:\n      result = ''\n      seconds = self.seconds + int(self.nanos // 1e9)\n      nanos = self.nanos % 1e9\n    result += '%d' % seconds\n    if (nanos % 1e9) == 0:\n      # If there are 0 fractional digits, the fractional\n      # point '.' should be omitted when serializing.\n      return result + 's'\n    if (nanos % 1e6) == 0:\n      # Serialize 3 fractional digits.\n      return result + '.%03ds' % (nanos / 1e6)\n    if (nanos % 1e3) == 0:\n      # Serialize 6 fractional digits.\n      return result + '.%06ds' % (nanos / 1e3)\n    # Serialize 9 fractional digits.\n    return result + '.%09ds' % nanos\n\n  def FromJsonString(self, value):\n    \"\"\"Converts a string to Duration.\n\n    Args:\n      value: A string to be converted. The string must end with 's'. Any\n          fractional digits (or none) are accepted as long as they fit into\n          precision. For example: \"1s\", \"1.01s\", \"1.0000001s\", \"-3.100s\n\n    Raises:\n      ValueError: On parsing problems.\n    \"\"\"\n    if not isinstance(value, str):\n      raise ValueError('Duration JSON value not a string: {!r}'.format(value))\n    if len(value) &lt; 1 or value[-1] != 's':\n      raise ValueError(\n          'Duration must end with letter \"s\": {0}.'.format(value))\n    try:\n      pos = value.find('.')\n      if pos == -1:\n        seconds = int(value[:-1])\n        nanos = 0\n      else:\n        seconds = int(value[:pos])\n        if value[0] == '-':\n          nanos = int(round(float('-0{0}'.format(value[pos: -1])) *1e9))\n        else:\n          nanos = int(round(float('0{0}'.format(value[pos: -1])) *1e9))\n      _CheckDurationValid(seconds, nanos)\n      self.seconds = seconds\n      self.nanos = nanos\n    except ValueError as e:\n      raise ValueError(\n          'Couldn\\'t parse duration: {0} : {1}.'.format(value, e))\n\n  def ToNanoseconds(self):\n    \"\"\"Converts a Duration to nanoseconds.\"\"\"\n    return self.seconds * _NANOS_PER_SECOND + self.nanos\n\n  def ToMicroseconds(self):\n    \"\"\"Converts a Duration to microseconds.\"\"\"\n    micros = _RoundTowardZero(self.nanos, _NANOS_PER_MICROSECOND)\n    return self.seconds * _MICROS_PER_SECOND + micros\n\n  def ToMilliseconds(self):\n    \"\"\"Converts a Duration to milliseconds.\"\"\"\n    millis = _RoundTowardZero(self.nanos, _NANOS_PER_MILLISECOND)\n    return self.seconds * _MILLIS_PER_SECOND + millis\n\n  def ToSeconds(self):\n    \"\"\"Converts a Duration to seconds.\"\"\"\n    return self.seconds\n\n  def FromNanoseconds(self, nanos):\n    \"\"\"Converts nanoseconds to Duration.\"\"\"\n    self._NormalizeDuration(nanos // _NANOS_PER_SECOND,\n                            nanos % _NANOS_PER_SECOND)\n\n  def FromMicroseconds(self, micros):\n    \"\"\"Converts microseconds to Duration.\"\"\"\n    self._NormalizeDuration(\n        micros // _MICROS_PER_SECOND,\n        (micros % _MICROS_PER_SECOND) * _NANOS_PER_MICROSECOND)\n\n  def FromMilliseconds(self, millis):\n    \"\"\"Converts milliseconds to Duration.\"\"\"\n    self._NormalizeDuration(\n        millis // _MILLIS_PER_SECOND,\n        (millis % _MILLIS_PER_SECOND) * _NANOS_PER_MILLISECOND)\n\n  def FromSeconds(self, seconds):\n    \"\"\"Converts seconds to Duration.\"\"\"\n    self.seconds = seconds\n    self.nanos = 0\n\n  def ToTimedelta(self):\n    \"\"\"Converts Duration to timedelta.\"\"\"\n    return datetime.timedelta(\n        seconds=self.seconds, microseconds=_RoundTowardZero(\n            self.nanos, _NANOS_PER_MICROSECOND))\n\n  def FromTimedelta(self, td):\n    \"\"\"Converts timedelta to Duration.\"\"\"\n    self._NormalizeDuration(td.seconds + td.days * _SECONDS_PER_DAY,\n                            td.microseconds * _NANOS_PER_MICROSECOND)\n\n  def _NormalizeDuration(self, seconds, nanos):\n    \"\"\"Set Duration by seconds and nanos.\"\"\"\n    # Force nanos to be negative if the duration is negative.\n    if seconds &lt; 0 and nanos &gt; 0:\n      seconds += 1\n      nanos -= _NANOS_PER_SECOND\n    self.seconds = seconds\n    self.nanos = nanos\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/internal/well_known_types.html#client.ayon_hiero.vendor.google.protobuf.internal.well_known_types.Duration.FromJsonString","title":"<code>FromJsonString(value)</code>","text":"<p>Converts a string to Duration.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <p>A string to be converted. The string must end with 's'. Any   fractional digits (or none) are accepted as long as they fit into   precision. For example: \"1s\", \"1.01s\", \"1.0000001s\", \"-3.100s</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>On parsing problems.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/internal/well_known_types.py</code> <pre><code>def FromJsonString(self, value):\n  \"\"\"Converts a string to Duration.\n\n  Args:\n    value: A string to be converted. The string must end with 's'. Any\n        fractional digits (or none) are accepted as long as they fit into\n        precision. For example: \"1s\", \"1.01s\", \"1.0000001s\", \"-3.100s\n\n  Raises:\n    ValueError: On parsing problems.\n  \"\"\"\n  if not isinstance(value, str):\n    raise ValueError('Duration JSON value not a string: {!r}'.format(value))\n  if len(value) &lt; 1 or value[-1] != 's':\n    raise ValueError(\n        'Duration must end with letter \"s\": {0}.'.format(value))\n  try:\n    pos = value.find('.')\n    if pos == -1:\n      seconds = int(value[:-1])\n      nanos = 0\n    else:\n      seconds = int(value[:pos])\n      if value[0] == '-':\n        nanos = int(round(float('-0{0}'.format(value[pos: -1])) *1e9))\n      else:\n        nanos = int(round(float('0{0}'.format(value[pos: -1])) *1e9))\n    _CheckDurationValid(seconds, nanos)\n    self.seconds = seconds\n    self.nanos = nanos\n  except ValueError as e:\n    raise ValueError(\n        'Couldn\\'t parse duration: {0} : {1}.'.format(value, e))\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/internal/well_known_types.html#client.ayon_hiero.vendor.google.protobuf.internal.well_known_types.Duration.FromMicroseconds","title":"<code>FromMicroseconds(micros)</code>","text":"<p>Converts microseconds to Duration.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/internal/well_known_types.py</code> <pre><code>def FromMicroseconds(self, micros):\n  \"\"\"Converts microseconds to Duration.\"\"\"\n  self._NormalizeDuration(\n      micros // _MICROS_PER_SECOND,\n      (micros % _MICROS_PER_SECOND) * _NANOS_PER_MICROSECOND)\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/internal/well_known_types.html#client.ayon_hiero.vendor.google.protobuf.internal.well_known_types.Duration.FromMilliseconds","title":"<code>FromMilliseconds(millis)</code>","text":"<p>Converts milliseconds to Duration.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/internal/well_known_types.py</code> <pre><code>def FromMilliseconds(self, millis):\n  \"\"\"Converts milliseconds to Duration.\"\"\"\n  self._NormalizeDuration(\n      millis // _MILLIS_PER_SECOND,\n      (millis % _MILLIS_PER_SECOND) * _NANOS_PER_MILLISECOND)\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/internal/well_known_types.html#client.ayon_hiero.vendor.google.protobuf.internal.well_known_types.Duration.FromNanoseconds","title":"<code>FromNanoseconds(nanos)</code>","text":"<p>Converts nanoseconds to Duration.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/internal/well_known_types.py</code> <pre><code>def FromNanoseconds(self, nanos):\n  \"\"\"Converts nanoseconds to Duration.\"\"\"\n  self._NormalizeDuration(nanos // _NANOS_PER_SECOND,\n                          nanos % _NANOS_PER_SECOND)\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/internal/well_known_types.html#client.ayon_hiero.vendor.google.protobuf.internal.well_known_types.Duration.FromSeconds","title":"<code>FromSeconds(seconds)</code>","text":"<p>Converts seconds to Duration.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/internal/well_known_types.py</code> <pre><code>def FromSeconds(self, seconds):\n  \"\"\"Converts seconds to Duration.\"\"\"\n  self.seconds = seconds\n  self.nanos = 0\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/internal/well_known_types.html#client.ayon_hiero.vendor.google.protobuf.internal.well_known_types.Duration.FromTimedelta","title":"<code>FromTimedelta(td)</code>","text":"<p>Converts timedelta to Duration.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/internal/well_known_types.py</code> <pre><code>def FromTimedelta(self, td):\n  \"\"\"Converts timedelta to Duration.\"\"\"\n  self._NormalizeDuration(td.seconds + td.days * _SECONDS_PER_DAY,\n                          td.microseconds * _NANOS_PER_MICROSECOND)\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/internal/well_known_types.html#client.ayon_hiero.vendor.google.protobuf.internal.well_known_types.Duration.ToJsonString","title":"<code>ToJsonString()</code>","text":"<p>Converts Duration to string format.</p> <p>Returns:</p> Type Description <p>A string converted from self. The string format will contains</p> <p>3, 6, or 9 fractional digits depending on the precision required to</p> <p>represent the exact Duration value. For example: \"1s\", \"1.010s\",</p> <p>\"1.000000100s\", \"-3.100s\"</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/internal/well_known_types.py</code> <pre><code>def ToJsonString(self):\n  \"\"\"Converts Duration to string format.\n\n  Returns:\n    A string converted from self. The string format will contains\n    3, 6, or 9 fractional digits depending on the precision required to\n    represent the exact Duration value. For example: \"1s\", \"1.010s\",\n    \"1.000000100s\", \"-3.100s\"\n  \"\"\"\n  _CheckDurationValid(self.seconds, self.nanos)\n  if self.seconds &lt; 0 or self.nanos &lt; 0:\n    result = '-'\n    seconds = - self.seconds + int((0 - self.nanos) // 1e9)\n    nanos = (0 - self.nanos) % 1e9\n  else:\n    result = ''\n    seconds = self.seconds + int(self.nanos // 1e9)\n    nanos = self.nanos % 1e9\n  result += '%d' % seconds\n  if (nanos % 1e9) == 0:\n    # If there are 0 fractional digits, the fractional\n    # point '.' should be omitted when serializing.\n    return result + 's'\n  if (nanos % 1e6) == 0:\n    # Serialize 3 fractional digits.\n    return result + '.%03ds' % (nanos / 1e6)\n  if (nanos % 1e3) == 0:\n    # Serialize 6 fractional digits.\n    return result + '.%06ds' % (nanos / 1e3)\n  # Serialize 9 fractional digits.\n  return result + '.%09ds' % nanos\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/internal/well_known_types.html#client.ayon_hiero.vendor.google.protobuf.internal.well_known_types.Duration.ToMicroseconds","title":"<code>ToMicroseconds()</code>","text":"<p>Converts a Duration to microseconds.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/internal/well_known_types.py</code> <pre><code>def ToMicroseconds(self):\n  \"\"\"Converts a Duration to microseconds.\"\"\"\n  micros = _RoundTowardZero(self.nanos, _NANOS_PER_MICROSECOND)\n  return self.seconds * _MICROS_PER_SECOND + micros\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/internal/well_known_types.html#client.ayon_hiero.vendor.google.protobuf.internal.well_known_types.Duration.ToMilliseconds","title":"<code>ToMilliseconds()</code>","text":"<p>Converts a Duration to milliseconds.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/internal/well_known_types.py</code> <pre><code>def ToMilliseconds(self):\n  \"\"\"Converts a Duration to milliseconds.\"\"\"\n  millis = _RoundTowardZero(self.nanos, _NANOS_PER_MILLISECOND)\n  return self.seconds * _MILLIS_PER_SECOND + millis\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/internal/well_known_types.html#client.ayon_hiero.vendor.google.protobuf.internal.well_known_types.Duration.ToNanoseconds","title":"<code>ToNanoseconds()</code>","text":"<p>Converts a Duration to nanoseconds.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/internal/well_known_types.py</code> <pre><code>def ToNanoseconds(self):\n  \"\"\"Converts a Duration to nanoseconds.\"\"\"\n  return self.seconds * _NANOS_PER_SECOND + self.nanos\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/internal/well_known_types.html#client.ayon_hiero.vendor.google.protobuf.internal.well_known_types.Duration.ToSeconds","title":"<code>ToSeconds()</code>","text":"<p>Converts a Duration to seconds.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/internal/well_known_types.py</code> <pre><code>def ToSeconds(self):\n  \"\"\"Converts a Duration to seconds.\"\"\"\n  return self.seconds\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/internal/well_known_types.html#client.ayon_hiero.vendor.google.protobuf.internal.well_known_types.Duration.ToTimedelta","title":"<code>ToTimedelta()</code>","text":"<p>Converts Duration to timedelta.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/internal/well_known_types.py</code> <pre><code>def ToTimedelta(self):\n  \"\"\"Converts Duration to timedelta.\"\"\"\n  return datetime.timedelta(\n      seconds=self.seconds, microseconds=_RoundTowardZero(\n          self.nanos, _NANOS_PER_MICROSECOND))\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/internal/well_known_types.html#client.ayon_hiero.vendor.google.protobuf.internal.well_known_types.FieldMask","title":"<code>FieldMask</code>","text":"<p>               Bases: <code>object</code></p> <p>Class for FieldMask message type.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/internal/well_known_types.py</code> <pre><code>class FieldMask(object):\n  \"\"\"Class for FieldMask message type.\"\"\"\n\n  __slots__ = ()\n\n  def ToJsonString(self):\n    \"\"\"Converts FieldMask to string according to proto3 JSON spec.\"\"\"\n    camelcase_paths = []\n    for path in self.paths:\n      camelcase_paths.append(_SnakeCaseToCamelCase(path))\n    return ','.join(camelcase_paths)\n\n  def FromJsonString(self, value):\n    \"\"\"Converts string to FieldMask according to proto3 JSON spec.\"\"\"\n    if not isinstance(value, str):\n      raise ValueError('FieldMask JSON value not a string: {!r}'.format(value))\n    self.Clear()\n    if value:\n      for path in value.split(','):\n        self.paths.append(_CamelCaseToSnakeCase(path))\n\n  def IsValidForDescriptor(self, message_descriptor):\n    \"\"\"Checks whether the FieldMask is valid for Message Descriptor.\"\"\"\n    for path in self.paths:\n      if not _IsValidPath(message_descriptor, path):\n        return False\n    return True\n\n  def AllFieldsFromDescriptor(self, message_descriptor):\n    \"\"\"Gets all direct fields of Message Descriptor to FieldMask.\"\"\"\n    self.Clear()\n    for field in message_descriptor.fields:\n      self.paths.append(field.name)\n\n  def CanonicalFormFromMask(self, mask):\n    \"\"\"Converts a FieldMask to the canonical form.\n\n    Removes paths that are covered by another path. For example,\n    \"foo.bar\" is covered by \"foo\" and will be removed if \"foo\"\n    is also in the FieldMask. Then sorts all paths in alphabetical order.\n\n    Args:\n      mask: The original FieldMask to be converted.\n    \"\"\"\n    tree = _FieldMaskTree(mask)\n    tree.ToFieldMask(self)\n\n  def Union(self, mask1, mask2):\n    \"\"\"Merges mask1 and mask2 into this FieldMask.\"\"\"\n    _CheckFieldMaskMessage(mask1)\n    _CheckFieldMaskMessage(mask2)\n    tree = _FieldMaskTree(mask1)\n    tree.MergeFromFieldMask(mask2)\n    tree.ToFieldMask(self)\n\n  def Intersect(self, mask1, mask2):\n    \"\"\"Intersects mask1 and mask2 into this FieldMask.\"\"\"\n    _CheckFieldMaskMessage(mask1)\n    _CheckFieldMaskMessage(mask2)\n    tree = _FieldMaskTree(mask1)\n    intersection = _FieldMaskTree()\n    for path in mask2.paths:\n      tree.IntersectPath(path, intersection)\n    intersection.ToFieldMask(self)\n\n  def MergeMessage(\n      self, source, destination,\n      replace_message_field=False, replace_repeated_field=False):\n    \"\"\"Merges fields specified in FieldMask from source to destination.\n\n    Args:\n      source: Source message.\n      destination: The destination message to be merged into.\n      replace_message_field: Replace message field if True. Merge message\n          field if False.\n      replace_repeated_field: Replace repeated field if True. Append\n          elements of repeated field if False.\n    \"\"\"\n    tree = _FieldMaskTree(self)\n    tree.MergeMessage(\n        source, destination, replace_message_field, replace_repeated_field)\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/internal/well_known_types.html#client.ayon_hiero.vendor.google.protobuf.internal.well_known_types.FieldMask.AllFieldsFromDescriptor","title":"<code>AllFieldsFromDescriptor(message_descriptor)</code>","text":"<p>Gets all direct fields of Message Descriptor to FieldMask.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/internal/well_known_types.py</code> <pre><code>def AllFieldsFromDescriptor(self, message_descriptor):\n  \"\"\"Gets all direct fields of Message Descriptor to FieldMask.\"\"\"\n  self.Clear()\n  for field in message_descriptor.fields:\n    self.paths.append(field.name)\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/internal/well_known_types.html#client.ayon_hiero.vendor.google.protobuf.internal.well_known_types.FieldMask.CanonicalFormFromMask","title":"<code>CanonicalFormFromMask(mask)</code>","text":"<p>Converts a FieldMask to the canonical form.</p> <p>Removes paths that are covered by another path. For example, \"foo.bar\" is covered by \"foo\" and will be removed if \"foo\" is also in the FieldMask. Then sorts all paths in alphabetical order.</p> <p>Parameters:</p> Name Type Description Default <code>mask</code> <p>The original FieldMask to be converted.</p> required Source code in <code>client/ayon_hiero/vendor/google/protobuf/internal/well_known_types.py</code> <pre><code>def CanonicalFormFromMask(self, mask):\n  \"\"\"Converts a FieldMask to the canonical form.\n\n  Removes paths that are covered by another path. For example,\n  \"foo.bar\" is covered by \"foo\" and will be removed if \"foo\"\n  is also in the FieldMask. Then sorts all paths in alphabetical order.\n\n  Args:\n    mask: The original FieldMask to be converted.\n  \"\"\"\n  tree = _FieldMaskTree(mask)\n  tree.ToFieldMask(self)\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/internal/well_known_types.html#client.ayon_hiero.vendor.google.protobuf.internal.well_known_types.FieldMask.FromJsonString","title":"<code>FromJsonString(value)</code>","text":"<p>Converts string to FieldMask according to proto3 JSON spec.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/internal/well_known_types.py</code> <pre><code>def FromJsonString(self, value):\n  \"\"\"Converts string to FieldMask according to proto3 JSON spec.\"\"\"\n  if not isinstance(value, str):\n    raise ValueError('FieldMask JSON value not a string: {!r}'.format(value))\n  self.Clear()\n  if value:\n    for path in value.split(','):\n      self.paths.append(_CamelCaseToSnakeCase(path))\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/internal/well_known_types.html#client.ayon_hiero.vendor.google.protobuf.internal.well_known_types.FieldMask.Intersect","title":"<code>Intersect(mask1, mask2)</code>","text":"<p>Intersects mask1 and mask2 into this FieldMask.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/internal/well_known_types.py</code> <pre><code>def Intersect(self, mask1, mask2):\n  \"\"\"Intersects mask1 and mask2 into this FieldMask.\"\"\"\n  _CheckFieldMaskMessage(mask1)\n  _CheckFieldMaskMessage(mask2)\n  tree = _FieldMaskTree(mask1)\n  intersection = _FieldMaskTree()\n  for path in mask2.paths:\n    tree.IntersectPath(path, intersection)\n  intersection.ToFieldMask(self)\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/internal/well_known_types.html#client.ayon_hiero.vendor.google.protobuf.internal.well_known_types.FieldMask.IsValidForDescriptor","title":"<code>IsValidForDescriptor(message_descriptor)</code>","text":"<p>Checks whether the FieldMask is valid for Message Descriptor.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/internal/well_known_types.py</code> <pre><code>def IsValidForDescriptor(self, message_descriptor):\n  \"\"\"Checks whether the FieldMask is valid for Message Descriptor.\"\"\"\n  for path in self.paths:\n    if not _IsValidPath(message_descriptor, path):\n      return False\n  return True\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/internal/well_known_types.html#client.ayon_hiero.vendor.google.protobuf.internal.well_known_types.FieldMask.MergeMessage","title":"<code>MergeMessage(source, destination, replace_message_field=False, replace_repeated_field=False)</code>","text":"<p>Merges fields specified in FieldMask from source to destination.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <p>Source message.</p> required <code>destination</code> <p>The destination message to be merged into.</p> required <code>replace_message_field</code> <p>Replace message field if True. Merge message   field if False.</p> <code>False</code> <code>replace_repeated_field</code> <p>Replace repeated field if True. Append   elements of repeated field if False.</p> <code>False</code> Source code in <code>client/ayon_hiero/vendor/google/protobuf/internal/well_known_types.py</code> <pre><code>def MergeMessage(\n    self, source, destination,\n    replace_message_field=False, replace_repeated_field=False):\n  \"\"\"Merges fields specified in FieldMask from source to destination.\n\n  Args:\n    source: Source message.\n    destination: The destination message to be merged into.\n    replace_message_field: Replace message field if True. Merge message\n        field if False.\n    replace_repeated_field: Replace repeated field if True. Append\n        elements of repeated field if False.\n  \"\"\"\n  tree = _FieldMaskTree(self)\n  tree.MergeMessage(\n      source, destination, replace_message_field, replace_repeated_field)\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/internal/well_known_types.html#client.ayon_hiero.vendor.google.protobuf.internal.well_known_types.FieldMask.ToJsonString","title":"<code>ToJsonString()</code>","text":"<p>Converts FieldMask to string according to proto3 JSON spec.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/internal/well_known_types.py</code> <pre><code>def ToJsonString(self):\n  \"\"\"Converts FieldMask to string according to proto3 JSON spec.\"\"\"\n  camelcase_paths = []\n  for path in self.paths:\n    camelcase_paths.append(_SnakeCaseToCamelCase(path))\n  return ','.join(camelcase_paths)\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/internal/well_known_types.html#client.ayon_hiero.vendor.google.protobuf.internal.well_known_types.FieldMask.Union","title":"<code>Union(mask1, mask2)</code>","text":"<p>Merges mask1 and mask2 into this FieldMask.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/internal/well_known_types.py</code> <pre><code>def Union(self, mask1, mask2):\n  \"\"\"Merges mask1 and mask2 into this FieldMask.\"\"\"\n  _CheckFieldMaskMessage(mask1)\n  _CheckFieldMaskMessage(mask2)\n  tree = _FieldMaskTree(mask1)\n  tree.MergeFromFieldMask(mask2)\n  tree.ToFieldMask(self)\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/internal/well_known_types.html#client.ayon_hiero.vendor.google.protobuf.internal.well_known_types.ListValue","title":"<code>ListValue</code>","text":"<p>               Bases: <code>object</code></p> <p>Class for ListValue message type.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/internal/well_known_types.py</code> <pre><code>class ListValue(object):\n  \"\"\"Class for ListValue message type.\"\"\"\n\n  __slots__ = ()\n\n  def __len__(self):\n    return len(self.values)\n\n  def append(self, value):\n    _SetStructValue(self.values.add(), value)\n\n  def extend(self, elem_seq):\n    for value in elem_seq:\n      self.append(value)\n\n  def __getitem__(self, index):\n    \"\"\"Retrieves item by the specified index.\"\"\"\n    return _GetStructValue(self.values.__getitem__(index))\n\n  def __setitem__(self, index, value):\n    _SetStructValue(self.values.__getitem__(index), value)\n\n  def __delitem__(self, key):\n    del self.values[key]\n\n  def items(self):\n    for i in range(len(self)):\n      yield self[i]\n\n  def add_struct(self):\n    \"\"\"Appends and returns a struct value as the next value in the list.\"\"\"\n    struct_value = self.values.add().struct_value\n    # Clear will mark struct_value modified which will indeed create a struct.\n    struct_value.Clear()\n    return struct_value\n\n  def add_list(self):\n    \"\"\"Appends and returns a list value as the next value in the list.\"\"\"\n    list_value = self.values.add().list_value\n    # Clear will mark list_value modified which will indeed create a list.\n    list_value.Clear()\n    return list_value\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/internal/well_known_types.html#client.ayon_hiero.vendor.google.protobuf.internal.well_known_types.ListValue.__getitem__","title":"<code>__getitem__(index)</code>","text":"<p>Retrieves item by the specified index.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/internal/well_known_types.py</code> <pre><code>def __getitem__(self, index):\n  \"\"\"Retrieves item by the specified index.\"\"\"\n  return _GetStructValue(self.values.__getitem__(index))\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/internal/well_known_types.html#client.ayon_hiero.vendor.google.protobuf.internal.well_known_types.ListValue.add_list","title":"<code>add_list()</code>","text":"<p>Appends and returns a list value as the next value in the list.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/internal/well_known_types.py</code> <pre><code>def add_list(self):\n  \"\"\"Appends and returns a list value as the next value in the list.\"\"\"\n  list_value = self.values.add().list_value\n  # Clear will mark list_value modified which will indeed create a list.\n  list_value.Clear()\n  return list_value\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/internal/well_known_types.html#client.ayon_hiero.vendor.google.protobuf.internal.well_known_types.ListValue.add_struct","title":"<code>add_struct()</code>","text":"<p>Appends and returns a struct value as the next value in the list.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/internal/well_known_types.py</code> <pre><code>def add_struct(self):\n  \"\"\"Appends and returns a struct value as the next value in the list.\"\"\"\n  struct_value = self.values.add().struct_value\n  # Clear will mark struct_value modified which will indeed create a struct.\n  struct_value.Clear()\n  return struct_value\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/internal/well_known_types.html#client.ayon_hiero.vendor.google.protobuf.internal.well_known_types.Struct","title":"<code>Struct</code>","text":"<p>               Bases: <code>object</code></p> <p>Class for Struct message type.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/internal/well_known_types.py</code> <pre><code>class Struct(object):\n  \"\"\"Class for Struct message type.\"\"\"\n\n  __slots__ = ()\n\n  def __getitem__(self, key):\n    return _GetStructValue(self.fields[key])\n\n  def __contains__(self, item):\n    return item in self.fields\n\n  def __setitem__(self, key, value):\n    _SetStructValue(self.fields[key], value)\n\n  def __delitem__(self, key):\n    del self.fields[key]\n\n  def __len__(self):\n    return len(self.fields)\n\n  def __iter__(self):\n    return iter(self.fields)\n\n  def keys(self):  # pylint: disable=invalid-name\n    return self.fields.keys()\n\n  def values(self):  # pylint: disable=invalid-name\n    return [self[key] for key in self]\n\n  def items(self):  # pylint: disable=invalid-name\n    return [(key, self[key]) for key in self]\n\n  def get_or_create_list(self, key):\n    \"\"\"Returns a list for this key, creating if it didn't exist already.\"\"\"\n    if not self.fields[key].HasField('list_value'):\n      # Clear will mark list_value modified which will indeed create a list.\n      self.fields[key].list_value.Clear()\n    return self.fields[key].list_value\n\n  def get_or_create_struct(self, key):\n    \"\"\"Returns a struct for this key, creating if it didn't exist already.\"\"\"\n    if not self.fields[key].HasField('struct_value'):\n      # Clear will mark struct_value modified which will indeed create a struct.\n      self.fields[key].struct_value.Clear()\n    return self.fields[key].struct_value\n\n  def update(self, dictionary):  # pylint: disable=invalid-name\n    for key, value in dictionary.items():\n      _SetStructValue(self.fields[key], value)\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/internal/well_known_types.html#client.ayon_hiero.vendor.google.protobuf.internal.well_known_types.Struct.get_or_create_list","title":"<code>get_or_create_list(key)</code>","text":"<p>Returns a list for this key, creating if it didn't exist already.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/internal/well_known_types.py</code> <pre><code>def get_or_create_list(self, key):\n  \"\"\"Returns a list for this key, creating if it didn't exist already.\"\"\"\n  if not self.fields[key].HasField('list_value'):\n    # Clear will mark list_value modified which will indeed create a list.\n    self.fields[key].list_value.Clear()\n  return self.fields[key].list_value\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/internal/well_known_types.html#client.ayon_hiero.vendor.google.protobuf.internal.well_known_types.Struct.get_or_create_struct","title":"<code>get_or_create_struct(key)</code>","text":"<p>Returns a struct for this key, creating if it didn't exist already.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/internal/well_known_types.py</code> <pre><code>def get_or_create_struct(self, key):\n  \"\"\"Returns a struct for this key, creating if it didn't exist already.\"\"\"\n  if not self.fields[key].HasField('struct_value'):\n    # Clear will mark struct_value modified which will indeed create a struct.\n    self.fields[key].struct_value.Clear()\n  return self.fields[key].struct_value\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/internal/well_known_types.html#client.ayon_hiero.vendor.google.protobuf.internal.well_known_types.Timestamp","title":"<code>Timestamp</code>","text":"<p>               Bases: <code>object</code></p> <p>Class for Timestamp message type.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/internal/well_known_types.py</code> <pre><code>class Timestamp(object):\n  \"\"\"Class for Timestamp message type.\"\"\"\n\n  __slots__ = ()\n\n  def ToJsonString(self):\n    \"\"\"Converts Timestamp to RFC 3339 date string format.\n\n    Returns:\n      A string converted from timestamp. The string is always Z-normalized\n      and uses 3, 6 or 9 fractional digits as required to represent the\n      exact time. Example of the return format: '1972-01-01T10:00:20.021Z'\n    \"\"\"\n    nanos = self.nanos % _NANOS_PER_SECOND\n    total_sec = self.seconds + (self.nanos - nanos) // _NANOS_PER_SECOND\n    seconds = total_sec % _SECONDS_PER_DAY\n    days = (total_sec - seconds) // _SECONDS_PER_DAY\n    dt = datetime.datetime(1970, 1, 1) + datetime.timedelta(days, seconds)\n\n    result = dt.isoformat()\n    if (nanos % 1e9) == 0:\n      # If there are 0 fractional digits, the fractional\n      # point '.' should be omitted when serializing.\n      return result + 'Z'\n    if (nanos % 1e6) == 0:\n      # Serialize 3 fractional digits.\n      return result + '.%03dZ' % (nanos / 1e6)\n    if (nanos % 1e3) == 0:\n      # Serialize 6 fractional digits.\n      return result + '.%06dZ' % (nanos / 1e3)\n    # Serialize 9 fractional digits.\n    return result + '.%09dZ' % nanos\n\n  def FromJsonString(self, value):\n    \"\"\"Parse a RFC 3339 date string format to Timestamp.\n\n    Args:\n      value: A date string. Any fractional digits (or none) and any offset are\n          accepted as long as they fit into nano-seconds precision.\n          Example of accepted format: '1972-01-01T10:00:20.021-05:00'\n\n    Raises:\n      ValueError: On parsing problems.\n    \"\"\"\n    if not isinstance(value, str):\n      raise ValueError('Timestamp JSON value not a string: {!r}'.format(value))\n    timezone_offset = value.find('Z')\n    if timezone_offset == -1:\n      timezone_offset = value.find('+')\n    if timezone_offset == -1:\n      timezone_offset = value.rfind('-')\n    if timezone_offset == -1:\n      raise ValueError(\n          'Failed to parse timestamp: missing valid timezone offset.')\n    time_value = value[0:timezone_offset]\n    # Parse datetime and nanos.\n    point_position = time_value.find('.')\n    if point_position == -1:\n      second_value = time_value\n      nano_value = ''\n    else:\n      second_value = time_value[:point_position]\n      nano_value = time_value[point_position + 1:]\n    if 't' in second_value:\n      raise ValueError(\n          'time data \\'{0}\\' does not match format \\'%Y-%m-%dT%H:%M:%S\\', '\n          'lowercase \\'t\\' is not accepted'.format(second_value))\n    date_object = datetime.datetime.strptime(second_value, _TIMESTAMPFOMAT)\n    td = date_object - datetime.datetime(1970, 1, 1)\n    seconds = td.seconds + td.days * _SECONDS_PER_DAY\n    if len(nano_value) &gt; 9:\n      raise ValueError(\n          'Failed to parse Timestamp: nanos {0} more than '\n          '9 fractional digits.'.format(nano_value))\n    if nano_value:\n      nanos = round(float('0.' + nano_value) * 1e9)\n    else:\n      nanos = 0\n    # Parse timezone offsets.\n    if value[timezone_offset] == 'Z':\n      if len(value) != timezone_offset + 1:\n        raise ValueError('Failed to parse timestamp: invalid trailing'\n                         ' data {0}.'.format(value))\n    else:\n      timezone = value[timezone_offset:]\n      pos = timezone.find(':')\n      if pos == -1:\n        raise ValueError(\n            'Invalid timezone offset value: {0}.'.format(timezone))\n      if timezone[0] == '+':\n        seconds -= (int(timezone[1:pos])*60+int(timezone[pos+1:]))*60\n      else:\n        seconds += (int(timezone[1:pos])*60+int(timezone[pos+1:]))*60\n    # Set seconds and nanos\n    self.seconds = int(seconds)\n    self.nanos = int(nanos)\n\n  def GetCurrentTime(self):\n    \"\"\"Get the current UTC into Timestamp.\"\"\"\n    self.FromDatetime(datetime.datetime.utcnow())\n\n  def ToNanoseconds(self):\n    \"\"\"Converts Timestamp to nanoseconds since epoch.\"\"\"\n    return self.seconds * _NANOS_PER_SECOND + self.nanos\n\n  def ToMicroseconds(self):\n    \"\"\"Converts Timestamp to microseconds since epoch.\"\"\"\n    return (self.seconds * _MICROS_PER_SECOND +\n            self.nanos // _NANOS_PER_MICROSECOND)\n\n  def ToMilliseconds(self):\n    \"\"\"Converts Timestamp to milliseconds since epoch.\"\"\"\n    return (self.seconds * _MILLIS_PER_SECOND +\n            self.nanos // _NANOS_PER_MILLISECOND)\n\n  def ToSeconds(self):\n    \"\"\"Converts Timestamp to seconds since epoch.\"\"\"\n    return self.seconds\n\n  def FromNanoseconds(self, nanos):\n    \"\"\"Converts nanoseconds since epoch to Timestamp.\"\"\"\n    self.seconds = nanos // _NANOS_PER_SECOND\n    self.nanos = nanos % _NANOS_PER_SECOND\n\n  def FromMicroseconds(self, micros):\n    \"\"\"Converts microseconds since epoch to Timestamp.\"\"\"\n    self.seconds = micros // _MICROS_PER_SECOND\n    self.nanos = (micros % _MICROS_PER_SECOND) * _NANOS_PER_MICROSECOND\n\n  def FromMilliseconds(self, millis):\n    \"\"\"Converts milliseconds since epoch to Timestamp.\"\"\"\n    self.seconds = millis // _MILLIS_PER_SECOND\n    self.nanos = (millis % _MILLIS_PER_SECOND) * _NANOS_PER_MILLISECOND\n\n  def FromSeconds(self, seconds):\n    \"\"\"Converts seconds since epoch to Timestamp.\"\"\"\n    self.seconds = seconds\n    self.nanos = 0\n\n  def ToDatetime(self, tzinfo=None):\n    \"\"\"Converts Timestamp to a datetime.\n\n    Args:\n      tzinfo: A datetime.tzinfo subclass; defaults to None.\n\n    Returns:\n      If tzinfo is None, returns a timezone-naive UTC datetime (with no timezone\n      information, i.e. not aware that it's UTC).\n\n      Otherwise, returns a timezone-aware datetime in the input timezone.\n    \"\"\"\n    delta = datetime.timedelta(\n        seconds=self.seconds,\n        microseconds=_RoundTowardZero(self.nanos, _NANOS_PER_MICROSECOND))\n    if tzinfo is None:\n      return _EPOCH_DATETIME_NAIVE + delta\n    else:\n      return _EPOCH_DATETIME_AWARE.astimezone(tzinfo) + delta\n\n  def FromDatetime(self, dt):\n    \"\"\"Converts datetime to Timestamp.\n\n    Args:\n      dt: A datetime. If it's timezone-naive, it's assumed to be in UTC.\n    \"\"\"\n    # Using this guide: http://wiki.python.org/moin/WorkingWithTime\n    # And this conversion guide: http://docs.python.org/library/time.html\n\n    # Turn the date parameter into a tuple (struct_time) that can then be\n    # manipulated into a long value of seconds.  During the conversion from\n    # struct_time to long, the source date in UTC, and so it follows that the\n    # correct transformation is calendar.timegm()\n    self.seconds = calendar.timegm(dt.utctimetuple())\n    self.nanos = dt.microsecond * _NANOS_PER_MICROSECOND\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/internal/well_known_types.html#client.ayon_hiero.vendor.google.protobuf.internal.well_known_types.Timestamp.FromDatetime","title":"<code>FromDatetime(dt)</code>","text":"<p>Converts datetime to Timestamp.</p> <p>Parameters:</p> Name Type Description Default <code>dt</code> <p>A datetime. If it's timezone-naive, it's assumed to be in UTC.</p> required Source code in <code>client/ayon_hiero/vendor/google/protobuf/internal/well_known_types.py</code> <pre><code>def FromDatetime(self, dt):\n  \"\"\"Converts datetime to Timestamp.\n\n  Args:\n    dt: A datetime. If it's timezone-naive, it's assumed to be in UTC.\n  \"\"\"\n  # Using this guide: http://wiki.python.org/moin/WorkingWithTime\n  # And this conversion guide: http://docs.python.org/library/time.html\n\n  # Turn the date parameter into a tuple (struct_time) that can then be\n  # manipulated into a long value of seconds.  During the conversion from\n  # struct_time to long, the source date in UTC, and so it follows that the\n  # correct transformation is calendar.timegm()\n  self.seconds = calendar.timegm(dt.utctimetuple())\n  self.nanos = dt.microsecond * _NANOS_PER_MICROSECOND\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/internal/well_known_types.html#client.ayon_hiero.vendor.google.protobuf.internal.well_known_types.Timestamp.FromJsonString","title":"<code>FromJsonString(value)</code>","text":"<p>Parse a RFC 3339 date string format to Timestamp.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <p>A date string. Any fractional digits (or none) and any offset are   accepted as long as they fit into nano-seconds precision.   Example of accepted format: '1972-01-01T10:00:20.021-05:00'</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>On parsing problems.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/internal/well_known_types.py</code> <pre><code>def FromJsonString(self, value):\n  \"\"\"Parse a RFC 3339 date string format to Timestamp.\n\n  Args:\n    value: A date string. Any fractional digits (or none) and any offset are\n        accepted as long as they fit into nano-seconds precision.\n        Example of accepted format: '1972-01-01T10:00:20.021-05:00'\n\n  Raises:\n    ValueError: On parsing problems.\n  \"\"\"\n  if not isinstance(value, str):\n    raise ValueError('Timestamp JSON value not a string: {!r}'.format(value))\n  timezone_offset = value.find('Z')\n  if timezone_offset == -1:\n    timezone_offset = value.find('+')\n  if timezone_offset == -1:\n    timezone_offset = value.rfind('-')\n  if timezone_offset == -1:\n    raise ValueError(\n        'Failed to parse timestamp: missing valid timezone offset.')\n  time_value = value[0:timezone_offset]\n  # Parse datetime and nanos.\n  point_position = time_value.find('.')\n  if point_position == -1:\n    second_value = time_value\n    nano_value = ''\n  else:\n    second_value = time_value[:point_position]\n    nano_value = time_value[point_position + 1:]\n  if 't' in second_value:\n    raise ValueError(\n        'time data \\'{0}\\' does not match format \\'%Y-%m-%dT%H:%M:%S\\', '\n        'lowercase \\'t\\' is not accepted'.format(second_value))\n  date_object = datetime.datetime.strptime(second_value, _TIMESTAMPFOMAT)\n  td = date_object - datetime.datetime(1970, 1, 1)\n  seconds = td.seconds + td.days * _SECONDS_PER_DAY\n  if len(nano_value) &gt; 9:\n    raise ValueError(\n        'Failed to parse Timestamp: nanos {0} more than '\n        '9 fractional digits.'.format(nano_value))\n  if nano_value:\n    nanos = round(float('0.' + nano_value) * 1e9)\n  else:\n    nanos = 0\n  # Parse timezone offsets.\n  if value[timezone_offset] == 'Z':\n    if len(value) != timezone_offset + 1:\n      raise ValueError('Failed to parse timestamp: invalid trailing'\n                       ' data {0}.'.format(value))\n  else:\n    timezone = value[timezone_offset:]\n    pos = timezone.find(':')\n    if pos == -1:\n      raise ValueError(\n          'Invalid timezone offset value: {0}.'.format(timezone))\n    if timezone[0] == '+':\n      seconds -= (int(timezone[1:pos])*60+int(timezone[pos+1:]))*60\n    else:\n      seconds += (int(timezone[1:pos])*60+int(timezone[pos+1:]))*60\n  # Set seconds and nanos\n  self.seconds = int(seconds)\n  self.nanos = int(nanos)\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/internal/well_known_types.html#client.ayon_hiero.vendor.google.protobuf.internal.well_known_types.Timestamp.FromMicroseconds","title":"<code>FromMicroseconds(micros)</code>","text":"<p>Converts microseconds since epoch to Timestamp.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/internal/well_known_types.py</code> <pre><code>def FromMicroseconds(self, micros):\n  \"\"\"Converts microseconds since epoch to Timestamp.\"\"\"\n  self.seconds = micros // _MICROS_PER_SECOND\n  self.nanos = (micros % _MICROS_PER_SECOND) * _NANOS_PER_MICROSECOND\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/internal/well_known_types.html#client.ayon_hiero.vendor.google.protobuf.internal.well_known_types.Timestamp.FromMilliseconds","title":"<code>FromMilliseconds(millis)</code>","text":"<p>Converts milliseconds since epoch to Timestamp.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/internal/well_known_types.py</code> <pre><code>def FromMilliseconds(self, millis):\n  \"\"\"Converts milliseconds since epoch to Timestamp.\"\"\"\n  self.seconds = millis // _MILLIS_PER_SECOND\n  self.nanos = (millis % _MILLIS_PER_SECOND) * _NANOS_PER_MILLISECOND\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/internal/well_known_types.html#client.ayon_hiero.vendor.google.protobuf.internal.well_known_types.Timestamp.FromNanoseconds","title":"<code>FromNanoseconds(nanos)</code>","text":"<p>Converts nanoseconds since epoch to Timestamp.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/internal/well_known_types.py</code> <pre><code>def FromNanoseconds(self, nanos):\n  \"\"\"Converts nanoseconds since epoch to Timestamp.\"\"\"\n  self.seconds = nanos // _NANOS_PER_SECOND\n  self.nanos = nanos % _NANOS_PER_SECOND\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/internal/well_known_types.html#client.ayon_hiero.vendor.google.protobuf.internal.well_known_types.Timestamp.FromSeconds","title":"<code>FromSeconds(seconds)</code>","text":"<p>Converts seconds since epoch to Timestamp.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/internal/well_known_types.py</code> <pre><code>def FromSeconds(self, seconds):\n  \"\"\"Converts seconds since epoch to Timestamp.\"\"\"\n  self.seconds = seconds\n  self.nanos = 0\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/internal/well_known_types.html#client.ayon_hiero.vendor.google.protobuf.internal.well_known_types.Timestamp.GetCurrentTime","title":"<code>GetCurrentTime()</code>","text":"<p>Get the current UTC into Timestamp.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/internal/well_known_types.py</code> <pre><code>def GetCurrentTime(self):\n  \"\"\"Get the current UTC into Timestamp.\"\"\"\n  self.FromDatetime(datetime.datetime.utcnow())\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/internal/well_known_types.html#client.ayon_hiero.vendor.google.protobuf.internal.well_known_types.Timestamp.ToDatetime","title":"<code>ToDatetime(tzinfo=None)</code>","text":"<p>Converts Timestamp to a datetime.</p> <p>Parameters:</p> Name Type Description Default <code>tzinfo</code> <p>A datetime.tzinfo subclass; defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <p>If tzinfo is None, returns a timezone-naive UTC datetime (with no timezone</p> <p>information, i.e. not aware that it's UTC).</p> <p>Otherwise, returns a timezone-aware datetime in the input timezone.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/internal/well_known_types.py</code> <pre><code>def ToDatetime(self, tzinfo=None):\n  \"\"\"Converts Timestamp to a datetime.\n\n  Args:\n    tzinfo: A datetime.tzinfo subclass; defaults to None.\n\n  Returns:\n    If tzinfo is None, returns a timezone-naive UTC datetime (with no timezone\n    information, i.e. not aware that it's UTC).\n\n    Otherwise, returns a timezone-aware datetime in the input timezone.\n  \"\"\"\n  delta = datetime.timedelta(\n      seconds=self.seconds,\n      microseconds=_RoundTowardZero(self.nanos, _NANOS_PER_MICROSECOND))\n  if tzinfo is None:\n    return _EPOCH_DATETIME_NAIVE + delta\n  else:\n    return _EPOCH_DATETIME_AWARE.astimezone(tzinfo) + delta\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/internal/well_known_types.html#client.ayon_hiero.vendor.google.protobuf.internal.well_known_types.Timestamp.ToJsonString","title":"<code>ToJsonString()</code>","text":"<p>Converts Timestamp to RFC 3339 date string format.</p> <p>Returns:</p> Type Description <p>A string converted from timestamp. The string is always Z-normalized</p> <p>and uses 3, 6 or 9 fractional digits as required to represent the</p> <p>exact time. Example of the return format: '1972-01-01T10:00:20.021Z'</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/internal/well_known_types.py</code> <pre><code>def ToJsonString(self):\n  \"\"\"Converts Timestamp to RFC 3339 date string format.\n\n  Returns:\n    A string converted from timestamp. The string is always Z-normalized\n    and uses 3, 6 or 9 fractional digits as required to represent the\n    exact time. Example of the return format: '1972-01-01T10:00:20.021Z'\n  \"\"\"\n  nanos = self.nanos % _NANOS_PER_SECOND\n  total_sec = self.seconds + (self.nanos - nanos) // _NANOS_PER_SECOND\n  seconds = total_sec % _SECONDS_PER_DAY\n  days = (total_sec - seconds) // _SECONDS_PER_DAY\n  dt = datetime.datetime(1970, 1, 1) + datetime.timedelta(days, seconds)\n\n  result = dt.isoformat()\n  if (nanos % 1e9) == 0:\n    # If there are 0 fractional digits, the fractional\n    # point '.' should be omitted when serializing.\n    return result + 'Z'\n  if (nanos % 1e6) == 0:\n    # Serialize 3 fractional digits.\n    return result + '.%03dZ' % (nanos / 1e6)\n  if (nanos % 1e3) == 0:\n    # Serialize 6 fractional digits.\n    return result + '.%06dZ' % (nanos / 1e3)\n  # Serialize 9 fractional digits.\n  return result + '.%09dZ' % nanos\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/internal/well_known_types.html#client.ayon_hiero.vendor.google.protobuf.internal.well_known_types.Timestamp.ToMicroseconds","title":"<code>ToMicroseconds()</code>","text":"<p>Converts Timestamp to microseconds since epoch.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/internal/well_known_types.py</code> <pre><code>def ToMicroseconds(self):\n  \"\"\"Converts Timestamp to microseconds since epoch.\"\"\"\n  return (self.seconds * _MICROS_PER_SECOND +\n          self.nanos // _NANOS_PER_MICROSECOND)\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/internal/well_known_types.html#client.ayon_hiero.vendor.google.protobuf.internal.well_known_types.Timestamp.ToMilliseconds","title":"<code>ToMilliseconds()</code>","text":"<p>Converts Timestamp to milliseconds since epoch.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/internal/well_known_types.py</code> <pre><code>def ToMilliseconds(self):\n  \"\"\"Converts Timestamp to milliseconds since epoch.\"\"\"\n  return (self.seconds * _MILLIS_PER_SECOND +\n          self.nanos // _NANOS_PER_MILLISECOND)\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/internal/well_known_types.html#client.ayon_hiero.vendor.google.protobuf.internal.well_known_types.Timestamp.ToNanoseconds","title":"<code>ToNanoseconds()</code>","text":"<p>Converts Timestamp to nanoseconds since epoch.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/internal/well_known_types.py</code> <pre><code>def ToNanoseconds(self):\n  \"\"\"Converts Timestamp to nanoseconds since epoch.\"\"\"\n  return self.seconds * _NANOS_PER_SECOND + self.nanos\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/internal/well_known_types.html#client.ayon_hiero.vendor.google.protobuf.internal.well_known_types.Timestamp.ToSeconds","title":"<code>ToSeconds()</code>","text":"<p>Converts Timestamp to seconds since epoch.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/internal/well_known_types.py</code> <pre><code>def ToSeconds(self):\n  \"\"\"Converts Timestamp to seconds since epoch.\"\"\"\n  return self.seconds\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/internal/wire_format.html","title":"wire_format","text":"<p>Constants and static functions to support protocol buffer wire format.</p>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/internal/wire_format.html#client.ayon_hiero.vendor.google.protobuf.internal.wire_format.IsTypePackable","title":"<code>IsTypePackable(field_type)</code>","text":"<p>Return true iff packable = true is valid for fields of this type.</p> <p>Parameters:</p> Name Type Description Default <code>field_type</code> <p>a FieldDescriptor::Type value.</p> required <p>Returns:</p> Type Description <p>True iff fields of this type are packable.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/internal/wire_format.py</code> <pre><code>def IsTypePackable(field_type):\n  \"\"\"Return true iff packable = true is valid for fields of this type.\n\n  Args:\n    field_type: a FieldDescriptor::Type value.\n\n  Returns:\n    True iff fields of this type are packable.\n  \"\"\"\n  return field_type not in NON_PACKABLE_TYPES\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/internal/wire_format.html#client.ayon_hiero.vendor.google.protobuf.internal.wire_format.PackTag","title":"<code>PackTag(field_number, wire_type)</code>","text":"<p>Returns an unsigned 32-bit integer that encodes the field number and wire type information in standard protocol message wire format.</p> <p>Parameters:</p> Name Type Description Default <code>field_number</code> <p>Expected to be an integer in the range [1, 1 &lt;&lt; 29)</p> required <code>wire_type</code> <p>One of the WIRETYPE_* constants.</p> required Source code in <code>client/ayon_hiero/vendor/google/protobuf/internal/wire_format.py</code> <pre><code>def PackTag(field_number, wire_type):\n  \"\"\"Returns an unsigned 32-bit integer that encodes the field number and\n  wire type information in standard protocol message wire format.\n\n  Args:\n    field_number: Expected to be an integer in the range [1, 1 &lt;&lt; 29)\n    wire_type: One of the WIRETYPE_* constants.\n  \"\"\"\n  if not 0 &lt;= wire_type &lt;= _WIRETYPE_MAX:\n    raise message.EncodeError('Unknown wire type: %d' % wire_type)\n  return (field_number &lt;&lt; TAG_TYPE_BITS) | wire_type\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/internal/wire_format.html#client.ayon_hiero.vendor.google.protobuf.internal.wire_format.TagByteSize","title":"<code>TagByteSize(field_number)</code>","text":"<p>Returns the bytes required to serialize a tag with this field number.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/internal/wire_format.py</code> <pre><code>def TagByteSize(field_number):\n  \"\"\"Returns the bytes required to serialize a tag with this field number.\"\"\"\n  # Just pass in type 0, since the type won't affect the tag+type size.\n  return _VarUInt64ByteSizeNoTag(PackTag(field_number, 0))\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/internal/wire_format.html#client.ayon_hiero.vendor.google.protobuf.internal.wire_format.UnpackTag","title":"<code>UnpackTag(tag)</code>","text":"<p>The inverse of PackTag().  Given an unsigned 32-bit number, returns a (field_number, wire_type) tuple.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/internal/wire_format.py</code> <pre><code>def UnpackTag(tag):\n  \"\"\"The inverse of PackTag().  Given an unsigned 32-bit number,\n  returns a (field_number, wire_type) tuple.\n  \"\"\"\n  return (tag &gt;&gt; TAG_TYPE_BITS), (tag &amp; TAG_TYPE_MASK)\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/internal/wire_format.html#client.ayon_hiero.vendor.google.protobuf.internal.wire_format.ZigZagDecode","title":"<code>ZigZagDecode(value)</code>","text":"<p>Inverse of ZigZagEncode().</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/internal/wire_format.py</code> <pre><code>def ZigZagDecode(value):\n  \"\"\"Inverse of ZigZagEncode().\"\"\"\n  if not value &amp; 0x1:\n    return value &gt;&gt; 1\n  return (value &gt;&gt; 1) ^ (~0)\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/internal/wire_format.html#client.ayon_hiero.vendor.google.protobuf.internal.wire_format.ZigZagEncode","title":"<code>ZigZagEncode(value)</code>","text":"<p>ZigZag Transform:  Encodes signed integers so that they can be effectively used with varint encoding.  See wire_format.h for more details.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/internal/wire_format.py</code> <pre><code>def ZigZagEncode(value):\n  \"\"\"ZigZag Transform:  Encodes signed integers so that they can be\n  effectively used with varint encoding.  See wire_format.h for\n  more details.\n  \"\"\"\n  if value &gt;= 0:\n    return value &lt;&lt; 1\n  return (value &lt;&lt; 1) ^ (~0)\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/pyext/index.html","title":"pyext","text":""},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/pyext/cpp_message.html","title":"cpp_message","text":"<p>Protocol message implementation hooks for C++ implementation.</p> <p>Contains helper functions used to create protocol message classes from Descriptor objects at runtime backed by the protocol buffer C++ API.</p>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/pyext/cpp_message.html#client.ayon_hiero.vendor.google.protobuf.pyext.cpp_message.GeneratedProtocolMessageType","title":"<code>GeneratedProtocolMessageType</code>","text":"<p>               Bases: <code>MessageMeta</code></p> <p>Metaclass for protocol message classes created at runtime from Descriptors.</p> <p>The protocol compiler currently uses this metaclass to create protocol message classes at runtime.  Clients can also manually create their own classes at runtime, as in this example:</p> <p>mydescriptor = Descriptor(.....) factory = symbol_database.Default() factory.pool.AddDescriptor(mydescriptor) MyProtoClass = factory.GetPrototype(mydescriptor) myproto_instance = MyProtoClass() myproto.foo_field = 23 ...</p> <p>The above example will not work for nested types. If you wish to include them, use reflection.MakeClass() instead of manually instantiating the class in order to create the appropriate class structure.</p> Source code in <code>client/ayon_hiero/vendor/google/protobuf/pyext/cpp_message.py</code> <pre><code>class GeneratedProtocolMessageType(_message.MessageMeta):\n\n  \"\"\"Metaclass for protocol message classes created at runtime from Descriptors.\n\n  The protocol compiler currently uses this metaclass to create protocol\n  message classes at runtime.  Clients can also manually create their own\n  classes at runtime, as in this example:\n\n  mydescriptor = Descriptor(.....)\n  factory = symbol_database.Default()\n  factory.pool.AddDescriptor(mydescriptor)\n  MyProtoClass = factory.GetPrototype(mydescriptor)\n  myproto_instance = MyProtoClass()\n  myproto.foo_field = 23\n  ...\n\n  The above example will not work for nested types. If you wish to include them,\n  use reflection.MakeClass() instead of manually instantiating the class in\n  order to create the appropriate class structure.\n  \"\"\"\n\n  # Must be consistent with the protocol-compiler code in\n  # proto2/compiler/internal/generator.*.\n  _DESCRIPTOR_KEY = 'DESCRIPTOR'\n</code></pre>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/pyext/python_pb2.html","title":"python_pb2","text":"<p>Generated protocol buffer code.</p>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/util/index.html","title":"util","text":""},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/util/json_format_pb2.html","title":"json_format_pb2","text":"<p>Generated protocol buffer code.</p>"},{"location":"autoapi/client/ayon_hiero/vendor/google/protobuf/util/json_format_proto3_pb2.html","title":"json_format_proto3_pb2","text":"<p>Generated protocol buffer code.</p>"},{"location":"autoapi/server/index.html","title":"server","text":""},{"location":"autoapi/server/settings/index.html","title":"settings","text":""},{"location":"autoapi/server/settings/index.html#server.settings.HieroSettings","title":"<code>HieroSettings</code>","text":"<p>               Bases: <code>BaseSettingsModel</code></p> <p>Nuke addon settings.</p> Source code in <code>server/settings/main.py</code> <pre><code>class HieroSettings(BaseSettingsModel):\n    \"\"\"Nuke addon settings.\"\"\"\n\n    imageio: ImageIOSettings = SettingsField(\n        default_factory=ImageIOSettings,\n        title=\"Color Management (imageio)\",\n    )\n\n    create: CreatorPluginsSettings = SettingsField(\n        default_factory=CreatorPluginsSettings,\n        title=\"Creator Plugins\",\n    )\n    load: LoaderPluginsModel = SettingsField(\n        default_factory=LoaderPluginsModel,\n        title=\"Loader plugins\"\n    )\n    publish: PublishPluginsModel = SettingsField(\n        default_factory=PublishPluginsModel,\n        title=\"Publish plugins\"\n    )\n    scriptsmenu: ScriptsmenuSettings = SettingsField(\n        default_factory=ScriptsmenuSettings,\n        title=\"Scripts Menu Definition\",\n    )\n    filters: list[PublishGUIFilterItemModel] = SettingsField(\n        default_factory=list\n    )\n</code></pre>"},{"location":"autoapi/server/settings/common.html","title":"common","text":""},{"location":"autoapi/server/settings/create_plugins.html","title":"create_plugins","text":""},{"location":"autoapi/server/settings/filters.html","title":"filters","text":""},{"location":"autoapi/server/settings/imageio.html","title":"imageio","text":""},{"location":"autoapi/server/settings/imageio.html#server.settings.imageio.ImageIOSettings","title":"<code>ImageIOSettings</code>","text":"<p>               Bases: <code>BaseSettingsModel</code></p> <p>Hiero color management project settings.</p> Source code in <code>server/settings/imageio.py</code> <pre><code>class ImageIOSettings(BaseSettingsModel):\n    \"\"\"Hiero color management project settings. \"\"\"\n    _isGroup: bool = True\n    activate_host_color_management: bool = SettingsField(\n        True, title=\"Enable Color Management\"\n    )\n    file_rules: ImageIOFileRulesModel = SettingsField(\n        default_factory=ImageIOFileRulesModel,\n        title=\"File Rules\"\n    )\n    workfile: WorkfileColorspaceSettings = SettingsField(\n        default_factory=WorkfileColorspaceSettings,\n        title=\"Workfile\"\n    )\n    \"\"\"# TODO: enhance settings with host api:\n    - old settings are using `regexInputs` key but we\n      need to rename to `regex_inputs`\n    - no need for `inputs` middle part. It can stay\n      directly on `regex_inputs`\n    \"\"\"\n    regexInputs: RegexInputsModel = SettingsField(\n        default_factory=RegexInputsModel,\n        title=\"Assign colorspace to clips via rules\"\n    )\n</code></pre>"},{"location":"autoapi/server/settings/imageio.html#server.settings.imageio.ImageIOSettings.workfile","title":"<code>workfile = SettingsField(default_factory=WorkfileColorspaceSettings, title='Workfile')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"autoapi/server/settings/imageio.html#server.settings.imageio.ImageIOSettings.workfile--todo-enhance-settings-with-host-api","title":"TODO: enhance settings with host api:","text":"<ul> <li>old settings are using <code>regexInputs</code> key but we   need to rename to <code>regex_inputs</code></li> <li>no need for <code>inputs</code> middle part. It can stay   directly on <code>regex_inputs</code></li> </ul>"},{"location":"autoapi/server/settings/imageio.html#server.settings.imageio.WorkfileColorspaceSettings","title":"<code>WorkfileColorspaceSettings</code>","text":"<p>               Bases: <code>BaseSettingsModel</code></p> <p>Hiero workfile colorspace preset.</p> Source code in <code>server/settings/imageio.py</code> <pre><code>class WorkfileColorspaceSettings(BaseSettingsModel):\n    \"\"\"Hiero workfile colorspace preset. \"\"\"\n    \"\"\"# TODO: enhance settings with host api:\n    we need to add mapping to resolve properly keys.\n    Hiero is excpecting camel case key names,\n    but for better code consistency we are using snake_case:\n\n    ocio_config = ocioConfigName\n    working_space_name = workingSpace\n    int_16_name = sixteenBitLut\n    int_8_name = eightBitLut\n    float_name = floatLut\n    log_name = logLut\n    viewer_name = viewerLut\n    thumbnail_name = thumbnailLut\n    \"\"\"\n\n    ocioConfigName: str = SettingsField(\n        title=\"OpenColorIO Config\",\n        description=\"Switch between OCIO configs\",\n        enum_resolver=ocio_configs_switcher_enum,\n        conditionalEnum=True\n    )\n    workingSpace: str = SettingsField(\n        title=\"Working Space\"\n    )\n    viewerLut: str = SettingsField(\n        title=\"Viewer\"\n    )\n    eightBitLut: str = SettingsField(\n        title=\"8-bit files\"\n    )\n    sixteenBitLut: str = SettingsField(\n        title=\"16-bit files\"\n    )\n    logLut: str = SettingsField(\n        title=\"Log files\"\n    )\n    floatLut: str = SettingsField(\n        title=\"Float files\"\n    )\n    thumbnailLut: str = SettingsField(\n        title=\"Thumnails\"\n    )\n    monitorOutLut: str = SettingsField(\n        title=\"Monitor\"\n    )\n</code></pre>"},{"location":"autoapi/server/settings/loader_plugins.html","title":"loader_plugins","text":""},{"location":"autoapi/server/settings/main.html","title":"main","text":""},{"location":"autoapi/server/settings/main.html#server.settings.main.HieroSettings","title":"<code>HieroSettings</code>","text":"<p>               Bases: <code>BaseSettingsModel</code></p> <p>Nuke addon settings.</p> Source code in <code>server/settings/main.py</code> <pre><code>class HieroSettings(BaseSettingsModel):\n    \"\"\"Nuke addon settings.\"\"\"\n\n    imageio: ImageIOSettings = SettingsField(\n        default_factory=ImageIOSettings,\n        title=\"Color Management (imageio)\",\n    )\n\n    create: CreatorPluginsSettings = SettingsField(\n        default_factory=CreatorPluginsSettings,\n        title=\"Creator Plugins\",\n    )\n    load: LoaderPluginsModel = SettingsField(\n        default_factory=LoaderPluginsModel,\n        title=\"Loader plugins\"\n    )\n    publish: PublishPluginsModel = SettingsField(\n        default_factory=PublishPluginsModel,\n        title=\"Publish plugins\"\n    )\n    scriptsmenu: ScriptsmenuSettings = SettingsField(\n        default_factory=ScriptsmenuSettings,\n        title=\"Scripts Menu Definition\",\n    )\n    filters: list[PublishGUIFilterItemModel] = SettingsField(\n        default_factory=list\n    )\n</code></pre>"},{"location":"autoapi/server/settings/publish_plugins.html","title":"publish_plugins","text":""},{"location":"autoapi/server/settings/publish_plugins.html#server.settings.publish_plugins.CollectClipEffectsDefModel","title":"<code>CollectClipEffectsDefModel</code>","text":"<p>               Bases: <code>BaseSettingsModel</code></p> Source code in <code>server/settings/publish_plugins.py</code> <pre><code>class CollectClipEffectsDefModel(BaseSettingsModel):\n    _layout = \"expanded\"\n    name: str = SettingsField(\"\", title=\"Name\")\n    effect_classes: list[str] = SettingsField(\n        default_factory=list, title=\"Effect Classes\"\n    )\n\n    @validator(\"name\")\n    def validate_name(cls, value):\n        \"\"\"Ensure name does not contain weird characters\"\"\"\n        return normalize_name(value)\n</code></pre>"},{"location":"autoapi/server/settings/publish_plugins.html#server.settings.publish_plugins.CollectClipEffectsDefModel.validate_name","title":"<code>validate_name(value)</code>","text":"<p>Ensure name does not contain weird characters</p> Source code in <code>server/settings/publish_plugins.py</code> <pre><code>@validator(\"name\")\ndef validate_name(cls, value):\n    \"\"\"Ensure name does not contain weird characters\"\"\"\n    return normalize_name(value)\n</code></pre>"},{"location":"autoapi/server/settings/scriptsmenu.html","title":"scriptsmenu","text":""},{"location":"autoapi/server/settings/scriptsmenu.html#server.settings.scriptsmenu.ScriptsmenuSettings","title":"<code>ScriptsmenuSettings</code>","text":"<p>               Bases: <code>BaseSettingsModel</code></p> <p>Nuke script menu project settings.</p> Source code in <code>server/settings/scriptsmenu.py</code> <pre><code>class ScriptsmenuSettings(BaseSettingsModel):\n    \"\"\"Nuke script menu project settings.\"\"\"\n    _isGroup = True\n\n    \"\"\"# TODO: enhance settings with host api:\n    - in api rename key `name` to `menu_name`\n    \"\"\"\n    name: str = SettingsField(title=\"Menu name\")\n    definition: list[ScriptsmenuSubmodel] = SettingsField(\n        default_factory=list,\n        title=\"Definition\",\n        description=\"Scriptmenu Items Definition\")\n</code></pre>"},{"location":"autoapi/server/settings/scriptsmenu.html#server.settings.scriptsmenu.ScriptsmenuSubmodel","title":"<code>ScriptsmenuSubmodel</code>","text":"<p>               Bases: <code>BaseSettingsModel</code></p> <p>Item Definition</p> Source code in <code>server/settings/scriptsmenu.py</code> <pre><code>class ScriptsmenuSubmodel(BaseSettingsModel):\n    \"\"\"Item Definition\"\"\"\n    _isGroup = True\n\n    type: str = SettingsField(title=\"Type\")\n    command: str = SettingsField(title=\"Command\")\n    sourcetype: str = SettingsField(title=\"Source Type\")\n    title: str = SettingsField(title=\"Title\")\n    tooltip: str = SettingsField(title=\"Tooltip\")\n</code></pre>"}]}